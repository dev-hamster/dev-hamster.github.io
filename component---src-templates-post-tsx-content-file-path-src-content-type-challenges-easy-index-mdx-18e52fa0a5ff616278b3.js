"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[253],{8370:function(e,n,t){t.r(n),t.d(n,{default:function(){return E}});var l=t(1151),a=t(7294);function r(e){const n=Object.assign({h2:"h2",h3:"h3",p:"p",ul:"ul",li:"li",code:"code",span:"span",strong:"strong",a:"a",blockquote:"blockquote"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h2,null,"PICK-4"),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"pick을 사용하지 않고 Pick을 구현하는 문제이다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.code,null,"keyof")," 는 객체의 키 값들을 숫자나 문자열 리터럴 유니언을 생성한다."),"\n",a.createElement(n.li,null,a.createElement(n.code,null,"in")," 는 객체에 특정 속성이 존재하는지 확인할 수 있다."),"\n"),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MyPick&lt;T, K extends keyof T> = {\n  [k in K]: T[k]\n}</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"K extends keyof T")," K는 T의 프로퍼티 이름을 가진다. 매핑된 타입을 이용하면 키를 통해 타입을 반복적으로 생성할 수 있고 인덱스 시그니처 문법으로 작성하면 된다."),"\n",a.createElement(n.h2,null,"Readonly"),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"Readonly 타입을 사용하지 않고 구현하는 문제이다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.code,null,"readonly")," 는 프로퍼티를 읽기 전용으로 지정할 수 있다."),"\n"),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MyReadonly&lt;T> = {\n  readonly [P in keyof T]: T[P]\n}</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Tuple to Object")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"각 원소의 값을 key/value로 갖는 오브젝트 타입을 반환하는 타입을 구현하는 문제이다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 배열의 원소의 값을 key/value로 갖는 타입을 반환한다.\n['tesla', 'model 3', 'model X', 'model Y']\n\n{ 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}</code></pre></div>"}}),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type TupleToObject&lt;T extends readonly PropertyKey[]> = {\n  [P in T[number]] : P\n}</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"배열 순회하기: ",a.createElement(n.code,null,"T[number]"),"을 통해 배열을 순회하여 타입을 가져올 수 있다. ",a.createElement(n.code,null,"T[number]")," 은 인덱스가 숫자형인 요소들의 타입을 가져오므로 배열에 있는 모든 요소의 타입을 가져올 수 있다."),"\n",a.createElement(n.li,null,"PropertyKey: ",a.createElement(n.code,null,"keyof")," 를 통해 생성되는 key의 집합이다. 여기에는 string, number, symbol이 있다."),"\n"),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"First of Array")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"T"),"를 받아 첫번째 원소의 타입을 반환하는 제네릭 ",a.createElement(n.code,null,"First<T>"),"를 구현하는 문제이다."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 오답: 빈 배열인 경우 T[0]은 undefeind가 된다\ntype First&lt;T extends any[]> = T[0] extends never ? never : T[0]; // 원소가 없다면 never 타입 반환\n\n// 정답1\ntype First&lt;T extends unknown[]> = T[number] extends never ? never : T[0];\n// 정답2\ntype First&lt;T extends unknown[]> = T extends [] ? never : T[0];</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"조건부 타입: 배열이 빈 배열이라면 ",a.createElement(n.code,null,"never")," 타입을 반환한다."),"\n"),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Length of Tuple")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"튜블(배열)의 길이를 반환하는 제네릭 타입을 구현하는 문제이다."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 오답: Length&lt;5>인 경우 타입 에러가 나지 않는다.\ntype Length&lt;T> = T extends readonly unknown[] ? T[\'length\'] : never;</code></pre></div>'}}),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"<T extends readonly unknown[]>")," 는 T가 ",a.createElement(n.code,null,"readonly unknown[ ]"),"이라는 타입을 반드시 만족해야 하므로 배열이 아닌 경우 타입 에러를 발생한다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 정답\ntype Length&lt;T extends readonly unknown[]> = T["length"];</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.code,null,"readonly"),": 튜플은 고정된 요소를 저장하므로 readonly이다."),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"T extends readonly unknown[]")," 에서 T가 배열 타입인지 조건부로 타입을 할당한다. 이런 경우 배열이 아닌 경우 ",a.createElement(n.code,null,"never"),"를 반환하기 때문에 타입 에러가 나지 않는다."),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Exclude")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"T에서 U에 할당할 수 있는 타입을 제외하는 내장 제네릭 Exclude를 사용하지 않고 구현하는 문제이다."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MyExclude&lt;T, U> = T extends U ? never : T;</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.code,null,"Exclude"),": ",a.createElement(n.code,null,"Exclude<T, U>")," 는 U에 할당할 수 있는 타입을 제외한다. 차집합으로 이해할 수 있다."),"\n",a.createElement(n.li,null,"분배법칙: 조건부 타입에서 분배법칙이 적용된다. 예를 들어 ",a.createElement(n.code,null,"A | B | C extends U ? X : Y")," 는 ",a.createElement(n.code,null,"A extends U ? X : Y"),", ",a.createElement(n.code,null,"B extends U ? X : Y"),", ",a.createElement(n.code,null,"C extends U ? X : Y")," 가 된다. ",a.createElement(n.code,null,"T extends U ? X : Y")," 에서 T 유니언 타입은 개별 구성 요소를 확인한다."),"\n"),"\n",a.createElement(n.p,null,"T가 U에 속한다면, never를 반환한다."),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Awaited")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"Promise와 같은 타입에 감싸인 타입이 있을 때, 안에 감싸인 타입이 무엇인지 가르키는 타입을 구현하는 문제이다."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MyAwaited&lt;T> = T extends PromiseLike&lt;infer D> ? MyAwaited&lt;D> : T;</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.p,null,"Promise에 감싸진 리턴 타입을 반환하기 위해 T가 Promise라면 Promise를 재귀적으로 풀어주고 그렇지 않다면 T를 반환하면 된다."),"\n",a.createElement(n.p,null,"예를 들어 타입 ",a.createElement(n.code,null,"X"),"에서 Promise로 감싸진 타입을 가져올 때 다음처럼 동작한다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MyAwaited&lt;T> = T extends PromiseLike&lt;infer D> ? MyAwaited&lt;D> : T;\n\ntype X = Promise&lt;string>\ntype Foo = MyAwaited&lt;X> // string</code></pre></div>'}}),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"MyAwaited<Promise<string>>"),"은 ",a.createElement(n.code,null,"PromiseLike<infer D>"),"타입에 해당하므로 다시 ",a.createElement(n.code,null,"MyAwaited<D>")," 을 호출한다. 여기서 ",a.createElement(n.code,null,"infer D")," 로 string을 추론한다. ",a.createElement(n.code,null,"MyAwaited<string>")," 은 ",a.createElement(n.code,null,"PromiseLike"),"타입이 아니므로 타입 ",a.createElement(n.code,null,"string"),"을 반환한다."),"\n",a.createElement(n.h3,null,a.createElement(n.code,null,"infer"),"란?"),"\n",a.createElement(n.p,null,"조건부 타입에서 ",a.createElement(n.code,null,"infer")," 키워드를 이용해 새로운 타입 변수를 선언적으로 정의할 수 있다. ",a.createElement(n.code,null,"type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;")),"\n",a.createElement(n.h3,null,a.createElement(n.code,null,"Promise"),"가 아닌 ",a.createElement(n.code,null,"PromiseLike"),"를 사용하는 이유"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"Promise"),"가 아닌 ",a.createElement(n.code,null,"PromiseLike"),"를 사용하는 이유는 아래 테스트 케이스가 존재하기 때문이다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type T = { then: (onfulfilled: (arg: number) => any) => any }</code></pre></div>'}}),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"PromiseLike"),"타입에는 후속처리 메서드인 then만 가지고 있다. 이를 통해 커스텀 비동기 처리를 유연하게 정의할 수 있다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// https://github.com/microsoft/TypeScript/blob/main/src/lib/es5.d.ts\n\ninterface PromiseLike&lt;T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then&lt;TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike&lt;TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike&lt;TResult2>) | undefined | null\n      ): PromiseLike&lt;TResult1 | TResult2>;\n}</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"If")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"조건 C가 참이면 A, 아니면 B를 반환하는 타입을 구현하자."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type If&lt;C extends boolean, T, F> = C extends true ? T : F;</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.p,null,"C는 true, false만 가능하도록 ",a.createElement(n.code,null,"boolean")," 타입으로 제한하고 C 조건에 따라 T, F를 리턴하면 된다."),"\n",a.createElement(n.h2,null,"Concat"),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"Array.concat 함수를 타입 시스템에서 구현하자. 인수를 왼쪽부터 concat한 새로운 배열을 반환하자."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 오답\ntype Concat&lt;T extends unknown[], U extends unknown[]> = [\n  T extends [] ? never : T[number],\n  U extends [] ? never : U[number]\n];\n\ntype Foo = Concat&lt;[\'1\', 2, 3], []>; // [2 | 3 | "1", never]</code></pre></div>'}}),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 정답\ntype Tuple = readonly unknown[];\ntype Concat&lt;T extends Tuple, U extends Tuple> = [...T, ...U];\n\ntype Foo = Concat&lt;[\'1\', 2, 3], []>; //  ["1", 2, 3]</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.p,null,"T와 U를 concat할 수 있도록 T와 U를 배열로 타입을 제한했다. 요소의 타입으로 이루어진 튜플을 반환할 수 있도록 ",a.createElement(n.code,null,"T[number]")," 를 했다. 그러나 ",a.createElement(n.code,null,"T[number]"),"는 배열의 요소 타입으로 이뤄진 유니언 타입을 추출한다. 그리고 빈 배열인 경우 never 타입이 반환되므로 오답이다."),"\n",a.createElement(n.p,null,"여기서 T와 U를 배열타입으로 제한했으므로 열거 가능하다."),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Includes")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"JavaScript의 ",a.createElement(n.code,null,"Array.includes")," 함수를 타입 시스템에서 구현하세요. 타입은 두 인수를 받고, ",a.createElement(n.code,null,"true")," 또는 ",a.createElement(n.code,null,"false"),"를 반환하자."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 오답\ntype Includes&lt;T extends readonly unknown[], U> = U extends T[number] ? true : false;</code></pre></div>'}}),"\n",a.createElement(n.p,null,"T 배열의 요소를 키로 갖는 타입을 만들고 U가 T의 키인지 확인하면 해결할 수 있을 것 같지만, U가 프로퍼티 키로 사용할 수 있을 때만 통과된다. (",a.createElement(n.a,{href:"https://github.com/type-challenges/type-challenges/issues/1568"},"참고"),")"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 오답\ntype Includes&lt;T extends readonly any[], U> = {\n  [P in T[number]]: true\n}[U] extends true ? true : false;</code></pre></div>'}}),"\n",a.createElement(n.p,null,"이를 해결하기 위해 배열의 첫번째 요소와 타입이 같은지 재귀적으로 타입을 확인해야 한다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 정답\ntype Includes&lt;T extends readonly unknown[], U> =\n  T extends [infer First, ...infer Rest]\n    ? Equal&lt;First, U> extends true ? true : Includes&lt;Rest, U>\n    : false;</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.p,null,"U가 T의 구성 요소인지 확인하기 위해 T를 인덱스 접근 타입으로 변경하고 U가 이 유니온 타입에 속하는지 조건부로 true 또는 false를 반환한다. 그런데 이 코드는 primitive type만 통과하고 객체나 타입 자체는 통과하지 않는다. 예를 들어 ",a.createElement(n.code,null,"{ a: 'A'}")," 는 ",a.createElement(n.code,null,"{ }"),"의 서브 타입으로 true를 반환한다."),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,a.createElement(n.code,null,"infer")," 키워드를 복습하고 가자. ",a.createElement(n.code,null,"infer"),"은 조건부 타입에서 ",a.createElement(n.strong,null,"참으로 평가"),"될 때 사용할 수 있는 타입을 추론하는 데 사용한다."),"\n"),"\n",a.createElement(n.p,null,"참고로 ",a.createElement(n.code,null,"@type-challenges/utils")," 의 Equal은 아래처럼 구현되어 있다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Equal&lt;X, Y> =\n    (&lt;T>() => T extends X ? 1 : 2) extends\n    (&lt;T>() => T extends Y ? 1 : 2) ? true : false;</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Push")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"Array.push"),"의 제네릭 버전을 구현하자."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Push&lt;T extends unknown[], U> = [...T, U];</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.p,null,"T를 배열로 타입을 제한하고 배열 디스트럭쳐링을 이용해 배열 타입을 반환한다."),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Unshift")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"Array.unshift"),"의 타입 버전을 구현하자."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Unshift&lt;T extends unknown[], U> = [U, ...T];</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.p,null,"Push 문제와 동일하다. T와 U 순서만 바꿔주면 된다."),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Parameters")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"내장 제네릭 ",a.createElement(n.code,null,"Parameters<T>"),"를 이를 사용하지 않고 구현하자."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MyParameters&lt;T> = T extends (...args: infer D) => unknown ? D : any;\n\nconst temp = [\'1\'];\ntype x = MyParameters&lt;typeof temp>; // 타입 에러가 나지 않는다.</code></pre></div>'}}),"\n",a.createElement(n.p,null,"타입 에러가 나지 않는데, 이를 막으려면 타입 T를 함수로 제한하면 된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MyParameters&lt;T extends (...args: any[]) => any> = T extends (...any: infer S) => any ? S : any</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"풀이"),"\n",a.createElement(n.p,null,"조건부 타입으로 함수 타입이라면 args를 추론한 D 타입을 반환한다. 하지만 T타입이 함수로 제한하지 않아 함수가 아닌 타입에서 에러가 나지 않아서 아쉽다."))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},s=t(4160),u=t(4098),d=t(1858),o=t(8032),m=t(9542);const g={Link:s.rU};function i(e){let{data:n,children:t}=e;const{frontmatter:r}=n.mdx,c=(0,m.E)(r.thumbnail);return a.createElement(a.Fragment,null,a.createElement(u.h,null),a.createElement(d.A,null,a.createElement(l.Zo,{components:Object.assign({ul:e=>a.createElement("ul",Object.assign({},e,{style:{listStyle:"revert"}})),ol:e=>a.createElement("ul",Object.assign({},e,{style:{listStyleType:"decimal"}}))},g)},a.createElement("article",{className:"markdown-body"},a.createElement("h1",null,r.title),c&&a.createElement("div",{style:{position:"relative",width:"100%",paddingBottom:"56.25%"}},a.createElement(o.G,{image:c,alt:r.title,className:"absolute top-0 left-0 w-full h-full object-cover"})),t))))}function E(e){return a.createElement(i,e,a.createElement(c,e))}},9542:function(e,n,t){t.d(n,{E:function(){return l}});const l=e=>{if(e)return"childImageSharp"in e?e.childImageSharp.gatsbyImageData:e}},1151:function(e,n,t){t.d(n,{Zo:function(){return s},ah:function(){return r}});var l=t(7294);const a=l.createContext({});function r(e){const n=l.useContext(a);return l.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const c={};function s({components:e,children:n,disableParentContext:t}){let s;return s=t?"function"==typeof e?e({}):e||c:r(e),l.createElement(a.Provider,{value:s},n)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-content-type-challenges-easy-index-mdx-18e52fa0a5ff616278b3.js.map