"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[376],{1971:function(e,n,t){t.r(n),t.d(n,{default:function(){return p}});var l=t(1151),a=t(7294);function r(e){const n=Object.assign({h2:"h2",strong:"strong",h3:"h3",p:"p",code:"code",span:"span",ul:"ul",li:"li",em:"em",blockquote:"blockquote",hr:"hr"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h2,null,a.createElement(n.strong,null,"Get Return Type")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"내장 제네릭 ",a.createElement(n.code,null,"ReturnType<T>"),"을 이를 사용하지 않고 구현하자"),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 아쉬운 정답\ntype MyReturnType&lt;T extends (...args: any) => unknown> =\n  T extends (...args:any) => infer U\n      ? U\n      : never;</code></pre></div>'}}),"\n",a.createElement(n.p,null,"함수 인자 타입을 ",a.createElement(n.code,null,"never[]")," 로 하면 모든 테스트 케이스가 통과된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 정답\ntype MyReturnType&lt;T extends (...args: never[]) => unknown> =\n  T extends (...args: never[]) => infer R\n    ? R\n    : never</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"해설"),"\n",a.createElement(n.p,null,"리턴되는 타입을 ",a.createElement(n.code,null,"infer U"),"로 추론하고 U를 반환한다. 하지만 함수 인수를 받는 타입을 ",a.createElement(n.code,null,"unknown[]")," 으로 하면 테스트 케이스가 일부만 통과해서 ",a.createElement(n.code,null,"any"),"로 변경해 모두 통과되도록 했다."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,a.createElement(n.code,null,"unknown[]"),"이 안되는 이유")),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"unknown")," 은 모든 타입의 상위 타입이므로 모든 타입은 ",a.createElement(n.code,null,"unknown"),"에 할당할 수 있다. 그렇기 때문에 ",a.createElement(n.code,null,"unknown")," 은 가장 일반적인 타입이기 때문에 구체적인 타입과 호환되지 않는다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type foo = unknown extends string ? true : false; // false</code></pre></div>'}}),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,a.createElement(n.code,null,"never[]")," 를 사용하는 이유")),"\n",a.createElement(n.p,null,"never는 존재하지 않는 공집합이기 때문에 any를 포함해 어떤 값도 가질 수 없는 가장 구체적인 타입이어서 다른 타입들과 호환될 수 있다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type foo = never extends string ? true : false; // true</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Omit")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"T"),"에서 ",a.createElement(n.code,null,"K")," 프로퍼티만 제거해 새로운 오브젝트 타입을 만드는 내장 제네릭 ",a.createElement(n.code,null,"Omit<T, K>"),"를 이를 사용하지 않고 구현하자."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.p,null,"T의 프로퍼티 키에서 K가 아니라면 키값을 추출하는 코드를 의도했다. 이 코드는 infer의 잘못된 사용으로 동작하지 않는다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 오답\ntype MyOmit&lt;T, K extends keyof T> = K extends infer Key keyof T ?\n  never :\n  { Key: T[Key] }</code></pre></div>'}}),"\n",a.createElement(n.p,null,"정답 코드는 이렇다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 정답\ntype MyOmit&lt;T, K extends keyof T> = {[Key in keyof T as Key extends K ? never: Key]: T[Key]}</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"해설"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,a.createElement(n.code,null,"as")," 키워드")),"\n",a.createElement(n.p,null,"as 키용해 이용해 맵드 타입의 키를 다시 매핑할 수 있다. 예를들어 모든 프로퍼티 키를 Hamster라고 키 이름을 다시 매핑할 수 있다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MappedTypeWithNewProperties&lt;Type> = {\n    [Properties in keyof Type as \'Hamster\']: Type[Properties]\n}</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Readonly 2")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"T"),"에서 ",a.createElement(n.code,null,"K")," 프로퍼티만 읽기 전용으로 설정해 새로운 오브젝트 타입을 만드는 제네릭 ",a.createElement(n.code,null,"MyReadonly2<T, K>"),"를 구현하세요. ",a.createElement(n.code,null,"K"),"가 주어지지 않으면 단순히 ",a.createElement(n.code,null,"Readonly<T>"),"처럼 모든 프로퍼티를 읽기 전용으로 설정해야 합니다."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MyReadonly2&lt;T, K extends keyof T = keyof T> = { readonly [k in K]: T[k] } &amp; Omit&lt;T, K>;</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"해설"),"\n",a.createElement(n.p,null,"K 프로퍼티는 readonly 속성을 부여하면 된다. 구현은 정답을 참고했다."),"\n",a.createElement(n.p,null,"K가 주어지지 않는 경우를 위해 ",a.createElement(n.code,null,"K extends keyof T = keyof T")," default 값을 설정한다."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"교차 타입 &")),"\n",a.createElement(n.p,null,"두 개 이상의 타입을 결합해 모든 타입의 속성을 포함하는 새로운 타입을 생성할 수 있다. ",a.createElement(n.code,null,"A & B"),"는 ",a.createElement(n.code,null,"A"),"와 ",a.createElement(n.code,null,"B"),"의 모든 속성을 포함하는 새로운 타입이 된다."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"유니온 타입 |")),"\n",a.createElement(n.p,null,"두 개 이상의 타입 중 하나를 선택할 수 있는 새로운 타입을 생성한다. ",a.createElement(n.code,null,"A | B")," 는 ",a.createElement(n.code,null,"A"),"또는 ",a.createElement(n.code,null,"B")," 중 하나의 타입을 가질 수 있다."),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Deep Readonly")),"\n",a.createElement(n.h3,null,"문제"),"\n",a.createElement(n.p,null,"객체의 프로퍼티와 모든 하위 객체를 재귀적으로 읽기 전용으로 설정하는 제네릭 ",a.createElement(n.code,null,"DeepReadonly<T>"),"를 구현하세요."),"\n",a.createElement(n.p,null,"이 챌린지에서는 타입 파라미터 ",a.createElement(n.code,null,"T"),"를 객체 타입으로 제한하고 있습니다. 객체뿐만 아니라 배열, 함수, 클래스 등 가능한 다양한 형태의 타입 파라미터를 사용하도록 도전해 보세요."),"\n",a.createElement(n.h3,null,"코드"),"\n",a.createElement(n.p,null,"중첩된 객체 프로퍼티의 타입을 반환하는 타입은 만들었는데 다음은 어떻게 해야할까?"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 오답\ntype DeepReadonly&lt;T> = T extends object ? DeepReadonly&lt;T[keyof T]> : T</code></pre></div>'}}),"\n",a.createElement(n.p,null,"정답을 참고해서 ",a.createElement(n.code,null,"readonly")," 타입을 반환하도록 했는데, 중첩된 객체에서는 ",a.createElement(n.code,null,"readonly"),"가 안된다. (아래 코드가 왜 잘못됐는지 모르겠다🥲 )"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 오답\ntype DeepReadonly&lt;T> = T extends Record&lt;PropertyKey, unknown> ?\n  { readonly [P in keyof T]: DeepReadonly&lt;T[P]> }\n  :\n  T;\n\ntype x = DeepReadonly&lt;{l: [\n        \'hi\',\n        {\n          m: [\'hey\']\n        },\n      ]}>;\n\n// 결과\n// type x = {\n//  readonly l: ["hi", {\n//      m: ["hey"];\n//    }];\n//  }\n\n// 기댓값\n// type x = {\n//  readonly l: readonly ["hi", {\n//      readonly m: readonly ["hey"];\n//    }];\n//  }</code></pre></div>'}}),"\n",a.createElement(n.p,null,"정답 코드를 보면 ",a.createElement(n.code,null,"T"),"에 프로퍼티 키로 접근할 수 있는 값이 없다면 T[K]를 반환하고 그렇지 않다면 재귀적으로 ",a.createElement(n.code,null,"DeepReadonly<T[K]>")," 를 호출한다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// 정답\ntype DeepReadonly&lt;T> = {\n  readonly [K in keyof T]: keyof T[K] extends never ? T[K] : DeepReadonly&lt;T[K]>\n}</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"해설"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"TypeScript 에서 ",a.createElement(n.code,null,"{}")," vs ",a.createElement(n.code,null,"Object")," vs ",a.createElement(n.code,null,"object"))),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.code,null,"{}")," 는 빈 객체가 아닌 any non-nullsih value이므로 ",a.createElement(n.code,null,"undefined"),", ",a.createElement(n.code,null,"null"),"을 제외한 모든 타입을 할당할 수 있다."),"\n",a.createElement(n.li,null,a.createElement(n.code,null,"Object")," 도 ",a.createElement(n.code,null,"{}")," 와 동일하다."),"\n",a.createElement(n.li,null,a.createElement(n.code,null,"object")," 는 원시값을 제외한 모든 값이 할당 가능하다."),"\n"),"\n",a.createElement(n.p,null,"빈 객체",a.createElement(n.code,null,"{}")," 타입만을 허용하고 싶다면 ",a.createElement(n.code,null,"never"),"를 사용하자. 자바스크립트의 객체 타입(중괄호로 이루어진 객체)만을 허용하고 싶다면 Record를 사용하면 된다."),"\n",a.createElement(n.p,null,a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/145633b0b43672218acc597e5e844146/41099/mind.jpg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQD/8QAFwEAAwEAAAAAAAAAAAAAAAAAAAECBP/aAAwDAQACEAMQAAABwqg10552hOCsm5wH/8QAGxAAAgIDAQAAAAAAAAAAAAAAAQIAAxESEzH/2gAIAQEAAQUCSsWNzUllAYWhVSxuaAMM4lbbN7P/xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQMBAT8BdjP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAeEAABAwQDAAAAAAAAAAAAAAABAAIREDFBcRIiUv/aAAgBAQAGPwIukQoyLK8roNonKnm0boZ80//EAB0QAQADAAEFAAAAAAAAAAAAAAEAESFBMVFhgaH/2gAIAQEAAT8hQ4HqGRxmFK7I45dWmaAvugAgCW94NoIZFxEtnqHN+T//2gAMAwEAAgADAAAAEFvwvf/EABcRAAMBAAAAAAAAAAAAAAAAAAABERD/2gAIAQMBAT8QSivX/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQAREP/aAAgBAgEBPxDDJCHn/8QAHRABAAMBAAIDAAAAAAAAAAAAAQARMSFBUWGBof/aAAgBAQABPxBcViXfijxKMIoVB3pNgOiyrvqMDAtSneh42dds2aj8e5YPLoH8j5dLyVRoBSg1z7LhA8le4J//2Q==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="mind"\n        title=""\n        src="/static/145633b0b43672218acc597e5e844146/41099/mind.jpg"\n        srcset="/static/145633b0b43672218acc597e5e844146/f93b5/mind.jpg 300w,\n/static/145633b0b43672218acc597e5e844146/41099/mind.jpg 500w"\n        sizes="(max-width: 500px) 100vw, 500px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),a.createElement(n.em,null,"타입스크립트는 어렵네요")),"\n",a.createElement(n.h2,null,"문제 풀기에 앞서…"),"\n",a.createElement(n.p,null,"문제 풀기에 앞서 아직 헷갈리는 내용을 짚고 넘어가보자."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"정적 타입 검사:")),"\n",a.createElement(n.p,null,"타입스크립트는 프로그램을 실행시키지 않고 오류를 검출한다."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"점진적 타입 시스템:")),"\n",a.createElement(n.p,null,"타입스크립트는 타입 검사를 점진적으로 적용해 동적 타입처럼 자유롭게 타입을 작성할 수 있다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">let a = 10;  // 타입스크립트가 자동으로 number로 추론 (자동 타입 추론)\nlet b;       // 타입 명시가 없으므로 b는 암시적으로 any 타입을 가짐\nb = "hello"; // b에 어떤 값이든 할당 가능 (any 타입)\nb = 42;      // any 타입이기 때문에 타입 오류 없음</code></pre></div>'}}),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"구조적 타입 시스템이란:")),"\n",a.createElement(n.p,null,"타입스크립트 컴파일러는 두 타입의 명시적 선언이 아닌 ",a.createElement(n.strong,null,"프로퍼티를 비교"),"하여 타입을 비교한다. 그러니까 타입 ",a.createElement(n.code,null,"Hamster"),"과 ",a.createElement(n.code,null,"Animal"),"이 있을 때, ",a.createElement(n.code,null,"Hamster")," ⊂ ",a.createElement(n.code,null,"Animal"),"를 만족한다. ",a.createElement(n.code,null,"Hamster"),"의 프로퍼티는 ",a.createElement(n.code,null,"Animal"),"를 만족시키기 때문에 ",a.createElement(n.code,null,"Hamster"),"타입에 ",a.createElement(n.code,null,"Animal"),"을 할당할 수 있고 ",a.createElement(n.code,null,"Hamster"),"은 ",a.createElement(n.code,null,"Animal"),"타입과 호환이 가능하다."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Indexed Access Type:")),"\n",a.createElement(n.p,null,"인덱스를 사용해 객체의 프로퍼티 타입을 추출할 수 있다. 배열 요소의 타입을 가져오려면 ",a.createElement(n.code,null,"Foo[number]")," 로 하면 된다."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"infer:")),"\n",a.createElement(n.p,null,"조건부 타입의 ",a.createElement(n.code,null,"extends")," 절 안에서 infer을 이용해 타입 변수를 추론할 수 있다. 이렇게 추론된 타입은 분기에서 참조될 수 있다."),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Tuple to Union")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"튜플 값으로 유니온 타입을 생성하는 제네릭 ",a.createElement(n.code,null,"TupleToUnion<T>"),"를 구현하세요."),"\n"),"\n",a.createElement(n.p,null,"배열의 인덱스를 number로 접근해서 타입을 가져오면 된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type TupleToUnion&lt;T extends unknown[]> = T[number];</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Chainable Options")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"체인 가능 옵션은 일반적으로 Javascript에서 사용됩니다. 하지만 TypeScript로 전환하면 제대로 구현할 수 있나요?"),"\n",a.createElement(n.p,null,"이 챌린지에서는 ",a.createElement(n.code,null,"option(key, value)"),"과 ",a.createElement(n.code,null,"get()")," 두가지 함수를 제공하는 객체(또는 클래스) 타입을 구현해야 합니다. 현재 타입을 ",a.createElement(n.code,null,"option"),"으로 지정된 키와 값으로 확장할 수 있고 ",a.createElement(n.code,null,"get"),"으로 최종 결과를 가져올 수 있어야 합니다."),"\n"),"\n",a.createElement(n.p,null,"너무 어려워서 정답을 봤다. R 타입은 option 메서드로 점진적으로 타입이 확장된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Chainable&lt;T = object> = {\n  option&lt;K extends PropertyKey, V>(\n    key: K extends keyof T\n         ? (V extends T[K] ? never : K)\n         : K,\n    value: V\n  ): Chainable&lt;Omit&lt;T, K> &amp; Record&lt;K, V>>; // Omit K from T\n  get(): T;\n}</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"declare"),"\n",a.createElement(n.p,null,"문제에서 a를 declare로 선언했는데, declare에 대해 알아보자."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">declare const a: Chainable</code></pre></div>'}}),"\n",a.createElement(n.p,null,"declare는 타입이나 값을 설명하기 위해 사용할 수 있다. 변수, 객체, 함수 또는 외부 모듈 등에서 타입 정보를 제공하는 용도로 사용할 수 있다. declare 키워드로 선언된 변수는 javascript로 컴파일되지 않는다."),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Last of Array")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"배열 T를 사용하고 마지막 요소를 반환하는 제네릭 ",a.createElement(n.code,null,"Last<T>"),"를 구현합니다."),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"T[length - 1]")," 식으로 접근하고 싶은데, 타입스크립트는 런타입 값을 알 수 없기 때문에 계산이 안된다."),"\n",a.createElement(n.p,null,"정답 코드에서는 새로운 배열을 만들고, 이 배열의 ",a.createElement(n.code,null,"T['length']")," 를 접근한다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Last&lt;T extends unknown[]> = [unknown, ...T][T["length"]]</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Pop")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"배열 T를 사용해 마지막 요소를 제외한 배열을 반환하는 제네릭 ",a.createElement(n.code,null,"Pop<T>"),"를 구현합니다."),"\n"),"\n",a.createElement(n.p,null,"infer로 추론하고 P를 반환하면 된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Pop&lt;T extends unknown[]> = T extends [...infer P, unknown] ? P : [];</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"Shift, Push, Unshift 구현하기"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Shift&lt;T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push&lt;T extends unknown[], X> = [...T, X];\n\ntype Unshift&lt;T extends unknown[], X> = [X, ...T];</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Promise.all")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array."),"\n"),"\n",a.createElement(n.p,null,"09번은 너무 어려워서 패스하고 다음에 도전해본다!"),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Type Lookup")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다."),"\n",a.createElement(n.p,null,"이 챌린지에서는 유니온 타입 ",a.createElement(n.code,null,"Cat | Dog"),"에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 ",a.createElement(n.code,null,"LookUp<Cat | Dog, 'dog'>"),"으로 Dog 타입을,",a.createElement(n.code,null," LookUp<Cat | Dog, 'cat'>"),"으로 ",a.createElement(n.code,null,"Cat")," 타입을 얻을 수 있습니다."),"\n"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type LookUp&lt;U, T> = U extends { type: T } ? U : never;</code></pre></div>'}}),"\n",a.createElement(n.h3,null,"Shift, Push, Unshift 구현하기"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Shift&lt;T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push&lt;T extends unknown[], X> = [...T, X];\n\ntype Unshift&lt;T extends unknown[], X> = [X, ...T];</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Promise.all")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array."),"\n"),"\n",a.createElement(n.p,null,"09번은 너무 어려워서 패스하고 다음에 도전해본다!"),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Type Lookup")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다."),"\n",a.createElement(n.p,null,"이 챌린지에서는 유니온 타입 ",a.createElement(n.code,null,"Cat | Dog"),"에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 ",a.createElement(n.code,null,"LookUp<Cat | Dog, 'dog'>"),"으로 Dog 타입을, ",a.createElement(n.code,null,"LookUp<Cat | Dog, 'cat'>"),"으로 Cat 타입을 얻을 수 있습니다."),"\n"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type LookUp&lt;U, T> = U extends { type: T } ? U : never;</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Trim Left")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"정확한 문자열 타입이고 시작 부분의 공백이 제거된 새 문자열을 반환하는 TrimLeft를 구현하십시오."),"\n"),"\n",a.createElement(n.p,null,"빈 공백을 제거하고 재귀적으로 trim을 하려고 했는데 U는 string이 아니라 배열 타입이 되므로 오답이다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type TrimLeft&lt;S extends string> = S[number] extends [\' \', ...infer U] ?  TrimLeft&lt;U> : S;</code></pre></div>'}}),"\n",a.createElement(n.p,null,"리터럴을 이용해 처리할 수 있다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Space = \' \' | \'\\t\' | \'\\n\';\ntype TrimLeft&lt;S extends string> = S extends `${Space}${infer U}` ?  TrimLeft&lt;U> : S;</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Trim")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"정확한 문자열 타입이고 양쪽 끝의 공백이 제거된 새 문자열을 반환하는 Trim를 구현하십시오."),"\n"),"\n",a.createElement(n.p,null,"TrimLeft 코드에서 분기 처리를 추가하면 된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Space = \' \' | \'\\t\' | \'\\n\';\n\ntype Trim&lt;S extends string> = S extends `${Space}${infer U}`\n  ? Trim&lt;U>\n  : S extends `${infer T}${Space}`\n  ? Trim&lt;T>\n  : S;</code></pre></div>'}}),"\n",a.createElement(n.p,null,"유니언으로 처리하면 더 깔끔하게 처리할 수 있다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Space = \' \' | \'\\t\' | \'\\n\';\n\ntype Trim&lt;S extends string> = S extends `${Space}${infer T}` | `${infer T}${Space}` ? Trim&lt;T> : S;</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Capitalize")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"문자열의 첫 글자만 대문자로 바꾸고 나머지는 그대로 놔두는 Capitalize를 구현하세요."),"\n"),"\n",a.createElement(n.p,null,"Capitalize 인터페이스를 사용하면 된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type MyCapitalize&lt;S extends string> = S extends `${infer X}${infer T}` ? `${Capitalize&lt;X>}${T}` : S;</code></pre></div>'}}),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Replace")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"문자열 S에서 From를 찾아 한 번만 To로 교체하는 ",a.createElement(n.code,null,"Replace<S, From, To>"),"를 구현하세요."),"\n"),"\n",a.createElement(n.p,null,"리터럴 타입을 이용해 조건부로 넘겼지만, From이 ",a.createElement(n.code,null,"''")," 케이스인 경우 통과하지 않는다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Replace&lt;\n  S extends string,\n  From extends string,\n  To extends string\n> = S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;</code></pre></div>'}}),"\n",a.createElement(n.p,null,"From이 공백 문자열인지 확인하는 분기를 추가하면 된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type Replace&lt;\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends \'\'\n  ? S\n  : S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"ReplaceAll")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"주어진 문자열 S에서 부분 문자열 From을 찾아 모두 To로 교체하는 제네릭 ",a.createElement(n.code,null,"ReplaceAll<S, From, To>"),"을 구현하세요."),"\n"),"\n",a.createElement(n.p,null,"Replace 코드에 재귀적으로 타입을 호출했는데, 이미 교체한 문자열에도 교체를 진행해 ",a.createElement(n.code,null,"foobarfoobar")," 테스트 케이스를 통과하지 못한다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type ReplaceAll&lt;\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends \'\'\n  ? S\n  : S extends `${infer T}${From}${infer X}`\n  ? ReplaceAll&lt;`${T}${To}${X}`, From, To>\n  : S extends `${From}${infer T}`\n  ? ReplaceAll&lt;`${To}${T}`, From, To>\n  : S;</code></pre></div>'}}),"\n",a.createElement(n.p,null,"리터럴 타입 내부에서 ReplaceAll 타입을 재귀적으로 호출하면 된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type ReplaceAll&lt;S extends string, From extends string, To extends string> = From extends \'\'\n  ? S\n  : S extends `${infer R1}${From}${infer R2}`\n  ? `${R1}${To}${ReplaceAll&lt;R2, From, To>}`\n  : S</code></pre></div>'}}),"\n",a.createElement(n.h2,null,a.createElement(n.strong,null,"Append Argument")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"함수 타입 Fn과 어떤 타입 A가 주어질 때 Fn의 인수와 A를 마지막 인수로 받는 Fn과 동일한 함수 유형인 G를 생성하세요."),"\n"),"\n",a.createElement(n.p,null,"Fn의 인자 타입을 추론하고 A를 추가하고자 아래처럼 작성했는데, 문법상에 오류가 있다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type AppendArgument&lt;Fn extends (...args: any[]) => unknown, A> = Fn extends (...X: any[]) => unknown ? (...X, A) => unknown : false;</code></pre></div>'}}),"\n",a.createElement(n.p,null,"arguments를 올바르게 타입을 추론하면 된다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">type AppendArgument&lt;Fn, A> = Fn extends (...args: infer T) => infer U ? (...arg: [...T, A]) => U : never;</code></pre></div>'}}),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"arguments 객체")),"\n",a.createElement(n.p,null,"arguments 객체는 함수에 전달된 인수에 해당하는 Array 형태의 객체이다."),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">function foo(a, b, c){\n    console.log(arguments[0] === a);\n    console.log(arguments[1] === b);\n    console.log(arguments[2] === c);\n}</code></pre></div>'}}),"\n",a.createElement(n.hr),"\n",a.createElement(n.p,null,"타입 챌린지는 임시 중단합니다."),"\n",a.createElement(n.p,null,"다양한 타입을 만드는건 재미있지만 자주 쓰이는 케이스로 타입스크립트를 학습하겠습니다~"))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},s=t(4160),o=t(4098),u=t(1858),g=t(8032),m=t(9542);const d={Link:s.rU};function i(e){let{data:n,children:t}=e;const{frontmatter:r}=n.mdx,c=(0,m.E)(r.thumbnail);return a.createElement(a.Fragment,null,a.createElement(o.h,null),a.createElement(u.A,null,a.createElement(l.Zo,{components:Object.assign({ul:e=>a.createElement("ul",Object.assign({},e,{style:{listStyle:"revert"}})),ol:e=>a.createElement("ul",Object.assign({},e,{style:{listStyleType:"decimal"}}))},d)},a.createElement("article",{className:"markdown-body"},a.createElement("h1",null,r.title),c&&a.createElement("div",{style:{position:"relative",width:"100%",paddingBottom:"56.25%"}},a.createElement(g.G,{image:c,alt:r.title,className:"absolute top-0 left-0 w-full h-full object-cover"})),t))))}function p(e){return a.createElement(i,e,a.createElement(c,e))}},9542:function(e,n,t){t.d(n,{E:function(){return l}});const l=e=>{if(e)return"childImageSharp"in e?e.childImageSharp.gatsbyImageData:e}},1151:function(e,n,t){t.d(n,{Zo:function(){return s},ah:function(){return r}});var l=t(7294);const a=l.createContext({});function r(e){const n=l.useContext(a);return l.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const c={};function s({components:e,children:n,disableParentContext:t}){let s;return s=t?"function"==typeof e?e({}):e||c:r(e),l.createElement(a.Provider,{value:s},n)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-content-type-challenges-medium-index-mdx-64f191ab0de31cd7553a.js.map