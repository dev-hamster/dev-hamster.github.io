"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[399],{4112:function(e,t,n){n.r(t),n.d(t,{default:function(){return p}});var l=n(1151),r=n(7294);function a(e){const t=Object.assign({h2:"h2",ul:"ul",li:"li",code:"code",hr:"hr",p:"p",img:"img",h3:"h3",strong:"strong",a:"a"},(0,l.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.h2,null,"목차"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"들어가며"),"\n",r.createElement(t.li,null,r.createElement(t.code,null,"transform"),"으로 개선 전 후 성능 비교하기"),"\n",r.createElement(t.li,null,"Layout, Reflow, Paint, Repaint"),"\n",r.createElement(t.li,null,"애니메이션은 어떻게 처리될까?"),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,null,"들어가며"),"\n",r.createElement(t.p,null,"드래그 이벤트 구현시 초기에는 엘리먼트의 위치를 ",r.createElement(t.code,null,"top")," 과 ",r.createElement(t.code,null,"left")," 값으로 업데이트해주었다. 그런데 드래그시 미세하게 버벅거려 ",r.createElement(t.code,null,"transform")," 으로 변경해 매끄러운 드래그 이벤트를 구현했다. ",r.createElement(t.code,null,"transform"),"은 Layout(Reflow)를 발생시키지 않아 더 빠르게 위치를 업데이트 할 수 있다."),"\n",r.createElement(t.p,null,"이 포스트에서 실제로 성능을 비교해보고 브라우저 렌더링 과정을 이해하고 마지막으로 ",r.createElement(t.code,null,"transform"),"은 어떻게 처리하는지 알아보자."),"\n",r.createElement(t.h2,null,"개선 전, 후 성능 비교하기"),"\n",r.createElement(t.p,null,"크롬 성능 측정을 이용해 드래그 이벤트를 발생시킨 후, 드래그가 본격적으로 발생한 약 4초 동안의 구간을 확인해 보았다."),"\n",r.createElement(t.p,null,"개선 전, 개선 후의 요약 탭을 확인해보면 렌더링은 38ms에서 24ms 로 단축되고 페인팅은 41ms에서 24ms로 로 개선됐다."),"\n",r.createElement(t.p,null,"개선 전:\n",r.createElement(t.img,{src:"./%E1%84%80%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB.png",alt:"개선전"})),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"개선 후: ",r.createElement(t.img,{src:"./%E1%84%80%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%AE.png",alt:"개선후"})),"\n",r.createElement(t.p,null,"다음 사진은 드래그가 발생하는 동안 실행된 작업들이다. 여기서 하나를 확대해보자.\n",r.createElement(t.img,{src:"./%E1%84%83%E1%85%B3%E1%84%85%E1%85%A2%E1%84%80%E1%85%B3-%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8B%E1%85%B5%E1%86%AB-%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%E1%84%83%E1%85%B3%E1%86%AF.png",alt:"드래그시 실행 중인 작업"})),"\n",r.createElement(t.p,null,"mousemove가 드래그 이벤트가 발생한 시점이다. 개선 전 작업을 보면 레이아웃과 페인트 작업을 볼 수 있다.\n",r.createElement(t.img,{src:"./%E1%84%80%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8.png",alt:"개선 전 작업"})),"\n",r.createElement(t.p,null,"반면에 개선 후 작업에서는 페인트 단계만 볼 수 있다.\n",r.createElement(t.img,{src:"./%E1%84%80%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%AE%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8.png",alt:"개선 후 작업"})),"\n",r.createElement(t.p,null,"왜 transform 은 레이아웃 작업이 없을까? 브라우저 렌더링 과정에서 알아보자."),"\n",r.createElement(t.h2,null,"Layout, Reflow, Paint, Repaint"),"\n",r.createElement(t.p,null,"브라우저 렌더링 과정에은 Style, Layout, Paint, 때때로 Compositing이 포함된다. 오늘은 Layout부터 Repaint까지 알아보자."),"\n",r.createElement(t.h3,null,"Layout"),"\n",r.createElement(t.p,null,"렌더 트리가 만들어진 후, 각 노드의 도형 값을 계산하기 위해 레이아웃을 실행한다. 렌더 트리에 있는 모든 노드의 너비, 높이, 위치를 결정하는 프로세스이다. 처음 노드의 사이즈와 위치가 결정된다."),"\n",r.createElement(t.h3,null,"Reflow"),"\n",r.createElement(t.p,null,"레이아웃 이후 페이지의 일부분이나 전체 문서에 대한 크기나 위치에 대한 결정한다. 레이아웃 이후에 노드의 크기와 위치를 다시 계산한다. (크롬 개발자 도구에서는 Layout 용어로 통일)"),"\n",r.createElement(t.h3,null,"Paint"),"\n",r.createElement(t.p,null,"텍스트, 색깔, 경계, 그림자 및 버튼인자 이미지 같은 대체 요소를 포함하여 모든 요소의 ",r.createElement(t.strong,null,"시각적인 부분"),"을 화면에 그리는 작업이다."),"\n",r.createElement(t.h3,null,"Repaint"),"\n",r.createElement(t.p,null,"첫 페인트 이후 UI변경으로 시각적 업데이트를 표시하기 위해 다시 그릴 때 발생한다. 일반적으로 리플로우 이후에 발생한다."),"\n",r.createElement(t.p,null,"css 속성별로 렌더링을 발생시키는 작업이 있다. 각 속성이 어떤 렌더링 과정을 일으키는지는 ",r.createElement(t.a,{href:"https://lab.skk.moe/css-triggers%EC%97%90%EC%84%9C"},"https://lab.skk.moe/css-triggers"),"에서 확인할 수 있다."),"\n",r.createElement(t.p,null,"처음으로 구현했던 방법은 left와 top속성을 직접 업데이트하는 것이었는데, Layout을 발생시키는 요소를 확인할 수 있다.\n",r.createElement(t.img,{src:"./left-%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A5.png",alt:"left 트리거"})),"\n",r.createElement(t.p,null,"반대로 transform은 Composite만 발생시킨다. (Blink, 크롬기준)\n",r.createElement(t.img,{src:"./transform-%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A5.png",alt:"transform 트리거"})),"\n",r.createElement(t.p,null,"여기까지 transform이 실제로 Reflow작업을 방지해 성능을 개선한 것을 눈으로 알아봤다."),"\n",r.createElement(t.h2,null,r.createElement(t.code,null,"transform"),"은 어떻게 처리될까?"),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"transform"),"은 합성 단계에서 처리된다. 합성 단계는 메인 쓰레드가 아닌, GPU를 이용해 레이어를 합성해 정확하게 화면에 그린다. 레이어는 video, canvas, 3d 또는 원근 변화 css 속성 등 사용시 생성된다."),"\n",r.createElement(t.p,null,"즉, transform 속성을 사용하면 레이어를 생성한다. 그리고 GPU를 사용해 변경이 일어나면, 기존 레이어를 합성하여 더 빠르게 렌더링을 할 수 있다. 레이어를 이용하면 성능이 향상되지만, 메모리 관리 측면에서는 비싼 작업이므로 주의해야한다."),"\n",r.createElement(t.hr),"\n",r.createElement(t.p,null,"참고"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.a,{href:"https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work"},"https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work")),"\n",r.createElement(t.li,null,r.createElement(t.a,{href:"https://blog.seokho.dev/ko/development/2021/03/08/ReflowRepaint.html"},"https://blog.seokho.dev/ko/development/2021/03/08/ReflowRepaint.html")),"\n",r.createElement(t.li,null,r.createElement(t.a,{href:"https://developer.mozilla.org/ko/docs/Glossary/Repaint"},"https://developer.mozilla.org/ko/docs/Glossary/Repaint")),"\n",r.createElement(t.li,null,r.createElement(t.a,{href:"https://lab.skk.moe/css-triggers"},"https://lab.skk.moe/css-triggers")),"\n",r.createElement(t.li,null,r.createElement(t.a,{href:"https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work"},"https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work")),"\n",r.createElement(t.li,null,r.createElement(t.a,{href:"https://web.dev/articles/speed-layers#introducing_layers"},"https://web.dev/articles/speed-layers#introducing_layers")),"\n"))}var E=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.ah)(),e.components);return t?r.createElement(t,e,r.createElement(a,e)):a(e)},o=n(4160),c=n(8032),m=n(9542),s=n(4222);const u={Link:o.rU};function i(e){let{data:t,children:n}=e;const{frontmatter:a}=t.mdx,E=(0,m.E)(a.thumbnail);return r.createElement(s.X,null,r.createElement("div",{style:{marginTop:"40px"}},r.createElement(l.Zo,{components:Object.assign({ul:e=>r.createElement("ul",Object.assign({},e,{style:{listStyle:"revert"}})),ol:e=>r.createElement("ul",Object.assign({},e,{style:{listStyleType:"decimal"}}))},u)},r.createElement("article",{className:"markdown-body"},r.createElement("h1",null,a.title),E&&r.createElement("div",{style:{position:"relative",width:"100%",paddingBottom:"56.25%"}},r.createElement(c.G,{image:E,alt:a.title,className:"absolute top-0 left-0 w-full h-full object-cover"})),n))))}function p(e){return r.createElement(i,e,r.createElement(E,e))}},9542:function(e,t,n){n.d(t,{E:function(){return l}});const l=e=>{if(e)return"childImageSharp"in e?e.childImageSharp.gatsbyImageData:e}},1151:function(e,t,n){n.d(t,{Zo:function(){return o},ah:function(){return a}});var l=n(7294);const r=l.createContext({});function a(e){const t=l.useContext(r);return l.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const E={};function o({components:e,children:t,disableParentContext:n}){let o;return o=n?"function"==typeof e?e({}):e||E:a(e),l.createElement(r.Provider,{value:o},t)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-content-드래그-이벤트-구현기-2-왜-transform은-더-빠를까-index-mdx-04c9ae1e64c47385cd48.js.map