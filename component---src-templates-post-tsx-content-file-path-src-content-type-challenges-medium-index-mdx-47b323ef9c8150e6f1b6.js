"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[376],{6448:function(e,n,l){l.r(n),l.d(n,{default:function(){return d}});var t=l(1151),r=l(7294);function a(e){const n=Object.assign({h2:"h2",strong:"strong",h3:"h3",p:"p",code:"code",pre:"pre",ul:"ul",li:"li",span:"span",em:"em",blockquote:"blockquote",hr:"hr"},(0,t.a)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h2,null,r.createElement(n.strong,null,"Get Return Type")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"내장 제네릭 ",r.createElement(n.code,null,"ReturnType<T>"),"을 이를 사용하지 않고 구현하자"),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 아쉬운 정답\ntype MyReturnType<T extends (...args: any) => unknown> =\n  T extends (...args:any) => infer U\n      ? U\n      : never;\n")),"\n",r.createElement(n.p,null,"함수 인자 타입을 ",r.createElement(n.code,null,"never[]")," 로 하면 모든 테스트 케이스가 통과된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 정답\ntype MyReturnType<T extends (...args: never[]) => unknown> =\n  T extends (...args: never[]) => infer R\n    ? R\n    : never\n")),"\n",r.createElement(n.h3,null,"해설"),"\n",r.createElement(n.p,null,"리턴되는 타입을 ",r.createElement(n.code,null,"infer U"),"로 추론하고 U를 반환한다. 하지만 함수 인수를 받는 타입을 ",r.createElement(n.code,null,"unknown[]")," 으로 하면 테스트 케이스가 일부만 통과해서 ",r.createElement(n.code,null,"any"),"로 변경해 모두 통과되도록 했다."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,r.createElement(n.code,null,"unknown[]"),"이 안되는 이유")),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"unknown")," 은 모든 타입의 상위 타입이므로 모든 타입은 ",r.createElement(n.code,null,"unknown"),"에 할당할 수 있다. 그렇기 때문에 ",r.createElement(n.code,null,"unknown")," 은 가장 일반적인 타입이기 때문에 구체적인 타입과 호환되지 않는다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type foo = unknown extends string ? true : false; // false\n")),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,r.createElement(n.code,null,"never[]")," 를 사용하는 이유")),"\n",r.createElement(n.p,null,"never는 존재하지 않는 공집합이기 때문에 any를 포함해 어떤 값도 가질 수 없는 가장 구체적인 타입이어서 다른 타입들과 호환될 수 있다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type foo = never extends string ? true : false; // true\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Omit")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"T"),"에서 ",r.createElement(n.code,null,"K")," 프로퍼티만 제거해 새로운 오브젝트 타입을 만드는 내장 제네릭 ",r.createElement(n.code,null,"Omit<T, K>"),"를 이를 사용하지 않고 구현하자."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.p,null,"T의 프로퍼티 키에서 K가 아니라면 키값을 추출하는 코드를 의도했다. 이 코드는 infer의 잘못된 사용으로 동작하지 않는다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 오답\ntype MyOmit<T, K extends keyof T> = K extends infer Key keyof T ?\n  never :\n  { Key: T[Key] }\n")),"\n",r.createElement(n.p,null,"정답 코드는 이렇다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 정답\ntype MyOmit<T, K extends keyof T> = {[Key in keyof T as Key extends K ? never: Key]: T[Key]}\n")),"\n",r.createElement(n.h3,null,"해설"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,r.createElement(n.code,null,"as")," 키워드")),"\n",r.createElement(n.p,null,"as 키용해 이용해 맵드 타입의 키를 다시 매핑할 수 있다. 예를들어 모든 프로퍼티 키를 Hamster라고 키 이름을 다시 매핑할 수 있다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MappedTypeWithNewProperties<Type> = {\n    [Properties in keyof Type as 'Hamster']: Type[Properties]\n}\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Readonly 2")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"T"),"에서 ",r.createElement(n.code,null,"K")," 프로퍼티만 읽기 전용으로 설정해 새로운 오브젝트 타입을 만드는 제네릭 ",r.createElement(n.code,null,"MyReadonly2<T, K>"),"를 구현하세요. ",r.createElement(n.code,null,"K"),"가 주어지지 않으면 단순히 ",r.createElement(n.code,null,"Readonly<T>"),"처럼 모든 프로퍼티를 읽기 전용으로 설정해야 합니다."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MyReadonly2<T, K extends keyof T = keyof T> = { readonly [k in K]: T[k] } & Omit<T, K>;\n")),"\n",r.createElement(n.h3,null,"해설"),"\n",r.createElement(n.p,null,"K 프로퍼티는 readonly 속성을 부여하면 된다. 구현은 정답을 참고했다."),"\n",r.createElement(n.p,null,"K가 주어지지 않는 경우를 위해 ",r.createElement(n.code,null,"K extends keyof T = keyof T")," default 값을 설정한다."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"교차 타입 &")),"\n",r.createElement(n.p,null,"두 개 이상의 타입을 결합해 모든 타입의 속성을 포함하는 새로운 타입을 생성할 수 있다. ",r.createElement(n.code,null,"A & B"),"는 ",r.createElement(n.code,null,"A"),"와 ",r.createElement(n.code,null,"B"),"의 모든 속성을 포함하는 새로운 타입이 된다."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"유니온 타입 |")),"\n",r.createElement(n.p,null,"두 개 이상의 타입 중 하나를 선택할 수 있는 새로운 타입을 생성한다. ",r.createElement(n.code,null,"A | B")," 는 ",r.createElement(n.code,null,"A"),"또는 ",r.createElement(n.code,null,"B")," 중 하나의 타입을 가질 수 있다."),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Deep Readonly")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"객체의 프로퍼티와 모든 하위 객체를 재귀적으로 읽기 전용으로 설정하는 제네릭 ",r.createElement(n.code,null,"DeepReadonly<T>"),"를 구현하세요."),"\n",r.createElement(n.p,null,"이 챌린지에서는 타입 파라미터 ",r.createElement(n.code,null,"T"),"를 객체 타입으로 제한하고 있습니다. 객체뿐만 아니라 배열, 함수, 클래스 등 가능한 다양한 형태의 타입 파라미터를 사용하도록 도전해 보세요."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.p,null,"중첩된 객체 프로퍼티의 타입을 반환하는 타입은 만들었는데 다음은 어떻게 해야할까?"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 오답\ntype DeepReadonly<T> = T extends object ? DeepReadonly<T[keyof T]> : T\n")),"\n",r.createElement(n.p,null,"정답을 참고해서 ",r.createElement(n.code,null,"readonly")," 타입을 반환하도록 했는데, 중첩된 객체에서는 ",r.createElement(n.code,null,"readonly"),"가 안된다. (아래 코드가 왜 잘못됐는지 모르겠다🥲 )"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,'// 오답\ntype DeepReadonly<T> = T extends Record<PropertyKey, unknown> ?\n  { readonly [P in keyof T]: DeepReadonly<T[P]> }\n  :\n  T;\n\ntype x = DeepReadonly<{l: [\n        \'hi\',\n        {\n          m: [\'hey\']\n        },\n      ]}>;\n\n// 결과\n// type x = {\n//  readonly l: ["hi", {\n//      m: ["hey"];\n//    }];\n//  }\n\n// 기댓값\n// type x = {\n//  readonly l: readonly ["hi", {\n//      readonly m: readonly ["hey"];\n//    }];\n//  }\n')),"\n",r.createElement(n.p,null,"정답 코드를 보면 ",r.createElement(n.code,null,"T"),"에 프로퍼티 키로 접근할 수 있는 값이 없다면 T[K]를 반환하고 그렇지 않다면 재귀적으로 ",r.createElement(n.code,null,"DeepReadonly<T[K]>")," 를 호출한다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 정답\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: keyof T[K] extends never ? T[K] : DeepReadonly<T[K]>\n}\n")),"\n",r.createElement(n.h3,null,"해설"),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"TypeScript 에서 ",r.createElement(n.code,null,"{}")," vs ",r.createElement(n.code,null,"Object")," vs ",r.createElement(n.code,null,"object"))),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.code,null,"{}")," 는 빈 객체가 아닌 any non-nullsih value이므로 ",r.createElement(n.code,null,"undefined"),", ",r.createElement(n.code,null,"null"),"을 제외한 모든 타입을 할당할 수 있다."),"\n",r.createElement(n.li,null,r.createElement(n.code,null,"Object")," 도 ",r.createElement(n.code,null,"{}")," 와 동일하다."),"\n",r.createElement(n.li,null,r.createElement(n.code,null,"object")," 는 원시값을 제외한 모든 값이 할당 가능하다."),"\n"),"\n",r.createElement(n.p,null,"빈 객체",r.createElement(n.code,null,"{}")," 타입만을 허용하고 싶다면 ",r.createElement(n.code,null,"never"),"를 사용하자. 자바스크립트의 객체 타입(중괄호로 이루어진 객체)만을 허용하고 싶다면 Record를 사용하면 된다."),"\n",r.createElement(n.p,null,r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/145633b0b43672218acc597e5e844146/41099/mind.jpg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQD/8QAFwEAAwEAAAAAAAAAAAAAAAAAAAECBP/aAAwDAQACEAMQAAABwqg10552hOCsm5wH/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIAAxETMf/aAAgBAQABBQJKxY3NSWUBhaFVLG5oAw3JW2t7P//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPwF2M//EABYRAAMAAAAAAAAAAAAAAAAAAAAQIf/aAAgBAgEBPwEj/8QAHhAAAQMEAwAAAAAAAAAAAAAAAQACERAxQXESIlL/2gAIAQEABj8CLpEKMiyvK6DaJyp5tG6GfNP/xAAdEAEAAwACAwEAAAAAAAAAAAABABEhMUFRYYGh/9oACAEBAAE/IUeB5DI4zCldkcdurTNAX5QAQBLe9W0Fwi5iWz5Du/k//9oADAMBAAIAAwAAABBb8L3/xAAXEQADAQAAAAAAAAAAAAAAAAAAAREQ/9oACAEDAQE/EEor1//EABcRAQEBAQAAAAAAAAAAAAAAAAEAERD/2gAIAQIBAT8QwySDz//EAB0QAQADAQACAwAAAAAAAAAAAAEAESExQVFhgaH/2gAIAQEAAT8QWFYl78UeJRhFCoPdJkBaLKvfUYAMWpT3Q8dm+2bOo/HuWCS9A/kPV0uSrNAKUHWfZcIHJXeCf//Z\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="mind"\n        title=""\n        src="/static/145633b0b43672218acc597e5e844146/41099/mind.jpg"\n        srcset="/static/145633b0b43672218acc597e5e844146/f93b5/mind.jpg 300w,\n/static/145633b0b43672218acc597e5e844146/41099/mind.jpg 500w"\n        sizes="(max-width: 500px) 100vw, 500px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),r.createElement(n.em,null,"타입스크립트는 어렵네요")),"\n",r.createElement(n.h2,null,"문제 풀기에 앞서…"),"\n",r.createElement(n.p,null,"문제 풀기에 앞서 아직 헷갈리는 내용을 짚고 넘어가보자."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"정적 타입 검사:")),"\n",r.createElement(n.p,null,"타입스크립트는 프로그램을 실행시키지 않고 오류를 검출한다."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"점진적 타입 시스템:")),"\n",r.createElement(n.p,null,"타입스크립트는 타입 검사를 점진적으로 적용해 동적 타입처럼 자유롭게 타입을 작성할 수 있다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,'let a = 10;  // 타입스크립트가 자동으로 number로 추론 (자동 타입 추론)\nlet b;       // 타입 명시가 없으므로 b는 암시적으로 any 타입을 가짐\nb = "hello"; // b에 어떤 값이든 할당 가능 (any 타입)\nb = 42;      // any 타입이기 때문에 타입 오류 없음\n')),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"구조적 타입 시스템이란:")),"\n",r.createElement(n.p,null,"타입스크립트 컴파일러는 두 타입의 명시적 선언이 아닌 ",r.createElement(n.strong,null,"프로퍼티를 비교"),"하여 타입을 비교한다. 그러니까 타입 ",r.createElement(n.code,null,"Hamster"),"과 ",r.createElement(n.code,null,"Animal"),"이 있을 때, ",r.createElement(n.code,null,"Hamster")," ⊂ ",r.createElement(n.code,null,"Animal"),"를 만족한다. ",r.createElement(n.code,null,"Hamster"),"의 프로퍼티는 ",r.createElement(n.code,null,"Animal"),"를 만족시키기 때문에 ",r.createElement(n.code,null,"Hamster"),"타입에 ",r.createElement(n.code,null,"Animal"),"을 할당할 수 있고 ",r.createElement(n.code,null,"Hamster"),"은 ",r.createElement(n.code,null,"Animal"),"타입과 호환이 가능하다."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Indexed Access Type:")),"\n",r.createElement(n.p,null,"인덱스를 사용해 객체의 프로퍼티 타입을 추출할 수 있다. 배열 요소의 타입을 가져오려면 ",r.createElement(n.code,null,"Foo[number]")," 로 하면 된다."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"infer:")),"\n",r.createElement(n.p,null,"조건부 타입의 ",r.createElement(n.code,null,"extends")," 절 안에서 infer을 이용해 타입 변수를 추론할 수 있다. 이렇게 추론된 타입은 분기에서 참조될 수 있다."),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Tuple to Union")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"튜플 값으로 유니온 타입을 생성하는 제네릭 ",r.createElement(n.code,null,"TupleToUnion<T>"),"를 구현하세요."),"\n"),"\n",r.createElement(n.p,null,"배열의 인덱스를 number로 접근해서 타입을 가져오면 된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type TupleToUnion<T extends unknown[]> = T[number];\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Chainable Options")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"체인 가능 옵션은 일반적으로 Javascript에서 사용됩니다. 하지만 TypeScript로 전환하면 제대로 구현할 수 있나요?"),"\n",r.createElement(n.p,null,"이 챌린지에서는 ",r.createElement(n.code,null,"option(key, value)"),"과 ",r.createElement(n.code,null,"get()")," 두가지 함수를 제공하는 객체(또는 클래스) 타입을 구현해야 합니다. 현재 타입을 ",r.createElement(n.code,null,"option"),"으로 지정된 키와 값으로 확장할 수 있고 ",r.createElement(n.code,null,"get"),"으로 최종 결과를 가져올 수 있어야 합니다."),"\n"),"\n",r.createElement(n.p,null,"너무 어려워서 정답을 봤다. R 타입은 option 메서드로 점진적으로 타입이 확장된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Chainable<T = object> = {\n  option<K extends PropertyKey, V>(\n    key: K extends keyof T\n         ? (V extends T[K] ? never : K)\n         : K,\n    value: V\n  ): Chainable<Omit<T, K> & Record<K, V>>; // Omit K from T\n  get(): T;\n}\n")),"\n",r.createElement(n.h3,null,"declare"),"\n",r.createElement(n.p,null,"문제에서 a를 declare로 선언했는데, declare에 대해 알아보자."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"declare const a: Chainable\n")),"\n",r.createElement(n.p,null,"declare는 타입이나 값을 설명하기 위해 사용할 수 있다. 변수, 객체, 함수 또는 외부 모듈 등에서 타입 정보를 제공하는 용도로 사용할 수 있다. declare 키워드로 선언된 변수는 javascript로 컴파일되지 않는다."),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Last of Array")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"배열 T를 사용하고 마지막 요소를 반환하는 제네릭 ",r.createElement(n.code,null,"Last<T>"),"를 구현합니다."),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"T[length - 1]")," 식으로 접근하고 싶은데, 타입스크립트는 런타입 값을 알 수 없기 때문에 계산이 안된다."),"\n",r.createElement(n.p,null,"정답 코드에서는 새로운 배열을 만들고, 이 배열의 ",r.createElement(n.code,null,"T['length']")," 를 접근한다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,'type Last<T extends unknown[]> = [unknown, ...T][T["length"]]\n')),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Pop")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"배열 T를 사용해 마지막 요소를 제외한 배열을 반환하는 제네릭 ",r.createElement(n.code,null,"Pop<T>"),"를 구현합니다."),"\n"),"\n",r.createElement(n.p,null,"infer로 추론하고 P를 반환하면 된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Pop<T extends unknown[]> = T extends [...infer P, unknown] ? P : [];\n")),"\n",r.createElement(n.h3,null,"Shift, Push, Unshift 구현하기"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Shift<T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push<T extends unknown[], X> = [...T, X];\n\ntype Unshift<T extends unknown[], X> = [X, ...T];\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Promise.all")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array."),"\n"),"\n",r.createElement(n.p,null,"09번은 너무 어려워서 패스하고 다음에 도전해본다!"),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Type Lookup")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다."),"\n",r.createElement(n.p,null,"이 챌린지에서는 유니온 타입 ",r.createElement(n.code,null,"Cat | Dog"),"에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 ",r.createElement(n.code,null,"LookUp<Cat | Dog, 'dog'>"),"으로 Dog 타입을,",r.createElement(n.code,null," LookUp<Cat | Dog, 'cat'>"),"으로 ",r.createElement(n.code,null,"Cat")," 타입을 얻을 수 있습니다."),"\n"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type LookUp<U, T> = U extends { type: T } ? U : never;\n")),"\n",r.createElement(n.h3,null,"Shift, Push, Unshift 구현하기"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Shift<T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push<T extends unknown[], X> = [...T, X];\n\ntype Unshift<T extends unknown[], X> = [X, ...T];\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Promise.all")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array."),"\n"),"\n",r.createElement(n.p,null,"09번은 너무 어려워서 패스하고 다음에 도전해본다!"),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Type Lookup")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다."),"\n",r.createElement(n.p,null,"이 챌린지에서는 유니온 타입 ",r.createElement(n.code,null,"Cat | Dog"),"에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 ",r.createElement(n.code,null,"LookUp<Cat | Dog, 'dog'>"),"으로 Dog 타입을, ",r.createElement(n.code,null,"LookUp<Cat | Dog, 'cat'>"),"으로 Cat 타입을 얻을 수 있습니다."),"\n"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type LookUp<U, T> = U extends { type: T } ? U : never;\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Trim Left")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"정확한 문자열 타입이고 시작 부분의 공백이 제거된 새 문자열을 반환하는 TrimLeft를 구현하십시오."),"\n"),"\n",r.createElement(n.p,null,"빈 공백을 제거하고 재귀적으로 trim을 하려고 했는데 U는 string이 아니라 배열 타입이 되므로 오답이다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type TrimLeft<S extends string> = S[number] extends [' ', ...infer U] ?  TrimLeft<U> : S;\n")),"\n",r.createElement(n.p,null,"리터럴을 이용해 처리할 수 있다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Space = ' ' | '\\t' | '\\n';\ntype TrimLeft<S extends string> = S extends `${Space}${infer U}` ?  TrimLeft<U> : S;\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Trim")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"정확한 문자열 타입이고 양쪽 끝의 공백이 제거된 새 문자열을 반환하는 Trim를 구현하십시오."),"\n"),"\n",r.createElement(n.p,null,"TrimLeft 코드에서 분기 처리를 추가하면 된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Space = ' ' | '\\t' | '\\n';\n\ntype Trim<S extends string> = S extends `${Space}${infer U}`\n  ? Trim<U>\n  : S extends `${infer T}${Space}`\n  ? Trim<T>\n  : S;\n")),"\n",r.createElement(n.p,null,"유니언으로 처리하면 더 깔끔하게 처리할 수 있다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Space = ' ' | '\\t' | '\\n';\n\ntype Trim<S extends string> = S extends `${Space}${infer T}` | `${infer T}${Space}` ? Trim<T> : S;\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Capitalize")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"문자열의 첫 글자만 대문자로 바꾸고 나머지는 그대로 놔두는 Capitalize를 구현하세요."),"\n"),"\n",r.createElement(n.p,null,"Capitalize 인터페이스를 사용하면 된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MyCapitalize<S extends string> = S extends `${infer X}${infer T}` ? `${Capitalize<X>}${T}` : S;\n")),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Replace")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"문자열 S에서 From를 찾아 한 번만 To로 교체하는 ",r.createElement(n.code,null,"Replace<S, From, To>"),"를 구현하세요."),"\n"),"\n",r.createElement(n.p,null,"리터럴 타입을 이용해 조건부로 넘겼지만, From이 ",r.createElement(n.code,null,"''")," 케이스인 경우 통과하지 않는다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Replace<\n  S extends string,\n  From extends string,\n  To extends string\n> = S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;\n")),"\n",r.createElement(n.p,null,"From이 공백 문자열인지 확인하는 분기를 추가하면 된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Replace<\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends ''\n  ? S\n  : S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"ReplaceAll")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"주어진 문자열 S에서 부분 문자열 From을 찾아 모두 To로 교체하는 제네릭 ",r.createElement(n.code,null,"ReplaceAll<S, From, To>"),"을 구현하세요."),"\n"),"\n",r.createElement(n.p,null,"Replace 코드에 재귀적으로 타입을 호출했는데, 이미 교체한 문자열에도 교체를 진행해 ",r.createElement(n.code,null,"foobarfoobar")," 테스트 케이스를 통과하지 못한다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type ReplaceAll<\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends ''\n  ? S\n  : S extends `${infer T}${From}${infer X}`\n  ? ReplaceAll<`${T}${To}${X}`, From, To>\n  : S extends `${From}${infer T}`\n  ? ReplaceAll<`${To}${T}`, From, To>\n  : S;\n")),"\n",r.createElement(n.p,null,"리터럴 타입 내부에서 ReplaceAll 타입을 재귀적으로 호출하면 된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type ReplaceAll<S extends string, From extends string, To extends string> = From extends ''\n  ? S\n  : S extends `${infer R1}${From}${infer R2}`\n  ? `${R1}${To}${ReplaceAll<R2, From, To>}`\n  : S\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Append Argument")),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"함수 타입 Fn과 어떤 타입 A가 주어질 때 Fn의 인수와 A를 마지막 인수로 받는 Fn과 동일한 함수 유형인 G를 생성하세요."),"\n"),"\n",r.createElement(n.p,null,"Fn의 인자 타입을 추론하고 A를 추가하고자 아래처럼 작성했는데, 문법상에 오류가 있다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type AppendArgument<Fn extends (...args: any[]) => unknown, A> = Fn extends (...X: any[]) => unknown ? (...X, A) => unknown : false;\n")),"\n",r.createElement(n.p,null,"arguments를 올바르게 타입을 추론하면 된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type AppendArgument<Fn, A> = Fn extends (...args: infer T) => infer U ? (...arg: [...T, A]) => U : never;\n")),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"arguments 객체")),"\n",r.createElement(n.p,null,"arguments 객체는 함수에 전달된 인수에 해당하는 Array 형태의 객체이다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"function foo(a, b, c){\n    console.log(arguments[0] === a);\n    console.log(arguments[1] === b);\n    console.log(arguments[2] === c);\n}\n")),"\n",r.createElement(n.hr),"\n",r.createElement(n.p,null,"타입 챌린지는 임시 중단합니다."),"\n",r.createElement(n.p,null,"다양한 타입을 만드는건 재미있지만 자주 쓰이는 케이스로 타입스크립트를 학습하겠습니다~"))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,t.a)(),e.components);return n?r.createElement(n,e,r.createElement(a,e)):a(e)},o=l(4160),u=l(4098),m=l(1858),E=l(8032),A=l(9542);const p={Link:o.rU};function s(e){let{data:n,children:l}=e;const{frontmatter:a}=n.mdx,c=(0,A.E)(a.thumbnail);return r.createElement(r.Fragment,null,r.createElement(u.h,null),r.createElement(m.A,null,r.createElement(t.Z,{components:Object.assign({ul:e=>r.createElement("ul",Object.assign({},e,{style:{listStyle:"revert"}})),ol:e=>r.createElement("ul",Object.assign({},e,{style:{listStyleType:"decimal"}}))},p)},r.createElement("article",{className:"markdown-body"},r.createElement("h1",null,a.title),c&&r.createElement("div",{style:{position:"relative",width:"100%",paddingBottom:"56.25%"}},r.createElement(E.G,{image:c,alt:a.title,className:"absolute top-0 left-0 w-full h-full object-cover"})),l))))}function d(e){return r.createElement(s,e,r.createElement(c,e))}},9542:function(e,n,l){l.d(n,{E:function(){return t}});const t=e=>{if(e)return"childImageSharp"in e?e.childImageSharp.gatsbyImageData:e}},1151:function(e,n,l){l.d(n,{Z:function(){return o},a:function(){return c}});var t=l(7294);const r={},a=t.createContext(r);function c(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-content-type-challenges-medium-index-mdx-47b323ef9c8150e6f1b6.js.map