{"version":3,"file":"component---src-templates-post-tsx-content-file-path-src-content-type-challenges-easy-index-mdx-fab150d1f63d2d3664f4.js","mappings":"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","sources":["webpack://blog/./src/content/type-challenges/easy/index.mdx","webpack://blog/./src/templates/post.tsx","webpack://blog/./src/utils/getThumbnailImage.ts","webpack://blog/./node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    span: \"span\",\n    strong: \"strong\",\n    a: \"a\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"PICK-4\"), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"pick을 사용하지 않고 Pick을 구현하는 문제이다.\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, React.createElement(_components.code, null, \"keyof\"), \" 는 객체의 키 값들을 숫자나 문자열 리터럴 유니언을 생성한다.\"), \"\\n\", React.createElement(_components.li, null, React.createElement(_components.code, null, \"in\"), \" 는 객체에 특정 속성이 존재하는지 확인할 수 있다.\"), \"\\n\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type MyPick&lt;T, K extends keyof T> = {\\n  [k in K]: T[k]\\n}</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"K extends keyof T\"), \" K는 T의 프로퍼티 이름을 가진다. 매핑된 타입을 이용하면 키를 통해 타입을 반복적으로 생성할 수 있고 인덱스 시그니처 문법으로 작성하면 된다.\"), \"\\n\", React.createElement(_components.h2, null, \"Readonly\"), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"Readonly 타입을 사용하지 않고 구현하는 문제이다.\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, React.createElement(_components.code, null, \"readonly\"), \" 는 프로퍼티를 읽기 전용으로 지정할 수 있다.\"), \"\\n\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type MyReadonly&lt;T> = {\\n  readonly [P in keyof T]: T[P]\\n}</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"Tuple to Object\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"각 원소의 값을 key/value로 갖는 오브젝트 타입을 반환하는 타입을 구현하는 문제이다.\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// 배열의 원소의 값을 key/value로 갖는 타입을 반환한다.\\n['tesla', 'model 3', 'model X', 'model Y']\\n\\n{ 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type TupleToObject&lt;T extends readonly PropertyKey[]> = {\\n  [P in T[number]] : P\\n}</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"배열 순회하기: \", React.createElement(_components.code, null, \"T[number]\"), \"을 통해 배열을 순회하여 타입을 가져올 수 있다. \", React.createElement(_components.code, null, \"T[number]\"), \" 은 인덱스가 숫자형인 요소들의 타입을 가져오므로 배열에 있는 모든 요소의 타입을 가져올 수 있다.\"), \"\\n\", React.createElement(_components.li, null, \"PropertyKey: \", React.createElement(_components.code, null, \"keyof\"), \" 를 통해 생성되는 key의 집합이다. 여기에는 string, number, symbol이 있다.\"), \"\\n\"), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"First of Array\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"T\"), \"를 받아 첫번째 원소의 타입을 반환하는 제네릭 \", React.createElement(_components.code, null, \"First<T>\"), \"를 구현하는 문제이다.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// 오답: 빈 배열인 경우 T[0]은 undefeind가 된다\\ntype First&lt;T extends any[]> = T[0] extends never ? never : T[0]; // 원소가 없다면 never 타입 반환\\n\\n// 정답1\\ntype First&lt;T extends unknown[]> = T[number] extends never ? never : T[0];\\n// 정답2\\ntype First&lt;T extends unknown[]> = T extends [] ? never : T[0];</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"조건부 타입: 배열이 빈 배열이라면 \", React.createElement(_components.code, null, \"never\"), \" 타입을 반환한다.\"), \"\\n\"), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"Length of Tuple\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"튜블(배열)의 길이를 반환하는 제네릭 타입을 구현하는 문제이다.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// 오답: Length&lt;5>인 경우 타입 에러가 나지 않는다.\\ntype Length&lt;T> = T extends readonly unknown[] ? T['length'] : never;</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"<T extends readonly unknown[]>\"), \" 는 T가 \", React.createElement(_components.code, null, \"readonly unknown[ ]\"), \"이라는 타입을 반드시 만족해야 하므로 배열이 아닌 경우 타입 에러를 발생한다.\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// 정답\\ntype Length&lt;T extends readonly unknown[]> = T[\\\"length\\\"];</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, React.createElement(_components.code, null, \"readonly\"), \": 튜플은 고정된 요소를 저장하므로 readonly이다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"T extends readonly unknown[]\"), \" 에서 T가 배열 타입인지 조건부로 타입을 할당한다. 이런 경우 배열이 아닌 경우 \", React.createElement(_components.code, null, \"never\"), \"를 반환하기 때문에 타입 에러가 나지 않는다.\"), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"Exclude\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"T에서 U에 할당할 수 있는 타입을 제외하는 내장 제네릭 Exclude를 사용하지 않고 구현하는 문제이다.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type MyExclude&lt;T, U> = T extends U ? never : T;</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, React.createElement(_components.code, null, \"Exclude\"), \": \", React.createElement(_components.code, null, \"Exclude<T, U>\"), \" 는 U에 할당할 수 있는 타입을 제외한다. 차집합으로 이해할 수 있다.\"), \"\\n\", React.createElement(_components.li, null, \"분배법칙: 조건부 타입에서 분배법칙이 적용된다. 예를 들어 \", React.createElement(_components.code, null, \"A | B | C extends U ? X : Y\"), \" 는 \", React.createElement(_components.code, null, \"A extends U ? X : Y\"), \", \", React.createElement(_components.code, null, \"B extends U ? X : Y\"), \", \", React.createElement(_components.code, null, \"C extends U ? X : Y\"), \" 가 된다. \", React.createElement(_components.code, null, \"T extends U ? X : Y\"), \" 에서 T 유니언 타입은 개별 구성 요소를 확인한다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"T가 U에 속한다면, never를 반환한다.\"), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"Awaited\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"Promise와 같은 타입에 감싸인 타입이 있을 때, 안에 감싸인 타입이 무엇인지 가르키는 타입을 구현하는 문제이다.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type MyAwaited&lt;T> = T extends PromiseLike&lt;infer D> ? MyAwaited&lt;D> : T;</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.p, null, \"Promise에 감싸진 리턴 타입을 반환하기 위해 T가 Promise라면 Promise를 재귀적으로 풀어주고 그렇지 않다면 T를 반환하면 된다.\"), \"\\n\", React.createElement(_components.p, null, \"예를 들어 타입 \", React.createElement(_components.code, null, \"X\"), \"에서 Promise로 감싸진 타입을 가져올 때 다음처럼 동작한다.\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type MyAwaited&lt;T> = T extends PromiseLike&lt;infer D> ? MyAwaited&lt;D> : T;\\n\\ntype X = Promise&lt;string>\\ntype Foo = MyAwaited&lt;X> // string</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"MyAwaited<Promise<string>>\"), \"은 \", React.createElement(_components.code, null, \"PromiseLike<infer D>\"), \"타입에 해당하므로 다시 \", React.createElement(_components.code, null, \"MyAwaited<D>\"), \" 을 호출한다. 여기서 \", React.createElement(_components.code, null, \"infer D\"), \" 로 string을 추론한다. \", React.createElement(_components.code, null, \"MyAwaited<string>\"), \" 은 \", React.createElement(_components.code, null, \"PromiseLike\"), \"타입이 아니므로 타입 \", React.createElement(_components.code, null, \"string\"), \"을 반환한다.\"), \"\\n\", React.createElement(_components.h3, null, React.createElement(_components.code, null, \"infer\"), \"란?\"), \"\\n\", React.createElement(_components.p, null, \"조건부 타입에서 \", React.createElement(_components.code, null, \"infer\"), \" 키워드를 이용해 새로운 타입 변수를 선언적으로 정의할 수 있다. \", React.createElement(_components.code, null, \"type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;\")), \"\\n\", React.createElement(_components.h3, null, React.createElement(_components.code, null, \"Promise\"), \"가 아닌 \", React.createElement(_components.code, null, \"PromiseLike\"), \"를 사용하는 이유\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"Promise\"), \"가 아닌 \", React.createElement(_components.code, null, \"PromiseLike\"), \"를 사용하는 이유는 아래 테스트 케이스가 존재하기 때문이다.\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type T = { then: (onfulfilled: (arg: number) => any) => any }</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"PromiseLike\"), \"타입에는 후속처리 메서드인 then만 가지고 있다. 이를 통해 커스텀 비동기 처리를 유연하게 정의할 수 있다.\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// https://github.com/microsoft/TypeScript/blob/main/src/lib/es5.d.ts\\n\\ninterface PromiseLike&lt;T> {\\n    /**\\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\\n     * @param onfulfilled The callback to execute when the Promise is resolved.\\n     * @param onrejected The callback to execute when the Promise is rejected.\\n     * @returns A Promise for the completion of which ever callback is executed.\\n     */\\n    then&lt;TResult1 = T, TResult2 = never>(\\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike&lt;TResult1>) | undefined | null,\\n        onrejected?: ((reason: any) => TResult2 | PromiseLike&lt;TResult2>) | undefined | null\\n      ): PromiseLike&lt;TResult1 | TResult2>;\\n}</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"If\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"조건 C가 참이면 A, 아니면 B를 반환하는 타입을 구현하자.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type If&lt;C extends boolean, T, F> = C extends true ? T : F;</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.p, null, \"C는 true, false만 가능하도록 \", React.createElement(_components.code, null, \"boolean\"), \" 타입으로 제한하고 C 조건에 따라 T, F를 리턴하면 된다.\"), \"\\n\", React.createElement(_components.h2, null, \"Concat\"), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"Array.concat 함수를 타입 시스템에서 구현하자. 인수를 왼쪽부터 concat한 새로운 배열을 반환하자.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// 오답\\ntype Concat&lt;T extends unknown[], U extends unknown[]> = [\\n  T extends [] ? never : T[number],\\n  U extends [] ? never : U[number]\\n];\\n\\ntype Foo = Concat&lt;['1', 2, 3], []>; // [2 | 3 | \\\"1\\\", never]</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// 정답\\ntype Tuple = readonly unknown[];\\ntype Concat&lt;T extends Tuple, U extends Tuple> = [...T, ...U];\\n\\ntype Foo = Concat&lt;['1', 2, 3], []>; //  [\\\"1\\\", 2, 3]</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.p, null, \"T와 U를 concat할 수 있도록 T와 U를 배열로 타입을 제한했다. 요소의 타입으로 이루어진 튜플을 반환할 수 있도록 \", React.createElement(_components.code, null, \"T[number]\"), \" 를 했다. 그러나 \", React.createElement(_components.code, null, \"T[number]\"), \"는 배열의 요소 타입으로 이뤄진 유니언 타입을 추출한다. 그리고 빈 배열인 경우 never 타입이 반환되므로 오답이다.\"), \"\\n\", React.createElement(_components.p, null, \"여기서 T와 U를 배열타입으로 제한했으므로 열거 가능하다.\"), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"Includes\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"JavaScript의 \", React.createElement(_components.code, null, \"Array.includes\"), \" 함수를 타입 시스템에서 구현하세요. 타입은 두 인수를 받고, \", React.createElement(_components.code, null, \"true\"), \" 또는 \", React.createElement(_components.code, null, \"false\"), \"를 반환하자.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// 오답\\ntype Includes&lt;T extends readonly unknown[], U> = U extends T[number] ? true : false;</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.p, null, \"T 배열의 요소를 키로 갖는 타입을 만들고 U가 T의 키인지 확인하면 해결할 수 있을 것 같지만, U가 프로퍼티 키로 사용할 수 있을 때만 통과된다. (\", React.createElement(_components.a, {\n    href: \"https://github.com/type-challenges/type-challenges/issues/1568\"\n  }, \"참고\"), \")\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// 오답\\ntype Includes&lt;T extends readonly any[], U> = {\\n  [P in T[number]]: true\\n}[U] extends true ? true : false;</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.p, null, \"이를 해결하기 위해 배열의 첫번째 요소와 타입이 같은지 재귀적으로 타입을 확인해야 한다.\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">// 정답\\ntype Includes&lt;T extends readonly unknown[], U> =\\n  T extends [infer First, ...infer Rest]\\n    ? Equal&lt;First, U> extends true ? true : Includes&lt;Rest, U>\\n    : false;</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.p, null, \"U가 T의 구성 요소인지 확인하기 위해 T를 인덱스 접근 타입으로 변경하고 U가 이 유니온 타입에 속하는지 조건부로 true 또는 false를 반환한다. 그런데 이 코드는 primitive type만 통과하고 객체나 타입 자체는 통과하지 않는다. 예를 들어 \", React.createElement(_components.code, null, \"{ a: 'A'}\"), \" 는 \", React.createElement(_components.code, null, \"{ }\"), \"의 서브 타입으로 true를 반환한다.\"), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"infer\"), \" 키워드를 복습하고 가자. \", React.createElement(_components.code, null, \"infer\"), \"은 조건부 타입에서 \", React.createElement(_components.strong, null, \"참으로 평가\"), \"될 때 사용할 수 있는 타입을 추론하는 데 사용한다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"참고로 \", React.createElement(_components.code, null, \"@type-challenges/utils\"), \" 의 Equal은 아래처럼 구현되어 있다.\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">Equal&lt;X, Y> =\\n    (&lt;T>() => T extends X ? 1 : 2) extends\\n    (&lt;T>() => T extends Y ? 1 : 2) ? true : false;</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"Push\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"Array.push\"), \"의 제네릭 버전을 구현하자.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type Push&lt;T extends unknown[], U> = [...T, U];</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.p, null, \"T를 배열로 타입을 제한하고 배열 디스트럭쳐링을 이용해 배열 타입을 반환한다.\"), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"Unshift\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"Array.unshift\"), \"의 타입 버전을 구현하자.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type Unshift&lt;T extends unknown[], U> = [U, ...T];</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.p, null, \"Push 문제와 동일하다. T와 U 순서만 바꿔주면 된다.\"), \"\\n\", React.createElement(_components.h2, null, React.createElement(_components.strong, null, \"Parameters\")), \"\\n\", React.createElement(_components.h3, null, \"문제\"), \"\\n\", React.createElement(_components.p, null, \"내장 제네릭 \", React.createElement(_components.code, null, \"Parameters<T>\"), \"를 이를 사용하지 않고 구현하자.\"), \"\\n\", React.createElement(_components.h3, null, \"코드\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type MyParameters&lt;T> = T extends (...args: infer D) => unknown ? D : any;\\n\\nconst temp = ['1'];\\ntype x = MyParameters&lt;typeof temp>; // 타입 에러가 나지 않는다.</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.p, null, \"타입 에러가 나지 않는데, 이를 막으려면 타입 T를 함수로 제한하면 된다.\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">type MyParameters&lt;T extends (...args: any[]) => any> = T extends (...any: infer S) => any ? S : any</code></pre></div>\"\n    }\n  }), \"\\n\", React.createElement(_components.h3, null, \"풀이\"), \"\\n\", React.createElement(_components.p, null, \"조건부 타입으로 함수 타입이라면 args를 추론한 D 타입을 반환한다. 하지만 T타입이 함수로 제한하지 않아 함수가 아닌 타입에서 에러가 나지 않아서 아쉽다.\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import GATSBY_COMPILED_MDX from \"/Users/jina/Documents/GitHub/dev-hamster.github.io/src/content/type-challenges/easy/index.mdx\";\nimport {Link} from 'gatsby';\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport {Header} from 'components/Header';\nimport {Layout} from 'components/Layout';\nimport {GatsbyImage} from 'gatsby-plugin-image';\nimport {getThumbnailImage} from 'utils/getThumbnailImage';\nconst shortcodes = {\n  Link\n};\nfunction PageTemplate(_ref) {\n  let {data, children} = _ref;\n  const {frontmatter} = data.mdx;\n  const thumbnail = getThumbnailImage(frontmatter.thumbnail);\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(Layout, null, React.createElement(MDXProvider, {\n    components: Object.assign({\n      ul: props => React.createElement(\"ul\", Object.assign({}, props, {\n        style: {\n          listStyle: 'revert'\n        }\n      })),\n      ol: props => React.createElement(\"ul\", Object.assign({}, props, {\n        style: {\n          listStyleType: 'decimal'\n        }\n      }))\n    }, shortcodes)\n  }, React.createElement(\"article\", {\n    className: \"markdown-body\"\n  }, React.createElement(\"h1\", null, frontmatter.title), thumbnail && React.createElement(\"div\", {\n    style: {\n      position: 'relative',\n      width: '100%',\n      paddingBottom: '56.25%'\n    }\n  }, React.createElement(GatsbyImage, {\n    image: thumbnail,\n    alt: frontmatter.title,\n    className: \"absolute top-0 left-0 w-full h-full object-cover\"\n  })), children))));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(PageTemplate, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nconst query = \"1754812257\";\n","import { IGatsbyImageData } from 'gatsby-plugin-image';\nimport { Thumbnail } from 'types/post';\n\nexport const getThumbnailImage = (\n  thumbnail?: Thumbnail\n): IGatsbyImageData | undefined => {\n  if (!thumbnail) return;\n\n  if ('childImageSharp' in thumbnail) {\n    return thumbnail.childImageSharp.gatsbyImageData;\n  }\n  return thumbnail as IGatsbyImageData;\n};\n","/**\n * @import {MDXComponents} from 'mdx/types.js'\n * @import {Component, ReactElement, ReactNode} from 'react'\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {ReactElement}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","h3","p","ul","li","code","span","strong","a","blockquote","_provideComponents","components","React","dangerouslySetInnerHTML","__html","href","wrapper","MDXLayout","shortcodes","Link","PageTemplate","_ref","data","children","frontmatter","mdx","thumbnail","getThumbnailImage","Header","Layout","MDXProvider","style","listStyle","ol","listStyleType","className","title","position","width","paddingBottom","GatsbyImage","image","alt","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","childImageSharp","gatsbyImageData","emptyComponents","MDXContext","useMDXComponents","contextComponents","properties","allComponents","disableParentContext","Provider","value"],"sourceRoot":""}