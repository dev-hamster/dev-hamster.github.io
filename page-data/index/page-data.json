{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allMdx":{"nodes":[{"id":"8c581b0d-77ea-585c-a8cc-56d142b0e8ec","frontmatter":{"title":"FSD로 코드 경계 그리기","slug":"/FSD로 코드 경계 그리기","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABf0lEQVR42o2T207CQBCGef9bb3wGX0CvNCZGI/FAEA2aEKEi0gOluzOzbTHxd7olQgkHLybtzu7++80/uy1ixrcjXAc5jh4W+EwFhWNUedYQYVgWPI4Jc8twUud3RetvQAQio0LUWCBciwczgaV6fFhQxcSVkAKalOYicZ7sKSyQkXjiA4JKpEo27iMdnYJMoqRKZa0nMukYdj5FOCdkRivQw201p1H97xAsYaIuZoMTsI09lc+7BeTrAhLf+UOJrBLK/zyUfAHd78WqskRytaGA04Y5V4nkSkxetG6WbI01D1UgLzxZ5SfP+qDpDSjqgMNb0ORS16VaKm8ttUmoVDYZIw266mGqXVWadAgb9TT/CoqfYcKO+jqHMSv/dnuo5dqgjaR9DMnCZdm5elh6f1ffAjI4h0x6dY5pz7XJS/XwZ+ParG2g+mCXDOFM5MW3Cq66ppMbhvPaa+GKOAkgKsjTN3CWrG7Dck/zpewNqkv8uIe8XyF7OQPHo5pyw8dfHBCWBBZKUbAAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png","srcSet":"/static/d275c298c762d8b8e94f90601a2df767/69eb9/fsd-%EC%A0%81%EC%9A%A9.png 217w,\n/static/d275c298c762d8b8e94f90601a2df767/e56be/fsd-%EC%A0%81%EC%9A%A9.png 434w,\n/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png 867w","sizes":"(min-width: 867px) 867px, 100vw"},"sources":[{"srcSet":"/static/d275c298c762d8b8e94f90601a2df767/4c3cb/fsd-%EC%A0%81%EC%9A%A9.webp 217w,\n/static/d275c298c762d8b8e94f90601a2df767/6b58a/fsd-%EC%A0%81%EC%9A%A9.webp 434w,\n/static/d275c298c762d8b8e94f90601a2df767/7e940/fsd-%EC%A0%81%EC%9A%A9.webp 867w","type":"image/webp","sizes":"(min-width: 867px) 867px, 100vw"}]},"width":867,"height":540}}}},"body":"\n## 들어가며\n\n이번 프로젝트에서 코드의 유지보수성과 확장성을 높일 수 있는 FSD 아키텍처를 도입했습니다. 그 중 `createPost` 기능을 구현하며 기존 방식에서 느꼈던 문제점들과 FSD를 적용한 후 느낀 점을 회고해보려고 합니다.\n\n### FSD란?\n\nFSD는 `Feature-Sliced Design`로 코드를 **목적**에 따라 애플리케이션 구조를 잡는 아키텍처 방법론입니다. 이를 통해 **코드의 응집도를 높이고 결합도를 낮추어** 프로젝트 유지보수성을 극대화하는 데 중점을 둡니다.\n\n**FSD의 주요 개념**\n\n![fsd 계층 구조](fsd.jpg)\n\n- **레이어**: 애플리케이션의 전반적인 구조를 7가지 계층(App, Pages, Features 등)으로 나눔.\n- **슬라이스**: 각 비즈니스 도메인에 맞게 코드를 분리.\n- **세그먼트**: 슬라이스와 레이어 내에서 목적별로 코드를 분리 (예: UI, API, Model).\n\nFSD의 import 규칙은 **상위 레이어가 하위 레이어를 참조 가능**하다는 점과 **슬라이스는 Public API를 가진다**는 점이 핵심입니다.\n\n## FSD 구조를 적용한 createPost\n\nFSD를 적용하여 `createPost` 기능을 다음과 같이 구조화했습니다.\n\n### FSD 구조 적용\n\n- `pages/createPost/ui`: 페이지의 UI 구성.\n- `features/createPost/lib`: 폼 유효성 검사 로직.\n- `features/createPost/model`: 상태 관리 및 데이터 모델 정의.\n- ...\n\n```plaintext\n.\n├── entities\n│   └── post\n│       ├── api\n│       │   ├── createPostDto.ts\n│       │   └── createPost.ts\n│       └── ui\n│           └── createForm.tsx\n├── features\n│   └── createPost\n│       ├── lib\n│       │   └── validateForm.ts\n│       └── model\n│           ├── tag.ts\n│           ├── useFormState.ts\n│           └── useTagInput.ts\n└── pages\n    └── createPost\n        └── ui\n```\n\n### 기존 스타일과 비교\n\nFSD를 적용하기 전에는 코드 타입별로 폴더를 분류했습니다. 기존 방식으로 createPost 기능을 재구성하면 다음과 같은 모습입니다\n\n```\n.\n├── api\n│   └── createPost\n│       ├── index.ts\n│       └── type.ts\n├── components\n│   ├── common\n│   └── createPost\n│       └── CreateForm.tsx\n├── pages\n│   └── createPost.tsx\n├── hooks\n│   ├── useFormState.ts\n│   └── useImageInput.ts\n├── libs\n│   └── validateForm.ts\n└── types\n    └── post.ts\n```\n\n이 방식은 간단해 보이지만, 다음과 같은 문제점이 있었습니다:\n\n- 타입 관리의 혼란: 특정 타입이 여러 곳에서 사용되더라도, 어디서 관리해야 하는지 모호함.\n- 응집도 부족: 관련 코드가 분산되어, 하나의 기능을 수정하려면 여러 폴더를 오가야 했음.\n\nFSD 적용 전후의 import 관계를 대략적으로 그려보았습니다.\n\nFSD 적용 후: 기능병로 코드가 모여 있어 의존 관계가 단순해짐\n![fsd 적용](./fsd-적용.png)\n\nFSD 미적용: 코드가 분산되어 있어 의존 관계가 복잡함\n![fsd 미적용](./fsd-미적용.png)\n\n## 정리\n\nFSD는 러닝 커브가 높지만, 다음과 같은 이점을 제공합니다:\n\n1. **유지보수성 향상**: 도메인별로 코드가 나뉘어 기능 수정이 용이.\n2. **응집도 증가**: 관련 코드가 한곳에 모여 있어 가독성과 확장성이 개선.\n3. **결합도 감소**: 코드 간 의존성이 줄어 변경 사항의 영향을 최소화.\n\n---\n\n참고:\n\n- https://feature-sliced.design/docs\n- https://velog.io/@teo/fsd\n"},{"id":"a573e777-3e28-5377-b1cf-41b48d1f5881","frontmatter":{"title":"반응형 레이아웃 퍼블리싱 스터디 회고 🤓","slug":"/반응형-퍼블리싱-스터디-회고-🤓","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,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"},"images":{"fallback":{"src":"/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png","srcSet":"/static/17ad8121ccf87c6ce98490d2626d88cd/4d23f/07.png 231w,\n/static/17ad8121ccf87c6ce98490d2626d88cd/1b463/07.png 462w,\n/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png 924w","sizes":"(min-width: 924px) 924px, 100vw"},"sources":[{"srcSet":"/static/17ad8121ccf87c6ce98490d2626d88cd/1c447/07.webp 231w,\n/static/17ad8121ccf87c6ce98490d2626d88cd/4994e/07.webp 462w,\n/static/17ad8121ccf87c6ce98490d2626d88cd/6b2ec/07.webp 924w","type":"image/webp","sizes":"(min-width: 924px) 924px, 100vw"}]},"width":924,"height":1294}}}},"body":"\n퍼블리싱 속도를 높이고 레이아웃을 잡는 연습을 하기 위해 2024.11.10부터 4주간 퍼블리싱\n스터디에 참여했다. 동일한 Figma 디자인 시안으로 퍼블리싱을 진행해 다른 스터디원의\n노하우를 엿볼 수 있었다. 스터디에 참여하면서 grid, flex를 더 적극적으로 활용할 수\n있게 되었고, 퍼블리싱 팁뿐만 아니라 디렉토리 구조에 대해서도 지식을 넓힐 수 있었다.\n\n## week01\n\n**TL;DR**\n\n- 이미지 사이즈를 주는 방법은 3가지로 있고, 적재적소에 알맞게 사용하는게 좋다.\n- scss도 module을 지원한다. 하지만 CSS-in-JS가 선호되는 이유를 알겠다.\n\n**Figma 디자인 시안**\n\n![image01](01.png)\n\n**scss**\n\n개인적으로 CSS로 처리할 수 있는 작업은 CSS를 사용하는 것을 선호해 SCSS로 스타일링을 시도해보았다. 하지만 SCSS에서는 변수를 사용하려면 스타일 파일에서 명시적으로 연결해주어야 하는 점이 불편했다. 반면 CSS-in-JS는 변수를 쉽게 받아와 사용할 수 있다는 점이 큰 장점으로 느껴졌다.\n\n```\n// /styles/variables.scss\n\n// breakpoint를 변수로 관리했다.\n$tablet-breakpoint: 767px;\n$pc-breakpoint: 1024px;\n```\n\n```\n// button.module.scss에서 정의한 변수를 사용하려면 @use를 한다.\n@use '/styles/variables.scss' as var;\n\n.foo {\n  @media (min-width: var.$tablet-breakpoint) {\n    // ...\n  }\n}\n```\n\n**이미지 사이즈는 어떤 방법으로 줄까?**\n\n이미지 사이즈를 조정하는 방법은 이렇게 3가지가 있다. 어떤 방식으로 이미지를 넣어줘야 하는지 애매모호해서 스터디원의 의견과 구글링을 통해 기준을 정리해보았다.\n\n1.  이미지 태그에 직접 `width`, `height` 값 주기\n2.  이미지 `width`는 100%로 하고 부모 요소를 통해 스타일 제어하기\n3.  요소의 `background-image`속성으로 `object-position` 값을 주기\n\n> 이미지에 직접 width, height 값 주기\n\n- 디자인이 정적으로 고정되는 요소 (예: 해당 Fimga의 프로필 이미지)\n- CLS를 방지하고 브라우저가 이미지 크기를 미리 알고 효율적으로 로드\n\n> 이미지 width는 100%로 하고 부모 요소에 의존하기\n\n- 컨테이너 레이아웃, 가변적으로 적용되는 요소 (예: 해당 Fimga의 카드 컴포넌트 썸네일)\n\n> 요소의 background-image속성으로 object-position 값을 주기\n\n- 꾸밈 이미지와 같이 내용에 영향을 주지 않는 요소\n- 렌더 트리 생성 단계 이후에 이미지를 요청해 우선순위가 낮음\n\n**상단 컨텐츠 레이아웃**\n\n![image02](02.png)\n\nPC, 태블릿, 모바일 화면에서 레이아웃이 달라지는 디자인이다. 이 영역은 공통되는 초록생 영역을 기준으로 잡았다.\n\n초록색 영역은 `flex-direction`을 `column` 으로 레이아웃을 잡았다. 모바일 화면에서는 버튼 컨테이너와 Active Users 위치를 각각 `absolute`로 했다.\n\n**카드 리스트 레이아웃**\n\n![image03](03.png) ![image04](04.png)\n\n`Featured NFTs`와 `Cretors` 의 카드 영역은 모두 grid 레이아웃을 적용했다.\n\n**새로 알게된 사실**\n\nscss에서 `&__` 를 사용하면 상위 클래스 네임을 상속받을 수 있어 BEM 규칙을 따를 수 있다.\n\n```\n\n// 이것은\n.text-box {\n  &__title {\n  }\n}\n\n// 이렇게 컴파일 된다.\n.text-box{\n}\n.text-box__title {\n}\n```\n\n**작업 결과**\n\n![05](./05.gif)\n\n## Week02\n\n**TL;DR**\n\n- `flex: 1 1 auto` 를 이해하고 사용했다.\n- grid 레이아웃을 사용하면, 최대한 많은 요소를 보여주는 레이아웃을 그릴 수 있다.\n\n**Figma 디자인 시안**\n\n![06](06.png)\n\n**emotion 사용**\n\n디자인 재사용성을 높여보도록 `emotion`를 사용했는데, 퍼블리싱에만 집중했다. ^^;\n\n**reset css**\n\n[https://www.joshwcomeau.com/css/custom-css-reset/](https://www.joshwcomeau.com/css/custom-css-reset/) 를 사용했다.\n\n그 중에, isolation 속성이 인상깊은데,\n\n```\n/* https://www.joshwcomeau.com/css/custom-css-reset/ */\n\n/*\n  9. Create a root stacking context\n*/\n#root, #__next {\n  isolation: isolate;\n}\n```\n\n> This is beneficial since it allows us to guarantee that certain high-priority elements (modals, dropdowns, tooltips) will always show up above the other elements in our application. No weird stacking context bugs, no z-index arms race.\n\n모달, 드롭다운, 툴팁이 항상 다른 요소들 위에 표시되도록 보장할 수 있다고 한다.\n\n**카드 레이아웃**\n\n![07](07.png)\n\n화면 해상도가 넓어지면 최대한 많은 카드를 보여주기 위해 `grid-template-columns` 속성을 사용하고 최소 카드 width를 `315px` 를 주었다.\n\n```\nconst CardLayout = styled.div`\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(315px, 1fr));\n  grid-gap: 20px;\n`;\n```\n\n**탭 레이아웃**\n\n![08](08.png)\n\n두 버튼의 width 간격을 같은 비율로 맞춰주기 위해 `flex: 1 1 auto;` 를 적용했다. (미루고 미뤄왔던,,, `flex: 1 1 auto`를 이해했다. 😆)\n\nButton을 width 100%로 둬도 동일한 효과를 줄 수 있다고 한다.\n\n```\nconst TabContainer = styled.div`\n  display:flx;\n`\nconst Button = styled.div`\n    width: 100%;\n`\n```\n\n**Collection 하위 아이템 레이아웃**\n\n![09](09.png)\n\n하위 아이템의 레이아웃은 최소 너비를 95px를 보장하고 균등하게 나누기 위해 `flex: 1 1 95px;` 을 사용했다.\n\n하위 아이템 개수가 모자른 경우에는 조건문으로 빈 element를 넣어줬는데, grid-template-columns를 이용해 같은 공간을 3개로 균등하게 나누면 스크립트롤 작성하지 않아도 된다!\n\n```\ndisplay: grid;\ngrid-template-columns: 1fr 1fr 1fr;\n```\n\n**작업 결과**\n\n![10](10.gif)\n\n## week03\n\n**TL;DR**\n\n- Grid로 공백있는 레이아웃 표현하기\n\n**Figma 디자인 시안**\n\n![11](11.png)\n\n**그리드 시스템으로 공백이 있는 레이아웃 표현하기**\n\n모바일에서는 컨텐츠가 일렬로 배치되어 있고 태블릿 이상부터는 두 열로 배치된다. flex를 사용하면 태블릿 이상부터는 표현하기 어려워진다. 그리드 시스템을 사용하면 일렬, 두 열 레이아웃을 간결하게 구현할 수 있다.\n\n![12](12.png) <br /> ![13](13.png) <br /> ![14](14.png)\n\n`grid-template-areas`를 사용하면 이름을 지정해 레이아웃을 배치할 수 있다. 각 그리드\n아이템은 `grid-area` 속성으로 이름을 지정할 수 있다.\n\n각 영역에 `grid-area` 로 적당한 이름으로 준 뒤, 컨테이너에 이렇게 하면 일렬로 배치할 수 있다.\n\n```\nconst ContentsContainer = styled.div`\n    grid-template-areas:\n    'title'\n    'endsIn'\n    'creator'\n    'description'\n    'details'\n    'tags';\n  // ...\n`;\n```\n\n![15](15.png)\n\n태블릿 크기 이상에서는 그리드 아이템을 두 열로 나누어 배치한다. endsIn 영역은 오른쪽 열에 위치시키고 title부터 description 영역까지 세로로 걸치게 했다. 나머지 영역은 '.'을 사용하여 공백 처리한다.\n\n```\nconst ContentsContainer = styled.div`\n  // ...\n\n  @media (min-width: 834px) {\n    grid-template-areas:\n      'title title endsIn'\n      'creator creator endsIn'\n      'description description endsIn'\n      'details details .'\n      'tags tags .';\n    // ...\n    }\n`;\n```\n\n`endsIn` 영역(타이머)이 `description`까지 늘어나게 되는데, 이는 해당 요소에 `height`를 지정하지 않아 왼쪽 컨텐츠의 높이값을 따라가기 때문이다. 이 문제를 해결하기 위해 `endsIn` 컨텐츠에 `min-content` 값을 적용하여 자신의 내용물 크기만큼만 높이를 가지도록 했다.\n\n![16](16.png)\n\n```\nconst EndsInBlock = styled.div`\n  height: min-content;\n  // ...\n `\n```\n\n아래는 전체 코드의 일부이다. 흥미로운 점은 마크업 순서와 관계없이 `grid-area`의 이름 속성만으로 요소 배치가 결정된다.\n\n```\n<ContentsContainer>\n  <Title />\n  <Creator />\n  <Description />\n  <Details />\n  <Tags />\n  <EndsIn />\n</ContentsContainer>\n\nconst ContentsContainer = styled.div`\n  gap: 20px;\n  padding: 40px 30px;\n  display: grid;\n  grid-template-areas:\n    'title'\n    'endsIn'\n    'creator'\n    'description'\n    'details'\n    'tags';\n\n  @media (min-width: 834px) {\n    padding: 40px 72px;\n    grid-template-columns: 1fr 295px;\n    grid-template-areas:\n      'title title endsIn'\n      'creator creator endsIn'\n      'description description endsIn'\n      'details details .'\n      'tags tags .';\n    column-gap: 30px;\n  }\n\n  @media (min-width: 1280px) {\n    padding: 40px 115px;\n    column-gap: 150px;\n  }\n`;\n```\n\n**작업 결과**\n\n![17](17.gif)\n\n### week04\n\n**TL;DR**\n\n- 레이아웃 흐름을 방해하지 않고 스타일 주기\n\n**Figma 디자인 시안**\n\n![18](18.png)\n\n**Form 레이아웃**\n\ngrid 레이아웃으로 모바일에서는 1열로 배치하고 태블릿 이상부터는 `grid-template-areas`로 2열로 배치하도록 했다.\n\n```\n<FormContainer>\n    <HeroBox />\n    <FormBox />\n</FormContainer>\n```\n\n```\nconst FormContainer = styled.div`\n  display: grid;\n  grid-template-columns: 1fr;\n\n  @media (min-width: 834px) {\n    grid-template-areas: 'hero form';\n    grid-template-columns: 1fr 1fr;\n  }\n`;\n\nconst HeroBox = styled.div`\n  // ...\n  grid-area: 'hero';\n`;\n\nconst FormBox = styled(FlexColumnBox)`\n  // ...\n  grid-area: 'form';\n `\n```\n\n**Input focus 스타일**\n\nInput border스타일은 레이아웃에 영향을 주지 않는 `box-shadow`속성을 사용하고 `<InputEle/>` 에 focus가 활성화 됐을 때, 부모 컴포넌트에 포커스 스타일을 주기위해서 네이티브 focus스타일을 주지않고`:focus-within` 를 사용했다.\n\n![19](19.png)\n\n<br />\n![20](20.png)\n\n```\n<InputContainer>\n  <InputWrapper>\n    <InputEle/>\n  </InputWrapper>\n  <ErrorMessage>\n</InputContainer>\n```\n\n```\nconst InputWrapper = styled(FlexRowBox)`\n  // ...\n  box-shadow: 0px 0px 0px 1px rgba(133, 133, 132, 1);\n  &:focus-within {\n    box-shadow: 0px 0px 0px 1.5px rgba(162, 89, 255, 1);\n  }\n`;\n\nconst InputEle = styled.input`\n  // ...\n  outline: none;\n`;\n```\n\n**에러 메세지 레이아웃**\n\n에러메세지가 보여지면서 레이아웃 영향을 주지않도록 `absolute`를 사용했다.\n\n![21](21.png)\n\n```\n<InputContainer>\n  <InputWrapper>\n    <InputEle/>\n  </InputWrapper>\n  <ErrorMessage>\n</InputContainer>\n```\n\n```\nconst InputContainer = styled.div`\n  position: relative;\n`;\n\nconst ErrorMessage = styled.span`\n  // ...\n  position: absolute;\n  margin-top: 1px;\n`;\n```\n\n**작업 결과**\n\n![22](22.gif)\n"},{"id":"66e98d26-c788-5166-a1ae-694117f2c784","frontmatter":{"title":"[type-challenges] medium 도전","slug":"/type-challenges/medium","thumbnail":null},"body":"\n## **Get Return Type**\n\n### 문제\n\n내장 제네릭 `ReturnType<T>`을 이를 사용하지 않고 구현하자\n\n### 코드\n\n```\n// 아쉬운 정답\ntype MyReturnType<T extends (...args: any) => unknown> =\n  T extends (...args:any) => infer U\n      ? U\n      : never;\n```\n\n함수 인자 타입을 `never[]` 로 하면 모든 테스트 케이스가 통과된다.\n\n```\n// 정답\ntype MyReturnType<T extends (...args: never[]) => unknown> =\n  T extends (...args: never[]) => infer R\n    ? R\n    : never\n```\n\n### 해설\n\n리턴되는 타입을 `infer U`로 추론하고 U를 반환한다. 하지만 함수 인수를 받는 타입을 `unknown[]` 으로 하면 테스트 케이스가 일부만 통과해서 `any`로 변경해 모두 통과되도록 했다.\n\n**`unknown[]`이 안되는 이유**\n\n`unknown` 은 모든 타입의 상위 타입이므로 모든 타입은 `unknown`에 할당할 수 있다. 그렇기 때문에 `unknown` 은 가장 일반적인 타입이기 때문에 구체적인 타입과 호환되지 않는다.\n\n```\ntype foo = unknown extends string ? true : false; // false\n```\n\n**`never[]` 를 사용하는 이유**\n\nnever는 존재하지 않는 공집합이기 때문에 any를 포함해 어떤 값도 가질 수 없는 가장 구체적인 타입이어서 다른 타입들과 호환될 수 있다.\n\n```\ntype foo = never extends string ? true : false; // true\n```\n\n## **Omit**\n\n### 문제\n\n`T`에서 `K` 프로퍼티만 제거해 새로운 오브젝트 타입을 만드는 내장 제네릭 `Omit<T, K>`를 이를 사용하지 않고 구현하자.\n\n### 코드\n\nT의 프로퍼티 키에서 K가 아니라면 키값을 추출하는 코드를 의도했다. 이 코드는 infer의 잘못된 사용으로 동작하지 않는다.\n\n```\n// 오답\ntype MyOmit<T, K extends keyof T> = K extends infer Key keyof T ?\n  never :\n  { Key: T[Key] }\n```\n\n정답 코드는 이렇다.\n\n```\n// 정답\ntype MyOmit<T, K extends keyof T> = {[Key in keyof T as Key extends K ? never: Key]: T[Key]}\n```\n\n### 해설\n\n**`as` 키워드**\n\nas 키용해 이용해 맵드 타입의 키를 다시 매핑할 수 있다. 예를들어 모든 프로퍼티 키를 Hamster라고 키 이름을 다시 매핑할 수 있다.\n\n```\ntype MappedTypeWithNewProperties<Type> = {\n    [Properties in keyof Type as 'Hamster']: Type[Properties]\n}\n```\n\n## **Readonly 2**\n\n### 문제\n\n`T`에서 `K` 프로퍼티만 읽기 전용으로 설정해 새로운 오브젝트 타입을 만드는 제네릭 `MyReadonly2<T, K>`를 구현하세요. `K`가 주어지지 않으면 단순히 `Readonly<T>`처럼 모든 프로퍼티를 읽기 전용으로 설정해야 합니다.\n\n### 코드\n\n```\ntype MyReadonly2<T, K extends keyof T = keyof T> = { readonly [k in K]: T[k] } & Omit<T, K>;\n```\n\n### 해설\n\nK 프로퍼티는 readonly 속성을 부여하면 된다. 구현은 정답을 참고했다.\n\nK가 주어지지 않는 경우를 위해 `K extends keyof T = keyof T` default 값을 설정한다.\n\n**교차 타입 &**\n\n두 개 이상의 타입을 결합해 모든 타입의 속성을 포함하는 새로운 타입을 생성할 수 있다. `A & B`는 `A`와 `B`의 모든 속성을 포함하는 새로운 타입이 된다.\n\n**유니온 타입 |**\n\n두 개 이상의 타입 중 하나를 선택할 수 있는 새로운 타입을 생성한다. `A | B` 는 `A`또는 `B` 중 하나의 타입을 가질 수 있다.\n\n## **Deep Readonly**\n\n### 문제\n\n객체의 프로퍼티와 모든 하위 객체를 재귀적으로 읽기 전용으로 설정하는 제네릭 `DeepReadonly<T>`를 구현하세요.\n\n이 챌린지에서는 타입 파라미터 `T`를 객체 타입으로 제한하고 있습니다. 객체뿐만 아니라 배열, 함수, 클래스 등 가능한 다양한 형태의 타입 파라미터를 사용하도록 도전해 보세요.\n\n### 코드\n\n중첩된 객체 프로퍼티의 타입을 반환하는 타입은 만들었는데 다음은 어떻게 해야할까?\n\n```\n// 오답\ntype DeepReadonly<T> = T extends object ? DeepReadonly<T[keyof T]> : T\n```\n\n정답을 참고해서 `readonly` 타입을 반환하도록 했는데, 중첩된 객체에서는 `readonly`가 안된다. (아래 코드가 왜 잘못됐는지 모르겠다🥲 )\n\n```\n// 오답\ntype DeepReadonly<T> = T extends Record<PropertyKey, unknown> ?\n  { readonly [P in keyof T]: DeepReadonly<T[P]> }\n  :\n  T;\n\ntype x = DeepReadonly<{l: [\n        'hi',\n        {\n          m: ['hey']\n        },\n      ]}>;\n\n// 결과\n// type x = {\n//  readonly l: [\"hi\", {\n//      m: [\"hey\"];\n//    }];\n//  }\n\n// 기댓값\n// type x = {\n//  readonly l: readonly [\"hi\", {\n//      readonly m: readonly [\"hey\"];\n//    }];\n//  }\n```\n\n정답 코드를 보면 `T`에 프로퍼티 키로 접근할 수 있는 값이 없다면 T\\[K\\]를 반환하고 그렇지 않다면 재귀적으로 `DeepReadonly<T[K]>` 를 호출한다.\n\n```\n// 정답\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: keyof T[K] extends never ? T[K] : DeepReadonly<T[K]>\n}\n```\n\n### 해설\n\n**TypeScript 에서 `{}` vs `Object` vs `object`**\n\n- `{}` 는 빈 객체가 아닌 any non-nullsih value이므로 `undefined`, `null`을 제외한 모든 타입을 할당할 수 있다.\n- `Object` 도 `{}` 와 동일하다.\n- `object` 는 원시값을 제외한 모든 값이 할당 가능하다.\n\n빈 객체`{}` 타입만을 허용하고 싶다면 `never`를 사용하자. 자바스크립트의 객체 타입(중괄호로 이루어진 객체)만을 허용하고 싶다면 Record를 사용하면 된다.\n\n![mind](mind.jpeg)_타입스크립트는 어렵네요_\n\n## 문제 풀기에 앞서…\n\n문제 풀기에 앞서 아직 헷갈리는 내용을 짚고 넘어가보자.\n\n**정적 타입 검사:**\n\n타입스크립트는 프로그램을 실행시키지 않고 오류를 검출한다.\n\n**점진적 타입 시스템:**\n\n타입스크립트는 타입 검사를 점진적으로 적용해 동적 타입처럼 자유롭게 타입을 작성할 수 있다.\n\n```\nlet a = 10;  // 타입스크립트가 자동으로 number로 추론 (자동 타입 추론)\nlet b;       // 타입 명시가 없으므로 b는 암시적으로 any 타입을 가짐\nb = \"hello\"; // b에 어떤 값이든 할당 가능 (any 타입)\nb = 42;      // any 타입이기 때문에 타입 오류 없음\n```\n\n**구조적 타입 시스템이란:**\n\n타입스크립트 컴파일러는 두 타입의 명시적 선언이 아닌 **프로퍼티를 비교**하여 타입을 비교한다. 그러니까 타입 `Hamster`과 `Animal`이 있을 때, `Hamster` ⊂ `Animal`를 만족한다. `Hamster`의 프로퍼티는 `Animal`를 만족시키기 때문에 `Hamster`타입에 `Animal`을 할당할 수 있고 `Hamster`은 `Animal`타입과 호환이 가능하다.\n\n**Indexed Access Type:**\n\n인덱스를 사용해 객체의 프로퍼티 타입을 추출할 수 있다. 배열 요소의 타입을 가져오려면 `Foo[number]` 로 하면 된다.\n\n**infer:**\n\n조건부 타입의 `extends` 절 안에서 infer을 이용해 타입 변수를 추론할 수 있다. 이렇게 추론된 타입은 분기에서 참조될 수 있다.\n\n## **Tuple to Union**\n\n> 튜플 값으로 유니온 타입을 생성하는 제네릭 `TupleToUnion<T>`를 구현하세요.\n\n배열의 인덱스를 number로 접근해서 타입을 가져오면 된다.\n\n```\ntype TupleToUnion<T extends unknown[]> = T[number];\n```\n\n## **Chainable Options**\n\n> 체인 가능 옵션은 일반적으로 Javascript에서 사용됩니다. 하지만 TypeScript로 전환하면 제대로 구현할 수 있나요?\n>\n> 이 챌린지에서는 `option(key, value)`과 `get()` 두가지 함수를 제공하는 객체(또는 클래스) 타입을 구현해야 합니다. 현재 타입을 `option`으로 지정된 키와 값으로 확장할 수 있고 `get`으로 최종 결과를 가져올 수 있어야 합니다.\n\n너무 어려워서 정답을 봤다. R 타입은 option 메서드로 점진적으로 타입이 확장된다.\n\n```\ntype Chainable<T = object> = {\n  option<K extends PropertyKey, V>(\n    key: K extends keyof T\n         ? (V extends T[K] ? never : K)\n         : K,\n    value: V\n  ): Chainable<Omit<T, K> & Record<K, V>>; // Omit K from T\n  get(): T;\n}\n```\n\n### declare\n\n문제에서 a를 declare로 선언했는데, declare에 대해 알아보자.\n\n```\ndeclare const a: Chainable\n```\n\ndeclare는 타입이나 값을 설명하기 위해 사용할 수 있다. 변수, 객체, 함수 또는 외부 모듈 등에서 타입 정보를 제공하는 용도로 사용할 수 있다. declare 키워드로 선언된 변수는 javascript로 컴파일되지 않는다.\n\n## **Last of Array**\n\n> 배열 T를 사용하고 마지막 요소를 반환하는 제네릭 `Last<T>`를 구현합니다.\n\n`T[length - 1]` 식으로 접근하고 싶은데, 타입스크립트는 런타입 값을 알 수 없기 때문에 계산이 안된다.\n\n정답 코드에서는 새로운 배열을 만들고, 이 배열의 `T['length']` 를 접근한다.\n\n```\ntype Last<T extends unknown[]> = [unknown, ...T][T[\"length\"]]\n```\n\n## **Pop**\n\n> 배열 T를 사용해 마지막 요소를 제외한 배열을 반환하는 제네릭 `Pop<T>`를 구현합니다.\n\ninfer로 추론하고 P를 반환하면 된다.\n\n```\ntype Pop<T extends unknown[]> = T extends [...infer P, unknown] ? P : [];\n```\n\n### Shift, Push, Unshift 구현하기\n\n```\ntype Shift<T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push<T extends unknown[], X> = [...T, X];\n\ntype Unshift<T extends unknown[], X> = [X, ...T];\n```\n\n## **Promise.all**\n\n> Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array.\n\n09번은 너무 어려워서 패스하고 다음에 도전해본다!\n\n## **Type Lookup**\n\n> 때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다.\n>\n> 이 챌린지에서는 유니온 타입 `Cat | Dog`에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 `LookUp<Cat | Dog, 'dog'>`으로 Dog 타입을,` LookUp<Cat | Dog, 'cat'>`으로 `Cat` 타입을 얻을 수 있습니다.\n\n```\ntype LookUp<U, T> = U extends { type: T } ? U : never;\n```\n\n### Shift, Push, Unshift 구현하기\n\n```\ntype Shift<T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push<T extends unknown[], X> = [...T, X];\n\ntype Unshift<T extends unknown[], X> = [X, ...T];\n```\n\n## **Promise.all**\n\n> Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array.\n\n09번은 너무 어려워서 패스하고 다음에 도전해본다!\n\n## **Type Lookup**\n\n> 때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다.\n>\n> 이 챌린지에서는 유니온 타입 `Cat | Dog`에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 `LookUp<Cat | Dog, 'dog'>`으로 Dog 타입을, `LookUp<Cat | Dog, 'cat'>`으로 Cat 타입을 얻을 수 있습니다.\n\n```\ntype LookUp<U, T> = U extends { type: T } ? U : never;\n```\n\n## **Trim Left**\n\n> 정확한 문자열 타입이고 시작 부분의 공백이 제거된 새 문자열을 반환하는 TrimLeft를 구현하십시오.\n\n빈 공백을 제거하고 재귀적으로 trim을 하려고 했는데 U는 string이 아니라 배열 타입이 되므로 오답이다.\n\n```\ntype TrimLeft<S extends string> = S[number] extends [' ', ...infer U] ?  TrimLeft<U> : S;\n```\n\n리터럴을 이용해 처리할 수 있다.\n\n```\ntype Space = ' ' | '\\t' | '\\n';\ntype TrimLeft<S extends string> = S extends `${Space}${infer U}` ?  TrimLeft<U> : S;\n```\n\n## **Trim**\n\n> 정확한 문자열 타입이고 양쪽 끝의 공백이 제거된 새 문자열을 반환하는 Trim를 구현하십시오.\n\nTrimLeft 코드에서 분기 처리를 추가하면 된다.\n\n```\ntype Space = ' ' | '\\t' | '\\n';\n\ntype Trim<S extends string> = S extends `${Space}${infer U}`\n  ? Trim<U>\n  : S extends `${infer T}${Space}`\n  ? Trim<T>\n  : S;\n```\n\n유니언으로 처리하면 더 깔끔하게 처리할 수 있다.\n\n```\ntype Space = ' ' | '\\t' | '\\n';\n\ntype Trim<S extends string> = S extends `${Space}${infer T}` | `${infer T}${Space}` ? Trim<T> : S;\n```\n\n## **Capitalize**\n\n> 문자열의 첫 글자만 대문자로 바꾸고 나머지는 그대로 놔두는 Capitalize를 구현하세요.\n\nCapitalize 인터페이스를 사용하면 된다.\n\n```\ntype MyCapitalize<S extends string> = S extends `${infer X}${infer T}` ? `${Capitalize<X>}${T}` : S;\n```\n\n**Replace**\n\n> 문자열 S에서 From를 찾아 한 번만 To로 교체하는 `Replace<S, From, To>`를 구현하세요.\n\n리터럴 타입을 이용해 조건부로 넘겼지만, From이 `''` 케이스인 경우 통과하지 않는다.\n\n```\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string\n> = S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;\n```\n\nFrom이 공백 문자열인지 확인하는 분기를 추가하면 된다.\n\n```\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends ''\n  ? S\n  : S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;\n```\n\n## **ReplaceAll**\n\n> 주어진 문자열 S에서 부분 문자열 From을 찾아 모두 To로 교체하는 제네릭 `ReplaceAll<S, From, To>`을 구현하세요.\n\nReplace 코드에 재귀적으로 타입을 호출했는데, 이미 교체한 문자열에도 교체를 진행해 `foobarfoobar` 테스트 케이스를 통과하지 못한다.\n\n```\ntype ReplaceAll<\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends ''\n  ? S\n  : S extends `${infer T}${From}${infer X}`\n  ? ReplaceAll<`${T}${To}${X}`, From, To>\n  : S extends `${From}${infer T}`\n  ? ReplaceAll<`${To}${T}`, From, To>\n  : S;\n```\n\n리터럴 타입 내부에서 ReplaceAll 타입을 재귀적으로 호출하면 된다.\n\n```\ntype ReplaceAll<S extends string, From extends string, To extends string> = From extends ''\n  ? S\n  : S extends `${infer R1}${From}${infer R2}`\n  ? `${R1}${To}${ReplaceAll<R2, From, To>}`\n  : S\n```\n\n## **Append Argument**\n\n> 함수 타입 Fn과 어떤 타입 A가 주어질 때 Fn의 인수와 A를 마지막 인수로 받는 Fn과 동일한 함수 유형인 G를 생성하세요.\n\nFn의 인자 타입을 추론하고 A를 추가하고자 아래처럼 작성했는데, 문법상에 오류가 있다.\n\n```\ntype AppendArgument<Fn extends (...args: any[]) => unknown, A> = Fn extends (...X: any[]) => unknown ? (...X, A) => unknown : false;\n```\n\narguments를 올바르게 타입을 추론하면 된다.\n\n```\ntype AppendArgument<Fn, A> = Fn extends (...args: infer T) => infer U ? (...arg: [...T, A]) => U : never;\n```\n\n**arguments 객체**\n\narguments 객체는 함수에 전달된 인수에 해당하는 Array 형태의 객체이다.\n\n```\nfunction foo(a, b, c){\n    console.log(arguments[0] === a);\n    console.log(arguments[1] === b);\n    console.log(arguments[2] === c);\n}\n```\n\n---\n\n타입 챌린지는 임시 중단합니다.\n\n다양한 타입을 만드는건 재미있지만 자주 쓰이는 케이스로 타입스크립트를 학습하겠습니다~\n"},{"id":"6b2c3fe2-8ff8-5777-bd72-c6ad62307dd7","frontmatter":{"title":"[type-challenges] easy 도전","slug":"/type-challenges/easy","thumbnail":null},"body":"\n## PICK-4\n\n### 문제\n\npick을 사용하지 않고 Pick을 구현하는 문제이다.\n\n- `keyof` 는 객체의 키 값들을 숫자나 문자열 리터럴 유니언을 생성한다.\n- `in` 는 객체에 특정 속성이 존재하는지 확인할 수 있다.\n\n### 코드\n\n```\ntype MyPick<T, K extends keyof T> = {\n  [k in K]: T[k]\n}\n```\n\n### 풀이\n\n`K extends keyof T` K는 T의 프로퍼티 이름을 가진다. 매핑된 타입을 이용하면 키를 통해 타입을 반복적으로 생성할 수 있고 인덱스 시그니처 문법으로 작성하면 된다.\n\n## Readonly\n\n### 문제\n\nReadonly 타입을 사용하지 않고 구현하는 문제이다.\n\n- `readonly` 는 프로퍼티를 읽기 전용으로 지정할 수 있다.\n\n### 코드\n\n```\ntype MyReadonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n```\n\n## **Tuple to Object**\n\n### 문제\n\n각 원소의 값을 key/value로 갖는 오브젝트 타입을 반환하는 타입을 구현하는 문제이다.\n\n```\n// 배열의 원소의 값을 key/value로 갖는 타입을 반환한다.\n['tesla', 'model 3', 'model X', 'model Y']\n\n{ 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}\n```\n\n### 코드\n\n```\ntype TupleToObject<T extends readonly PropertyKey[]> = {\n  [P in T[number]] : P\n}\n```\n\n### 풀이\n\n- 배열 순회하기: `T[number]`을 통해 배열을 순회하여 타입을 가져올 수 있다. `T[number]` 은 인덱스가 숫자형인 요소들의 타입을 가져오므로 배열에 있는 모든 요소의 타입을 가져올 수 있다.\n- PropertyKey: `keyof` 를 통해 생성되는 key의 집합이다. 여기에는 string, number, symbol이 있다.\n\n## **First of Array**\n\n### 문제\n\n`T`를 받아 첫번째 원소의 타입을 반환하는 제네릭 `First<T>`를 구현하는 문제이다.\n\n### 코드\n\n```\n// 오답: 빈 배열인 경우 T[0]은 undefeind가 된다\ntype First<T extends any[]> = T[0] extends never ? never : T[0]; // 원소가 없다면 never 타입 반환\n\n// 정답1\ntype First<T extends unknown[]> = T[number] extends never ? never : T[0];\n// 정답2\ntype First<T extends unknown[]> = T extends [] ? never : T[0];\n```\n\n### 풀이\n\n- 조건부 타입: 배열이 빈 배열이라면 `never` 타입을 반환한다.\n\n## **Length of Tuple**\n\n### 문제\n\n튜블(배열)의 길이를 반환하는 제네릭 타입을 구현하는 문제이다.\n\n### 코드\n\n```\n// 오답: Length<5>인 경우 타입 에러가 나지 않는다.\ntype Length<T> = T extends readonly unknown[] ? T['length'] : never;\n```\n\n`<T extends readonly unknown[]>` 는 T가 `readonly unknown[ ]`이라는 타입을 반드시 만족해야 하므로 배열이 아닌 경우 타입 에러를 발생한다.\n\n```\n// 정답\ntype Length<T extends readonly unknown[]> = T[\"length\"];\n```\n\n### 풀이\n\n- `readonly`: 튜플은 고정된 요소를 저장하므로 readonly이다.\n\n`T extends readonly unknown[]` 에서 T가 배열 타입인지 조건부로 타입을 할당한다. 이런 경우 배열이 아닌 경우 `never`를 반환하기 때문에 타입 에러가 나지 않는다.\n\n## **Exclude**\n\n### 문제\n\nT에서 U에 할당할 수 있는 타입을 제외하는 내장 제네릭 Exclude를 사용하지 않고 구현하는 문제이다.\n\n### 코드\n\n```\ntype MyExclude<T, U> = T extends U ? never : T;\n```\n\n### 풀이\n\n- `Exclude`: `Exclude<T, U>` 는 U에 할당할 수 있는 타입을 제외한다. 차집합으로 이해할 수 있다.\n- 분배법칙: 조건부 타입에서 분배법칙이 적용된다. 예를 들어 `A | B | C extends U ? X : Y` 는 `A extends U ? X : Y`, `B extends U ? X : Y`, `C extends U ? X : Y` 가 된다. `T extends U ? X : Y` 에서 T 유니언 타입은 개별 구성 요소를 확인한다.\n\nT가 U에 속한다면, never를 반환한다.\n\n## **Awaited**\n\n### 문제\n\nPromise와 같은 타입에 감싸인 타입이 있을 때, 안에 감싸인 타입이 무엇인지 가르키는 타입을 구현하는 문제이다.\n\n### 코드\n\n```\ntype MyAwaited<T> = T extends PromiseLike<infer D> ? MyAwaited<D> : T;\n```\n\n### 풀이\n\nPromise에 감싸진 리턴 타입을 반환하기 위해 T가 Promise라면 Promise를 재귀적으로 풀어주고 그렇지 않다면 T를 반환하면 된다.\n\n예를 들어 타입 `X`에서 Promise로 감싸진 타입을 가져올 때 다음처럼 동작한다.\n\n```\ntype MyAwaited<T> = T extends PromiseLike<infer D> ? MyAwaited<D> : T;\n\ntype X = Promise<string>\ntype Foo = MyAwaited<X> // string\n```\n\n`MyAwaited<Promise<string>>`은 `PromiseLike<infer D>`타입에 해당하므로 다시 `MyAwaited<D>` 을 호출한다. 여기서 `infer D` 로 string을 추론한다. `MyAwaited<string>` 은 `PromiseLike`타입이 아니므로 타입 `string`을 반환한다.\n\n### `infer`란?\n\n조건부 타입에서 `infer` 키워드를 이용해 새로운 타입 변수를 선언적으로 정의할 수 있다. `type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;`\n\n### `Promise`가 아닌 `PromiseLike`를 사용하는 이유\n\n`Promise`가 아닌 `PromiseLike`를 사용하는 이유는 아래 테스트 케이스가 존재하기 때문이다.\n\n```\ntype T = { then: (onfulfilled: (arg: number) => any) => any }\n```\n\n`PromiseLike`타입에는 후속처리 메서드인 then만 가지고 있다. 이를 통해 커스텀 비동기 처리를 유연하게 정의할 수 있다.\n\n```\n// https://github.com/microsoft/TypeScript/blob/main/src/lib/es5.d.ts\n\ninterface PromiseLike<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n      ): PromiseLike<TResult1 | TResult2>;\n}\n```\n\n## **If**\n\n### 문제\n\n조건 C가 참이면 A, 아니면 B를 반환하는 타입을 구현하자.\n\n### 코드\n\n```\ntype If<C extends boolean, T, F> = C extends true ? T : F;\n```\n\n### 풀이\n\nC는 true, false만 가능하도록 `boolean` 타입으로 제한하고 C 조건에 따라 T, F를 리턴하면 된다.\n\n## Concat\n\n### 문제\n\nArray.concat 함수를 타입 시스템에서 구현하자. 인수를 왼쪽부터 concat한 새로운 배열을 반환하자.\n\n### 코드\n\n```\n// 오답\ntype Concat<T extends unknown[], U extends unknown[]> = [\n  T extends [] ? never : T[number],\n  U extends [] ? never : U[number]\n];\n\ntype Foo = Concat<['1', 2, 3], []>; // [2 | 3 | \"1\", never]\n```\n\n```\n// 정답\ntype Tuple = readonly unknown[];\ntype Concat<T extends Tuple, U extends Tuple> = [...T, ...U];\n\ntype Foo = Concat<['1', 2, 3], []>; //  [\"1\", 2, 3]\n```\n\n### 풀이\n\nT와 U를 concat할 수 있도록 T와 U를 배열로 타입을 제한했다. 요소의 타입으로 이루어진 튜플을 반환할 수 있도록 `T[number]` 를 했다. 그러나 `T[number]`는 배열의 요소 타입으로 이뤄진 유니언 타입을 추출한다. 그리고 빈 배열인 경우 never 타입이 반환되므로 오답이다.\n\n여기서 T와 U를 배열타입으로 제한했으므로 열거 가능하다.\n\n## **Includes**\n\n### 문제\n\nJavaScript의 `Array.includes` 함수를 타입 시스템에서 구현하세요. 타입은 두 인수를 받고, `true` 또는 `false`를 반환하자.\n\n### 코드\n\n```\n// 오답\ntype Includes<T extends readonly unknown[], U> = U extends T[number] ? true : false;\n```\n\nT 배열의 요소를 키로 갖는 타입을 만들고 U가 T의 키인지 확인하면 해결할 수 있을 것 같지만, U가 프로퍼티 키로 사용할 수 있을 때만 통과된다. ([참고](https://github.com/type-challenges/type-challenges/issues/1568))\n\n```\n// 오답\ntype Includes<T extends readonly any[], U> = {\n  [P in T[number]]: true\n}[U] extends true ? true : false;\n```\n\n이를 해결하기 위해 배열의 첫번째 요소와 타입이 같은지 재귀적으로 타입을 확인해야 한다.\n\n```\n// 정답\ntype Includes<T extends readonly unknown[], U> =\n  T extends [infer First, ...infer Rest]\n    ? Equal<First, U> extends true ? true : Includes<Rest, U>\n    : false;\n```\n\n### 풀이\n\nU가 T의 구성 요소인지 확인하기 위해 T를 인덱스 접근 타입으로 변경하고 U가 이 유니온 타입에 속하는지 조건부로 true 또는 false를 반환한다. 그런데 이 코드는 primitive type만 통과하고 객체나 타입 자체는 통과하지 않는다. 예를 들어 `{ a: 'A'}` 는 `{ }`의 서브 타입으로 true를 반환한다.\n\n> `infer` 키워드를 복습하고 가자. `infer`은 조건부 타입에서 **참으로 평가**될 때 사용할 수 있는 타입을 추론하는 데 사용한다.\n\n참고로 `@type-challenges/utils` 의 Equal은 아래처럼 구현되어 있다.\n\n```\nEqual<X, Y> =\n    (<T>() => T extends X ? 1 : 2) extends\n    (<T>() => T extends Y ? 1 : 2) ? true : false;\n```\n\n## **Push**\n\n### 문제\n\n`Array.push`의 제네릭 버전을 구현하자.\n\n### 코드\n\n```\ntype Push<T extends unknown[], U> = [...T, U];\n```\n\n### 풀이\n\nT를 배열로 타입을 제한하고 배열 디스트럭쳐링을 이용해 배열 타입을 반환한다.\n\n## **Unshift**\n\n### 문제\n\n`Array.unshift`의 타입 버전을 구현하자.\n\n### 코드\n\n```\ntype Unshift<T extends unknown[], U> = [U, ...T];\n```\n\n### 풀이\n\nPush 문제와 동일하다. T와 U 순서만 바꿔주면 된다.\n\n## **Parameters**\n\n### 문제\n\n내장 제네릭 `Parameters<T>`를 이를 사용하지 않고 구현하자.\n\n### 코드\n\n```\ntype MyParameters<T> = T extends (...args: infer D) => unknown ? D : any;\n\nconst temp = ['1'];\ntype x = MyParameters<typeof temp>; // 타입 에러가 나지 않는다.\n```\n\n타입 에러가 나지 않는데, 이를 막으려면 타입 T를 함수로 제한하면 된다.\n\n```\ntype MyParameters<T extends (...args: any[]) => any> = T extends (...any: infer S) => any ? S : any\n```\n\n### 풀이\n\n조건부 타입으로 함수 타입이라면 args를 추론한 D 타입을 반환한다. 하지만 T타입이 함수로 제한하지 않아 함수가 아닌 타입에서 에러가 나지 않아서 아쉽다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}