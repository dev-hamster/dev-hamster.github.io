{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allMdx":{"nodes":[{"id":"2ab68663-5df8-57ed-851a-ebca55021a25","frontmatter":{"title":"플라키 테스트 알아보기","slug":"/플라키 테스트 알아보기","date":"2026-01-04","tags":["TIL","테스트 자동화"],"thumbnail":null},"body":"\n본 글은 webdriverIO 기준으로 GPT의 도움을 받아 학습한 내용입니다.\n\n## 플라키 테스트란?\n\n같은 조건이지만 테스트 할 때마다 결과가 달라지는 현상을 말한다.\n\n플라키 테스트는 이런 문제점이 있다.\n\n- 개발 생산성 저하\n- 테스트 결과 신뢰도 하락\n- 실패 원인 분석 비용 증가\n\n## 플라키 테스트가 발생하는 원인\n\n1. 네트워크 상태\n   - API 응답 지연으로 UI가 완전히 렌더링 되지 않는 경우 (예: 스켈레톤 UI)\n   - 로그인 버튼 터치 후, 마이페이지로 이동할 때 네트워크가 느려 페이지 렌더링이 오래걸림\n2. 느린 렌더링\n\n   DOM에는 이미 존재하지만 아직 인터렉션이 가능한 상태가 아닌 경우\n   - 저사양 디바이스\n   - CI 환경\n   - 리액트 리스트 렌더링이 아직 끝나지 않은 상태\n   - 모달/바텀시트 애니메이션이 진행 중인 상태\n\n3. 테스트 실행 타이밍\n   - 동기적 단언으로 인해 retry를 하지 않는 경우\n   - 버튼 클릭 직후 UI 업데이트 전에 검증하는 경우\n\n## 어떻게 다루면 좋을까?\n\n### 비동기 단언 사용하기\n\n비동기적으로 변하는 상태는 조건이 만족될 때까지 기다리며 검증한다. 예를 들어서 버튼을 누르고 1초 후에 ‘Hello Wrold!’ 라고 텍스트가 표시되는 것을 검증한다면, `getText`가 아닌 타임아웃 내에 성공할때까지 retry를 하는 `toHaveText` 메소드를 사용한다.\n\n```jsx\n// Bad\nexpect(await textElement.getText()).toEqual('Hello World!');\n\n// Good\nawait expect(textElement).toHaveText('Hello World!');\n```\n\n### 테스트 retry 하기\n\n최후의 수단으로 외부 상태가 오염됐을 때(DB, 로그인 실패 등) 테스트 전체를 새 인스턴스에서 시작할 수 있다. 또한 플라키 테스트를 탐지 하기 위해 `—repeat` 옵션으로 여러번 실행해 불안정한 테스트를 식별할 수 있다.\n\n---\n\n참고\n\n[https://webdriver.io/docs/debugging/#debugging-flaky-tests](https://webdriver.io/docs/debugging/#debugging-flaky-tests)\n\n[https://webdriver.io/docs/retry/](https://webdriver.io/docs/retry/)\n\n[https://www.codewithjason.com/what-causes-flaky-tests/](https://www.codewithjason.com/what-causes-flaky-tests/)\n"},{"id":"6c2687c4-2f29-52fc-8b90-5c8b3e0fc485","frontmatter":{"title":"waitForExist vs waitForDisplayed","slug":"/waitForExist vs waitForDisplayed","date":"2026-01-04","tags":["TIL","테스트 자동화"],"thumbnail":null},"body":"\nwebdriverIO의 `waitFor...` 메서드 차이\n\n- wiatForExist: 주어진 타임아웃 시간 내에 DOM에 엘리먼트를 기다림. DOM에 하나라도 매칭이 되면 true를 리턴\n- waitForDisplayed: 뷰포트내에 있는가\n- waitForClckable: clickable한지 아닌지 상태를 기다림(브라우저만 지원) 이미 있다고 가정함\n- waitUntil: 주어진 컨디션이 참이 될때까지 기다림 (요소가 존재할때까지 기다리지 않음)\n"},{"id":"0b848b0e-d178-54f3-b2ec-21bdb3ed6df7","frontmatter":{"title":"2025 OFF QA 후기","slug":"/2025 OFF QA 후기","date":"2025-12-27","tags":["일상"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACrklEQVR42h2S609TBxjG+zcaN43JtsThQKAth17o9RTanran59YLtbVIOyu39nBRW1GDWpoiQ6gXEDRs0QUwMRqzGTXL/PTzxA+/vHk/vE+e98ljG/ylj+HzF3D09SNcHMIzMkLI7yMmjaPmEkxWNKbqWWo3izTWKiyvz9DsLtDqzLF44ypzs1WulitM5ypc0SvYQoMhQnYLR5CQM0BA8OMTxvB7vYSDY4gRP5HoGEHRhS8o4PM58HqcFqN43HZGhUHc1gyFXUjpADZ5xEARMmjuHJrLQNfrKJfXkLRbJHKrZIomen4GLTeHrNWIyA2q9XnM+TwxX5KwM0pYiCN6k4jWbksLBulRA9WdRRVU683r6AtPkMqbVFo9NvZ32HqxTXevx8P9HpcXtyi2n/Hpq4kmGsTsCkq8hj71kOyVDWzqqI5ioboyJIcV6os1pPpT4sYdfm9ucHCyzsm/bXqHHQ7fdMhP32XA2OXl+7vkJpIE+uJkknmUaptps4NNEXTSgmYJaoz3p+neM2jsbjPkuU00Nsv61hIHhws8fr7E04MGgXiTM7FXLD3epCSncJ4bpyDFMO+v4vWbVoZODdmpWqIKkd9SPGilef/fvHV4i5CrQGZylua9G1xbalKsmkiFVc5fOuTS9i55WcV5NkjMIXJ8VGQ8Oost5VBI2NOkHDJiX4I7KzKgsPzgNoLHREmVLdEZcuUG+ep1Sms9Spv7tN8+o5zN4jhtNeKCyMlxjb2jLrbEkIw0KJMYlgn/OkFzuco/X9Z593+bvZNt/nrb5ejjI44/7/D3xx3+/PAHB2+6PH/dYVKdxH7KjfunANOlGjdblsP4QIJYv8WAZDmcoKhPsWi2WFmpYdat0lanKBUKGGkdKZIkMhYlJEzguyji+jmA8wfPdxw/ehk67eUbn4YqBAXNxxwAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/60d9e80e7c0065896964d28ef5859ad9/1b2f1/%EC%9E%85%EC%9E%A5.png","srcSet":"/static/60d9e80e7c0065896964d28ef5859ad9/1b2f1/%EC%9E%85%EC%9E%A5.png 720w","sizes":"100vw"},"sources":[{"srcSet":"/static/60d9e80e7c0065896964d28ef5859ad9/815d6/%EC%9E%85%EC%9E%A5.webp 720w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5013888888888889}}}},"body":"\n11월에 OFF QA 를 다녀왔습니다. 요즘 갖고 있는 고민을 털어놓고 싶었고, 한 제품을 깊게 파고드는 QA는 어떤 느낌인지 궁금해서 신청했습니다.\n\n참가비랑 밥값까지 하면 5만원이라 솔직히 싸진 않았는데… 다녀오고 나서는 아깝다는 생각이 전혀 안 들었습니다! 오히려 다음 행사도 참여하고 싶을 정도입니다.\n\n![아이스브레이킹](./아이스브레이킹.png)\n\n아이스 브레이킹으로 QA 용어 맞추기 퀴즈를 했습니다. 저도 퀴즈를 맞추고 어떤 책을 고를지 한참 고민했습니다. LLM QA는 어떻게 접근하는지 궁금해져서 『인공지능 소프트웨어 품질 보증을 위한 테스트 기법』을 선택했습니다. (여담으로 메타모픽 테스트를 활용한다고 합니다.)\n\n![네트워킹](./네트워킹.png)\n\n드디어 네트워킹이 본격적으로 시작됐습니다. 여러 도메인 얘기를 들었는데, 낯선 분야라 완전히 이해하긴 어려웠습니다. 가장 흥미로웠던 분야는 커머스였습니다. 커피챗 했던 분들도 커머스 QA가 가장 재밌다고 해서 왜 그런지 물어봤습니다. 커머스는 정책이 자주 바뀌는데, 그 변화에 맞춰 QA 하는게 가장 재밌다고 했습니다. 이야기를 들어보니 QA가 매출과 바로 맞닿아 있는 점도 흥미로웠습니다.\n\n이후에는 어떻게 해야 QA 역할을 더 잘할 수 있을지 고민을 털어놨습니다. 미래에 100% 발생할 리스크들을 어떻게 다뤄야할지가 큰 고민이었는데, 리스크를 완전히 막으려 하지 말고 수치를 얼마나 완화할 수 있는지를 얘기하라고 한게 가장 인상이 깊었습니다. 또 개인적인 고민을 몇가지 털어놨는데, 자연스러운 현상이라고 하셔서 큰 도움이 됐습니다.\n\n![종료](./종료.png)\n\nOFF QA 덕분에 제 업무를 기술적으로 해결할 수 있는 부분이 무엇인지 고민할 수 있는 동기부여도 되고, 도움되는 조언을 들을 수 있어 좋았습니다. 훗날에는 제가 고민을 들어주는 사람이 되기를… 아자아자!\n"},{"id":"db974f97-e124-527e-915a-e1f89d129db1","frontmatter":{"title":"처음으로 AI와 협업해본 QA 경험 - 알바몬 AI QA 챌린지 회고","slug":"/처음으로 AI와 협업해본 QA 경험","date":"2025-11-16","tags":["AI","QA","Playwright"],"thumbnail":null},"body":"\nAI를 적극적으로 사용해서 테스트 설계와 테스트 코드 구현까지 경험할 수 있었던 AI Challenge QA 회고록을 자유롭게 작성해보았습니다.\n\n## AI를 QA도구로 써보자\n\n![알바몬개인회원로그인](login-page.png)\n\n챌린지 주제는 모바일 알바몬 개인 회원 로그인 자동화였습니다.\n\n예전에 다른 프로덕트에서 회원가입 후, 리워드 지급이 잘 되는지 E2E 테스트를 AI 도움으로 테스트 코드를 작성한 경험이 있는데, 그때 기억을 되살려 이번에는 테스트 케이스부터 적극적으로 AI를 활용해보고자 참여했습니다.\n\n이 챌린지에서 세운 목표는 두 가지 입니다.\n\n1. AI로 테스트 케이스 작성하기\n2. AI로 Playwright로 로그인 테스트코드 자동화하기\n\n## PRD기반으로 테스트 케이스 생성하기\n\nAI에 알바몬 개인 회원 로그인이 가지는 기본적인 PRD를 전달했습니다. 이를 바탕으로 AI가 테스트 케이스를 생성해줬습니다.\n\n```bash\n- 환경: 모바일 웹, Chrome/Edge 브라우저\n- 로그인 폼에 아이디와 비밀번호를 입력한다.\n- 로그인 성공 시, 마이페이지로 이동한다.\n- 로그인 실패 시, 브라우저 alert 창 표시한다.\n```\n\nAI는 빠르게 입력값, 실행 조건, 기대 결과를 포함한 TC를 빠르게 만들어줬습니다. 하지만 바로 사용하기엔 다음과 같은 한계점이 있었습니다.\n\n- 실제 DOM 구조를 몰라 임의의 선택자를 추천함\n- 상황에 맞지 않는 테스트 케이스를 제시함\n\n그래서 이후부터는 컨텍스트를 정교하게 제공했습니다. HTML 구조 알부를 전달하거나, 실제 사용자 흐름을 설명했습니다.\n\n## Playwright 자동화 구현\n\n![로그인 테스트 결과](./login-result.gif)\n\n테스트 자동화는 모바일, 웹 크로스 브라우저를 지원하는 Playwright를 사용했습니다.\n\n**시나리오**\n\n- 로그인, 비밀번호 입력 후 로그인 성공 시 마이페이지로 이동\n- 로그인 또는 비밀번호 공란시 로그인 실패 메시지 검증\n- 로그인 세션 만료시 로그인 페이지 이동\n\n**구현 전략**\n\n- [Gist Playwright 테스트 작성 가이드.md](https://gist.github.com/devbrother2024/7803601764476f79dbdfaf312a7e2454)를 참고하여\n  가이드를 작성했습니다.\n- `beforeEach`에서 항상 로그아웃 상태로 시작\n- `getByPlaceholder`로 접근자 선택자 위주로 사용하여 유지보수성을 고려\n- `test.step`으로 흐름을 단계별로 기록\n\n웹 페이지가 완전히 로드되지 않은 상태에서 테스트 코드가 실행되어 에러가 발생하는 케이스에서는 **URL or 요소 기준으로 대기**해 테스트 안정성을 확보했습니다.\n\n### 실행 결과\n\n![로그인 테스트 결과](./login-spec-test-result.png)\n\n- 테스트 약 18건 중 대부분 성공\n- 전체 플로우 실행 시간: 48.3초\n\n대부분의 케이스는 PASS했지만, 한 케이스에서는 Fail이 발생했습니다.\n\n**실패 케이스: 트리밍 미처리**\n\n![트리밍 실패 결과](./triming-fail.png)\n\n유효한 아이디, 비밀번호에 공백을 입력시, 공백이 올바르게 트리밍 되는 것응 기대했으나, Fail했습니다.\n\n유효한 아이디/비밀번호 앞뒤에 공백을 넣어서 입력하면,\n\n```bash\n␣␣␣{유효한 아이디}␣␣␣\n␣␣␣{유효한 비밀번호}␣␣␣\n```\n\n공백을 trim하고 정상 로그인 처리를 기대했으나, 실제로는 400에러가 발생했습니다.\n\n## AI와 협업하며 느낀 점\n\n이 챌린지를 통해 AI는 결과물을 빠르게 만드는 것을 체감했습니다. 하지만 기대값 정의, 플로우 정확성, DOM 이해는 결국 사람의 손이 필요해 테스트 결과의 검토는 사람이 해야 한다는 것을 느꼈습니다.\n\nAI를 잘 사용해 사람이 해야 하는 탐색적 테스트와 리스크 기반 테스트에 더 집중하는 QA 엔지니어가 되고 싶습니다.\n"},{"id":"29690a65-26dd-53b6-97db-097dcef5ef4a","frontmatter":{"title":"하루종일 걸릴 작업을 한시간만에 완료하기","slug":"/하루종일 걸릴 작업을 한시간만에 완료하기","date":"2025-11-07","tags":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA50lEQVR42o2SSwuDMBCE/f9/qz219NprD1qpUF9JfGu2OysJKlKyMJhM4MvOmogOZa2lZVm8sN+dzTOL/XGis4qOxjiOlCQJpWkqKsvSw8SLE3rfrvS5X9gMBFZVRU3TUN/31Lat7xq+0YaK+EXf54NsKBAgAI0xsgYQArxlH2edacjyJUFArbVElY4Y2nWdSCnFXs0qSWm1m+9fYJZlVBSFACHAAIaf57l4uDAYiGj4QsMw+MiAwpumSUaxhEbGjOq69t1tgWvsdRTBHSKOE+bpns3WBzQIiBjyN1nu6Tgg9s5H52f1A9uSD5wxKg48AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/b17ddb1e29f3f60510652ff1d862da8d/1b2f1/%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4%EC%98%88%EC%8B%9C.png","srcSet":"/static/b17ddb1e29f3f60510652ff1d862da8d/1b2f1/%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4%EC%98%88%EC%8B%9C.png 720w","sizes":"100vw"},"sources":[{"srcSet":"/static/b17ddb1e29f3f60510652ff1d862da8d/815d6/%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4%EC%98%88%EC%8B%9C.webp 720w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5013888888888889}}}},"body":"\nQA 업무 중, 앱 실행 후 특정 UI를 캡처해야 하는 작업이 있었습니다. 한두 개라면 금방 끝나는 일이죠. 하지만 테스트 대상이 100개가 넘는 다면...?\n\n앱 하나당 2분씩만 잡아도 몇 시간이 순식간에 지나가죠. 단순 반복 작업때문에 하루를 소비한다는건 정말 끔찍한 일이죠.\n\n## 내일 당장 쓸 수 있는 도구를 만들자\n\n아이디어는 단순했습니다. '앱을 실행하고 이미지 비교해서 이 UI가 보여주는지 검증하자.'\n문제는 웹 개발만 해왔던 터라 모바일도 이미지 처리는 낯선 영역이었습니다.`\n\n그래서 GPT와 함께 검증 & 구체화하고, Cursor 에이전트에서 코드를 함께 다듬는 방식으로 구현했습니다. 문서를 읽을 시간은 없었지만, AI와 대화하듯 코드를 작성해 30분만에 '돌아가는 형태'를 만들 수 있었습니다.\n\n![diagram](./diagram.png)\n\n## 5배 효율화하기\n\n완벽한 코드를 짤 여유는 없었습니다.\n대신, **당장 돌릴 수 있는 수준**을 목표로 잡았습니다.\n\n- 타이머, 대기 등 조정이 필요한 값은 환경변수를 통해 주입\n- 실패 케이스는 로그로 남기기\n- 로그 참고하여 변수 조정 + 셀프 이터레이션\n\n메인 업무를 진행하면서 작업이 종료될때마다 조금씩 변수를 조정하면서 이터레이션을 3번 정도 돌렸습니다. 그 결과, 약 80% 앱에 대해서는 자동으로 스크린샷을 성공하고, 나머지 20%는 수기로 진행해 약 300분 걸릴 작업을 60분 만에 마무리할 수 있었습니다.\n\n## 사용한 기술\n\n전 이런 원리를 알아가는걸 좋아합니다. 그리고 언젠가 이 지식을 써먹을 수 있을 날을 위해 정리해봤습니다.\n\n핵심 기술은 세가지 입니다.\n\n- adb: 안드로이드 기기 조작\n- python: 이미지 처리에 용이한 언어\n- scikit-image: 화면에 띄어지는지 감지하는 유사도 계산\n\n작동 흐름은 간단합니다. ADB로 앱을 실행하고, 일정 시간마다 화면을 캡쳐합니다. 그리고 이전 프레임과 현재 프레임을 비교해 유사도가 일정 기준 이하로 떨어지면 화면을 캡쳐합니다.\n\n명령어 한 줄이면 ADB로 앱 스킴을 실행할 수 있습니다. 저는 UI조작없이 단순히 앱 실행만 시키면 되는 작업이었어요.\n\n```bash\nadb shell am start -a android.intent.action.VIEW -d <scheme>\nadb shell screencap -p /sdcard/screen.png\n```\n\n유사도 측정은 이미지의 구조 정보만 파악할 수 있도록 RGB 색상 정보는 제외하고 Grayscale로 변환여 비교합니다.\n\n```python\nfrom skimage.metrics import structural_similarity\n\nimg1_array = np.array(img1.convert('L')) # Grayscale로 변환\nimg2_array = np.array(img2.convert('L'))\n\nsimilarity = structural_similarity(img1_array, img2_array)\n```\n\n## 마무리\n\n여러 변수가 있어 완벽한 자동화는 아니었습니다. 하지만 약 80%의 커버리지를 확보하면서 5시간은 소요됐을 일을 딱 한 시간만 수기 작업으로 마무리할 수 있었습니다.\n\n앞으로도 팀 생산성을 높일 수 있는 방법을 찾는 QA 엔지니어가 되겠습니다. 💪\n"},{"id":"2369f0f0-69c7-513b-b4b0-086c634ad17f","frontmatter":{"title":"탐.테가 뭔데? - 책 '탐험적 테스팅'을 읽는 Log","slug":"/탐테가뭔데","date":"2025-10-27","tags":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAADBv/EABQBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAcFLWjyE6R//xAAbEAADAAIDAAAAAAAAAAAAAAABAgQAAxMzNP/aAAgBAQABBQKWXlzbPpBdCrR9JUM1no//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQMBAT8BjX//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8BrH//xAAaEAEBAQADAQAAAAAAAAAAAAABAAIREjJB/9oACAEBAAY/Au2vMZFNM5fkXKTf/8QAHRABAAIBBQEAAAAAAAAAAAAAAQARMRAhUZGhsf/aAAgBAQABPyEAog4yzHkoz3BYpVOnriUNrnhPk//aAAwDAQACAAMAAAAQO9//xAAWEQEBAQAAAAAAAAAAAAAAAAABABH/2gAIAQMBAT8QAmtsv//EABcRAQEBAQAAAAAAAAAAAAAAAAEAESH/2gAIAQIBAT8QSOFl7f/EAB4QAQEAAgEFAQAAAAAAAAAAAAERACFBMVFhobHB/9oACAEBAAE/EGRpA6n8MKs4ldbL4VzQiQxQju/cGQtXDfGAJEqemf/Z"},"images":{"fallback":{"src":"/static/d0f773bf25d4b30bbdbabd63e6182baf/fe407/what_is_et.jpg","srcSet":"/static/d0f773bf25d4b30bbdbabd63e6182baf/37bba/what_is_et.jpg 750w,\n/static/d0f773bf25d4b30bbdbabd63e6182baf/61c72/what_is_et.jpg 1080w,\n/static/d0f773bf25d4b30bbdbabd63e6182baf/fe407/what_is_et.jpg 1200w","sizes":"100vw"},"sources":[{"srcSet":"/static/d0f773bf25d4b30bbdbabd63e6182baf/a66aa/what_is_et.webp 750w,\n/static/d0f773bf25d4b30bbdbabd63e6182baf/65dd5/what_is_et.webp 1080w,\n/static/d0f773bf25d4b30bbdbabd63e6182baf/edb28/what_is_et.webp 1200w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5625}}}},"body":"\nimport Thread from 'components/thread/Thread';\nimport ThreadItem from 'components/thread/ThredItem';\n\n해당 글은 책 '탐험적 테스팅: 배우고 통찰하며 개선하는 소프트웨어 테스트'을 읽고 편하게 작성한 스레드입니다.\n\n![탐험적 테스팅](book.jpg)\n\n<Thread>\n\n<ThreadItem>\n  태스트완료 = 모든 기능의 동작 확인하기 + 모든 위험 요소 탐험하기\n</ThreadItem>\n\n<ThreadItem>\n  탐테는 어떻게 하는거지? <br />- 간섭받지않고 오로지 테스트에 집중 <br /> -\n  개개인의 자유 의지와 책임감이 중요\n</ThreadItem>\n\n<ThreadItem>\n  가장 중요한 것은 테스트 설계와 수행을 동시에 하는 것임! 이것을 하려면 이전에\n  테스트를 통해 **학습** 한 것을 활용함\n</ThreadItem>\n\n<ThreadItem>세션 시간을 정해놓고 **테스트 차터**로 진행함</ThreadItem>\n\n<ThreadItem>\n  테스트 차터는 대게 테스트 목적, 자원, 찾아야 하는 정보로 구성되지만 양식이\n  어렵다면 간략하게 목적을 쓰는 것도 좋음! 예를 들어서 '사용자가 구매를 완료하지\n  못하는 시나리오를 찾아라' 같은 것도 좋은 차터가 될 수 있음\n</ThreadItem>\n\n<ThreadItem>\n  좋은차터란? 동작을 구체적으로 명시하지 않으면서 테스트가 나아가야할 방향을\n  작성한 것\n</ThreadItem>\n\n  <ThreadItem>\n  ```tsx\n  // ❌ Don’t \n‘보안에 취약한 모든 부분을 찾기 …(생략) 탐험을 떠나자’ // 너무 광범위함\n‘john doe를 가지는 이름을 제대로 처리하는지 …(생략) 탐험을 떠나자’ // 너무 구체적임\n````\n  ```tsx\n  // ✅ Do\n  // 여러 차터로 세밀하게 나누기\n  ‘보안에 취약한 점을 찾기 위해서 …(생략) 탐험을 떠나자’\n  ‘사용자가 구매하지 않을 콘텐츠에 접근할 수 있는지 …(생략) 탐험을 떠나자’\n````\n\n훌륭한 차터는 아주 명확한 행동 지침이나 결과물에 대한 언급 없어도 영감의 원천이 된다.\n\n</ThreadItem>\n\n<ThreadItem>\n  차터 작성하는 방법! <br /> 1. 요구사항 회의 도중에 발견되는 사항. 예를들어\n  개발자 얘기하면서 탐색해야할 곳을 발견하거나, 숨겨진 요구사항(신뢰성,\n  규모가변성 등)들을 차터로 만들자 <br /> 2. 새로운 기능과 연동이 잘 되는지,\n  변경된 조건에도 잘 동작하는지, 미래에 발생할 위험 요소(해킹 등)에 대해 차터를\n  만들자 <br />\n  3. 현재 집중하고 있는 차터에서 다른 방향으로 탐색하고 싶은 유혹이 들 때\n</ThreadItem>\n\n관찰하는건 어려운 일임\n\n- 기대한 결과대로 동작한다해도, 확인하지 못했던 부분에서 치명적인 것이 있을 수도 있음\n- 무주의 맹시\n- 의도적으로 그 상황들을 찾아내야 함\n\n본질적인 질문을 던져야함\nBAD: 로그인을 하고 '환영합니다!' 메세지가 보여줌\nGOOD: 로그인 후에 접근 권한이 있는 정보를 열람할 수 있음\n\n숨겨진 변수를 찾는 팁\n\n1. 셀 수 있는 것들\n\n- 0, 1 다수 휴리스틱: 결과값으로 0개, 1개, 1개 이상을 가지는 경우를 만들어 테스트하기\n- 극대 휴리스틱: 처리할 수 있는 값보다 더 많은 입력값이나 요청으로 테스트\n- 극소수 휴리스틱: 소프트웨어가 기대하는 값보다 더 작은 수로 입력하거나 더 적은 요청으로 테스트\n\n0, 1, 다수 휴리스틱인 경우 검색 데이터개 0개인 경우 적절한 ui를 보여주는게 떠오름\n극대휴리스틱인 경우 흔히 '따닥'이라 불리는 연속 요청이 떠오름\n\n타협하지 않고 꼭 지켜야할 규칙들을 찾아내기\n\n1. 항상 올바르게 동작해야 하는 핵심 기능\n2. 꼭 지원해야 하는 것들: 신뢰성, 규모 가변성, 사용성, 정확성 같은 품질 기준\n3. 프로젝트 이해관계자들이 주목하고 있는 다른 위험 요소들\n\n</Thread>\n````\n"},{"id":"f2204fc9-ec5a-5f46-8ce5-78138fdadc3c","frontmatter":{"title":"QA에서 자주 쓰이는 테스트 종류 정리","slug":"/QA에서 자주 쓰이는 테스트 종류 정리","date":"2025-10-01","tags":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC4UlEQVR42mNggABGCFXPxIAE/sPF4QDMD3WzEIp1to4HsR0jUv10olryHFOaWwLDwkwZ/v9nABtyar1Ry5El0k0g9v56BhawRnt7nmpflbK+GIPNHRE6K8q8VINA4nEeNnoJLtYQds2008tOH/vfvGbDf9uc6ckM/1cxMAdauoqd36l4fM0kyQBk5/TGGK09P6vg/9sDC/682DHj37amsP+1/tpZQJ+wdMe4coNcnNkw+8Tvudv/rZ67+r966ZxokDdZDiyUmXZsldb3w0uU97REy0mCPR/tXLS2xPb/hQ2z/7w8su73y2Nbfl1dO/H/3Ayz5/nhwQ5QO5mj66edOb/y8v8FS4/+1yvqTwKLzmpWctq/SOvDkRUqk7PsGXjmN9fFHpxZ9X9rreevY4sX/L+6cdH/Y8tn/j88u+fv+grXv9um1P2qT49XAOn1iMlJ1ivp77PNal4XGJHsyhAc42C+pV/5wMYpxu/2LdK6ubCeTa2ztEl1emX00dUF8X+f9vX/f3Sg7/+vw7v+vW5e9H9pqdfvWXU5m0r9/HixRlxKs+2Ngg6jnxe3Kf8/vlJqA0JGnHtSluGd61sF/h9bavr39sYVfw90pP1vCtXpBxtUj0gRoatWMRunpbGGhoYyMzQ1Rc9sW136/9Ih9f8vzzBtgSna3NeTf2R+3P8jy4R/755V/HdhltX/Oem6d3TlvAVB8mnGxlzRHip8oRYWnEAuIrkt7u+qvrj/7P+tm9z+r14jvg4mvmnmJI25BYFn1pTo/d/eHP5zU5H+/zW5um/8zI3Ncz082NN8jLlinS0NE5wsjGIczfRBOMHFTpWhu7iYe8nkJt3gPF89Md8IcbB3/kO8M682fePe1qD/m4v1f2+vtv2/qjb8e3aAx6JIW5NgcEqAejve3p4jysZGMMLJXJwBG/j//z84oOc2FpWtndTwvT0zeuvchvwrayY13CkK9Yr0MtWSABsI9Cp6pAAAWI48tPBsjJoAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/37ec33bc91d65e8ba926600f838633df/d2da8/monkiki.png","srcSet":"/static/37ec33bc91d65e8ba926600f838633df/d2da8/monkiki.png 512w","sizes":"100vw"},"sources":[{"srcSet":"/static/37ec33bc91d65e8ba926600f838633df/6142d/monkiki.webp 512w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.54296875}}}},"body":"\n몽키테스팅:\n\n- 임의의 입력값으로 동작을 확인\n- 예상치 못한 에러를 찾아냄\n- 개발자의 의도를 고려하지 않고 즉흥적으로 조작함\n- 버그를 재현하기 어렵거나 불가능한 경우가 있음\n\nAd-hoc 테스팅:\n\n- 테스터의 경험과 직관에 의존해서 즉흥적으로 테스팅함\n- 정식 ㅌ스트로 발견하기 어려운 결함을 발견할 수 있음\n\n탐색적 테스팅:\n\n- 도메인 지식과 경험을 활용해서 테스트를 설계하고 실행\n- 테스터의 경험에 기반해 테스트 설계와 실행이 동시에 이뤄짐\n- 시간 제한을 두고 테스트 차터를 수행\n\n스모크 테스팅:\n\n- 핵심 기능이 제대로 작동하는지 빠르게 확인하는 테스트\n- 새로운 빌드가 출시 되기 전, 핵심 기능이 제대로 작동하는지 확인\n\n확인 테스팅:\n\n- 결함이 성공적으로 제거되었는지 확인하는 테스트\n\n리그레이션 테스팅:\n\n- 변경 이후에 수정되지 않았거나 발견되지 않은 결함을 발견하는 테스트\n"},{"id":"46e447e2-27ef-5d96-8f0a-b0e36664108e","frontmatter":{"title":"QA의 세계로... ISTQB 취득 하기","slug":"/QA의 세계로 ISTQB 취득 하기","date":"2025-09-11","tags":null,"thumbnail":null},"body":"\nQA 관련 전문 지식을 쌓기 위해 ISTQB 자격증에 도전했습니다. 다른 후기를 보면 '실라버스만 공부하면 합격 가능하다'라고 했지만, 오픈 채팅에서는 2회 이상 응시했다는 후기가 있어 응시료가 20만 원이나 되는 만큼 부담감이 컸습니다. 그래도 다행히 합격해서 이렇게 후기를 남깁니다.\n\n## 왜 ISTQB를 따려 했나?\n\n직무전환의 진지함 보여주려고 했습니다. 20만원 상당의 자격증 & 국제 공인 자격증이여서 이 결심을 보여줄 수 있다고 생각했습니다.\n\n그리고 현재 QA 직무로 근무하고 있는데, 얕은 지식만으로 시작하다 보니 모르는 게 많았습니다. 그래서 자격증 준비를 하면 기초 지식을 빠르게 다지는 방법이라고 생각했습니다. 자격증을 못따도 공부를 했으니 이득이라고 생각했습니다.\n\n## 준비 방법\n\n여러 후기를 봤는데 《개발자도 알아야 할 소프트웨어 테스팅 실무》(개.알 책) 실라버스를 추천했습니다.\n\n저도 따라서 개.알을 구매했는데, 'SW 테스트가 이런 거구나' 정도만 감을 잡고 본격적인 공부는 실라버스로 진행했습니다.\n\n저는 이렇게 공부했습니다.\n\n1. 실라버스 1회독\n2. GPT에 실라버스 pdf 첨부해서 문제 돌리기\n3. 암기한 개념 써보기\n4. 샘플 문제 풀기\n\n이 4가지를 3번 반복했고 매일 2-3시간 두 달 정도 공부했습니다.\n\nGPT랑 공부한 흔적\n![GPT랑 공부한 흔적](./GPT랑공부.png)\n\n시험에서는 결함과 장애 같은 용어 차이를 정확히 아는지가 자주 나옵니다. 그래서 각 장마다 주요 개념을 마인드맵으로 정리하고 스스로 채점하는 방식이 큰 도움이 됐습니다.\n\n![암기](./마인드맵.png)\n\n## 시험 난이도 후기\n\n실라버스 다독 + 샘플 문제를 무난히 풀 수 있다면 합격할 수 있습니다. 합격점을 위한 문제 정도라면 답이 바로 눈에 들어왔어요.\n\n그러나 고득점을 노린다면... 4장은 추가 학습이 필요하다고 느꼈습니다. 샘플 문제만으로는 다양한 상황에 기법을 응용하기 어렵습니다. 샘플문제를 무난히 풀 수 있는 정도가 와서 자신이 있었는데 실제로는 어떤걸 찍어야할지 고민을 많이 했습니다.\n\n## 후기\n\n다행히 합격해 20만원을 지켜냈습니다! 점수는 아쉽게 간당간당했지만요\n\n전 왜 이걸 해야 하는지 알아야 몰입이 잘 되는데, 자격증 공부하면서 확실히 그 부분이 채워졌습니다. 업무 지시를 이해하기도 쉬웠고, 더 나아가서 어떤걸 더 하면 좋을까? 하고 고민해볼 수 있더라구요.\n\n자격증을 딸까 말까 고민 중이라면, 저는 따시는 추천합니다! :+1:\n"},{"id":"9fd83ddc-1461-567a-b98f-06ea260bba3b","frontmatter":{"title":"useQuery를 만들어보자","slug":"/useQuery를 만들어보자","date":"2025-01-23","tags":null,"thumbnail":null},"body":"\n## 들어가며\n\nReact Query는 제가 애정하는 라이브러리 중 하나입니다. 데이터 패칭 상태 관리를 마법 처럼 우아하게 처리하고 캐싱을 통해 불필요한 네트워크 요청을 줄여 리소스를 절약할 수도 있습니다. 예전에는 `useEffect`로 구현했는데 반복되는 중복 코드때문에 고민이 많았던 기억이 납니다.\n\n그런데 React Query에 너무 익숙해진 나머지, 정작 `useEffect`로 데이터 패칭을 구현하는 방법을 잊어버렸습니다. 그래서 이번에는 `useQuery` 훅을 직접 구현해보며 학습한 과정을 정리해보겠습니다.\n\n## 구현 목표\n\n이렇게 4가지를 구현해보았습니다.\n\n1. 상태 관리: `isPending`, `isError`, `data` 상태를 관리\n2. 경쟁 상태 방지: 여러번의 요청이 발생해도 최신 데이터만 화면에 보여지도록 보장\n3. 캐싱: 캐싱된 데이터가 있으면 이를 우선적으로 보여주고, 데이터가 stale한 상태라면 새로운 데이터를 패치\n4. retry 지원: 네트워크 요청 실패 시, 지정된 횟수만큼 재시도 할 수 있음\n\n## 구현 과정\n\n### 1. 상태 관리\n\n`useEffect`를 사용해 `isPending`, `isError`, `data` 상태를 관리하는 기능을 구현하면서 무한 렌더링에 빠졌습니다.\n\n`useEffect` 로직 내부에서 `queryKey`와 `queryFn`을 참조하여 `react-hooks` 린터 규칙에 따라 의존성 배열에 두 변수를 포함해야 합니다. 하지만 `queryFn`을 포함하면 무한 렌더링이 발생합니다.\n\n이는 `queryFn`이 리렌더링이 될때마다 **새로운 객체로 평가**되기 때문에 무한 렌더링에 빠지게 됩니다. 그래서 이를 방지하기 위해 의존성 배열에 `queryKey`만 포함했습니다.\n\n```tsx\n// useQuery.ts\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype UseQueryProps<T = any> = {\n  queryKey: string;\n  queryFn: () => Promise<T>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useQuery<TData = any, TError = any>({\n  queryKey,\n  queryFn,\n}: UseQueryProps) {\n  const [isPending, setIsPending] = useState(true);\n  const [data, setData] = useState<TData | undefined>();\n  const [error, setError] = useState<TError | undefined>();\n\n  useEffect(() => {\n    setIsPending(true);\n    setData(undefined);\n    setError(undefined);\n\n    try {\n      const result = await queryFn();\n      setData(result);\n      setError(undefined);\n      setIsPending(false);\n    } catch (error) {\n      setData(undefined);\n      setError(error as TError);\n      setIsPending(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [queryKey]);\n\n  return {\n    isPending,\n    error,\n    data,\n  };\n}\n```\n\n### 2. 경쟁 상태 방지\n\n![경쟁상태](./race-condition.png)\n\n만약에 동시에 여러 번의 요청이 발생했을 때 첫 번째 요청이 나중에 완료되면 두 번째 요청의 결과를 덮어씁니다.\n\n이를 방지하기 위해 현재 컴포넌트가 활성상태인지 나타내는 `active` flag를 통해 해결할 수 있습니다.\n\n새로운 요청이 발생할 때마다 `active`플래그를 `true`로 설정하고, 기존 요청에 대해서 클린업 함수를 실행해 `false`로 설정해 기존 요청의 결과를 무시합니다. 그러면 항상 마지막으로 요청한 요청에 대해서만 상태를 업데이트 하도록 보장할 수 있습니다.\n\n```tsx\n// useQuery.ts\n\nuseEffect(() => {\n  let active = true;\n  setIsPending(true);\n  setData(undefined);\n  setError(undefined);\n\n  const handleResult = (result: TData) => {\n    // 활성 상태가 아님\n    if (!active) return;\n\n    setData(result);\n    setError(undefined);\n    setIsPending(false);\n  };\n\n  const handleError = (error: TError) => {\n    // 활성 상태가 아님\n    if (!active) return;\n\n    setData(undefined);\n    setError(error as TError);\n    setIsPending(false);\n  };\n\n  try {\n    const result = await queryFn();\n    handleResult(result);\n  } catch (error) {\n    handleError(error as TError);\n  }\n\n  return () => {\n    active = false;\n  };\n}, [queryKey]);\n```\n\n### 3. retry 구현\n\n네트워크 요청 실패 시, `MAXIMUM_RETRY`만큼 재시도하도록 재귀적으로 `fetchWithRetry`를 호출했습니다.\n\n```tsx\n// useQuery.ts\n\n// ...\nconst fetchWithRetry = async (retry = 0) => {\n  try {\n    const result = await queryFn();\n    handleResult(result);\n  } catch (error) {\n    if (retry + 1 < MAXIMUM_RETRY) {\n      fetchWithRetry(retry + 1);\n    } else {\n      handleError(error as TError);\n    }\n  }\n};\n\nif (retry) {\n  fetchWithRetry();\n} else {\n  fetchWithoutRetry();\n}\n```\n\n### 4. cache 구현\n\n캐시를 관리하기 위해 싱글톤 클래스를 사용해 다른 useQuery에서도 동일한 캐시 데이터에 데이터를 저장할 수 있도록 했습니다.\n\nqueryKey를 기준으로 데이터를 저장하고 유효한 cacheTime 과 함께 데이터를 저장해 데이터를 읽었을 때 stale하다면 삭제하도록 했습니다.\n\n```tsx\n// queryCache.ts\n\ninterface CacheData<TData> {\n  createdAt: Date; // 데이터 생성 시간\n  cacheTime: number;\n  value: TData;\n}\n\nexport class QueryCache<TData> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private static instance: QueryCache<any>;\n  private cache: Record<string, CacheData<TData>> = {};\n\n  private constructor() {}\n\n  static getInstance<TData>(): QueryCache<TData> {\n    if (!QueryCache.instance) {\n      QueryCache.instance = new QueryCache();\n    }\n    return QueryCache.instance;\n  }\n\n  writeCache({\n    key,\n    value,\n    cacheTime,\n  }: {\n    key: string;\n    value: TData;\n    cacheTime: number;\n  }) {\n    this.cache[key] = { value, createdAt: new Date(), cacheTime };\n  }\n\n  readCache(key: string) {\n    if (key in this.cache) {\n      const cachedItem = this.cache[key];\n      const isStale =\n        new Date().getTime() - cachedItem.createdAt.getTime() >\n        cachedItem.cacheTime;\n      if (isStale) {\n        // 데이터 삭제\n        this.#deleteCache(key);\n        return null;\n      } else {\n        return cachedItem;\n      }\n    }\n    return null;\n  }\n\n  #deleteCache(key: string): void {\n    delete this.cache[key];\n  }\n}\n```\n\n```tsx\n// useQuery.ts\n\n// ...\nconst handleResult = (result: TData) => {\n  // 활성 상태가 아님\n  if (!active) return;\n\n  // 캐시에 저장\n  if (cache) {\n    queryCache.writeCache({ key: queryKey, value: result, cacheTime });\n  }\n\n  setData(result);\n  setError(undefined);\n  setIsPending(false);\n};\n\n// ...\nconst cachedData = queryCache.readCache(queryKey);\nif (cache && cachedData) {\n  setData(cachedData.value as TData);\n  setIsPending(false);\n  setError(undefined);\n} else {\n  if (retry) {\n    fetchWithRetry();\n  } else {\n    fetchWithoutRetry();\n  }\n}\n```\n\n### 전체코드\n\n```tsx\n// queryCache.ts\n\ninterface CacheData<TData> {\n  createdAt: Date; // 데이터 생성 시간\n  cacheTime: number;\n  value: TData;\n}\n\nexport class QueryCache<TData> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private static instance: QueryCache<any>;\n  private cache: Record<string, CacheData<TData>> = {};\n\n  private constructor() {}\n\n  static getInstance<TData>(): QueryCache<TData> {\n    if (!QueryCache.instance) {\n      QueryCache.instance = new QueryCache();\n    }\n    return QueryCache.instance;\n  }\n\n  writeCache({\n    key,\n    value,\n    cacheTime,\n  }: {\n    key: string;\n    value: TData;\n    cacheTime: number;\n  }) {\n    this.cache[key] = { value, createdAt: new Date(), cacheTime };\n  }\n\n  readCache(key: string) {\n    if (key in this.cache) {\n      const cachedItem = this.cache[key];\n      const isStale =\n        new Date().getTime() - cachedItem.createdAt.getTime() >\n        cachedItem.cacheTime;\n      if (isStale) {\n        // 데이터 삭제\n        this.#deleteCache(key);\n        return null;\n      } else {\n        return cachedItem;\n      }\n    }\n    return null;\n  }\n\n  #deleteCache(key: string): void {\n    delete this.cache[key];\n  }\n}\n```\n\n```tsx\n// useQuery.ts\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype UseQueryProps<T = any> = {\n  queryKey: string;\n  queryFn: () => Promise<T>;\n  cache?: boolean;\n  cacheTime?: number;\n  retry?: boolean;\n};\n\nconst MAXIMUM_RETRY = 5; // 최대 retry 횟수\nconst DEFAULT_CACHE_TIME = 60 * 1000; // 캐시 디폴트 저장 시간, 1분\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useQuery<TData = any, TError = any>({\n  queryKey,\n  queryFn,\n  cache,\n  cacheTime = DEFAULT_CACHE_TIME,\n  retry,\n}: UseQueryProps) {\n  const [isPending, setIsPending] = useState(true);\n  const [data, setData] = useState<TData | undefined>();\n  const [error, setError] = useState<TError | undefined>();\n  const queryCache = useMemo(() => QueryCache.getInstance(), []);\n\n  useEffect(() => {\n    let active = true;\n    setIsPending(true);\n    setData(undefined);\n    setError(undefined);\n\n    const handleResult = (result: TData) => {\n      // 활성 상태가 아님\n      if (!active) return;\n\n      // 캐시에 저장\n      if (cache) {\n        queryCache.writeCache({ key: queryKey, value: result, cacheTime });\n      }\n\n      setData(result);\n      setError(undefined);\n      setIsPending(false);\n    };\n\n    const handleError = (error: TError) => {\n      // 활성 상태가 아님\n      if (!active) return;\n\n      setData(undefined);\n      setError(error as TError);\n      setIsPending(false);\n    };\n\n    const fetchWithRetry = async (retry = 0) => {\n      try {\n        const result = await queryFn();\n        handleResult(result);\n      } catch (error) {\n        if (retry + 1 < MAXIMUM_RETRY) {\n          fetchWithRetry(retry + 1);\n        } else {\n          handleError(error as TError);\n        }\n      }\n    };\n\n    const fetchWithoutRetry = async () => {\n      try {\n        const result = await queryFn();\n        handleResult(result);\n      } catch (error) {\n        handleError(error as TError);\n      }\n    };\n\n    const cachedData = queryCache.readCache(queryKey);\n    if (cache && cachedData) {\n      setData(cachedData.value as TData);\n      setIsPending(false);\n      setError(undefined);\n    } else {\n      if (retry) {\n        fetchWithRetry();\n      } else {\n        fetchWithoutRetry();\n      }\n    }\n\n    return () => {\n      active = false;\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [queryKey, cache, cacheTime, retry]);\n\n  return {\n    isPending,\n    error,\n    data,\n  };\n}\n```\n"},{"id":"81103934-4eeb-5da0-9dd1-5d141cde9e49","frontmatter":{"title":"FSD로 코드 경계 그리기","slug":"/FSD로 코드 경계 그리기","date":"2025-01-16","tags":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVR42p2SW0/CQBCF+f+PvvkffNcXEx40GhVjQA0aDchFLi0tO5dtwZjjtIsGiAXjw6Sd2d1vz5zZGovgwzPO3zIcNJYYJorcC4q6WKgKiBW3fUZKAq+hXhW19YSZDMQbG1QCvBcX4JDvBzJD/QI+hxV1a5NH6gStcY7UlOp+haZIc7iojVn3GDSPSiVEVH5dMoBLx5gkjLlzZRflmgUzVwEXcNMmZq9HEIos97ZIEFOt4zo0urE8K2Gi+r+WVTOL3IbAq0FkcCtlfwQaIFsGmMF51gaNLsCTO8jkEvRet32JAeXXVjeB1iLFAyS9pnk4M+88OOmCpvdw8TMoeoAzMLkEztGP0moPTRn1rhFfHULnk/KCouXC22JghZflv3kiL6fQYSvUhHe1bH4tPreezdoBDkPycccunQZ4JXD9kFT4UyiOe5CoCx49Qebfr4F3ACuDQ4v9BrRzhvTxBBy9BZVbPn4BYJ6VlEM7qVUAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png","srcSet":"/static/d275c298c762d8b8e94f90601a2df767/fbddd/fsd-%EC%A0%81%EC%9A%A9.png 750w,\n/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png 867w","sizes":"100vw"},"sources":[{"srcSet":"/static/d275c298c762d8b8e94f90601a2df767/4c146/fsd-%EC%A0%81%EC%9A%A9.webp 750w,\n/static/d275c298c762d8b8e94f90601a2df767/7e940/fsd-%EC%A0%81%EC%9A%A9.webp 867w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.6228373702422145}}}},"body":"\n## 들어가며\n\n이번 프로젝트에서 코드의 유지보수성과 확장성을 높일 수 있는 FSD 아키텍처를 도입했습니다. 그 중 `createPost` 기능을 구현하며 기존 방식에서 느꼈던 문제점들과 FSD를 적용한 후 느낀 점을 회고해보려고 합니다.\n\n### FSD란?\n\nFSD는 `Feature-Sliced Design`로 코드를 **목적**에 따라 애플리케이션 구조를 잡는 아키텍처 방법론입니다. 이를 통해 **코드의 응집도를 높이고 결합도를 낮추어** 프로젝트 유지보수성을 극대화하는 데 중점을 둡니다.\n\n**FSD의 주요 개념**\n\n![fsd 계층 구조](fsd.jpg)\n\n- **레이어**: 애플리케이션의 전반적인 구조를 7가지 계층(App, Pages, Features 등)으로 나눔.\n- **슬라이스**: 각 비즈니스 도메인에 맞게 코드를 분리.\n- **세그먼트**: 슬라이스와 레이어 내에서 목적별로 코드를 분리 (예: UI, API, Model).\n\nFSD의 import 규칙은 **상위 레이어가 하위 레이어를 참조 가능**하다는 점과 **슬라이스는 Public API를 가진다**는 점이 핵심입니다.\n\n## FSD 구조를 적용한 createPost\n\nFSD를 적용하여 `createPost` 기능을 다음과 같이 구조화했습니다.\n\n### FSD 구조 적용\n\n- `pages/createPost/ui`: 페이지의 UI 구성.\n- `features/createPost/lib`: 폼 유효성 검사 로직.\n- `features/createPost/model`: 상태 관리 및 데이터 모델 정의.\n- ...\n\n```plaintext\n.\n├── entities\n│   └── post\n│       ├── api\n│       │   ├── createPostDto.ts\n│       │   └── createPost.ts\n│       └── ui\n│           └── createForm.tsx\n├── features\n│   └── createPost\n│       ├── lib\n│       │   └── validateForm.ts\n│       └── model\n│           ├── tag.ts\n│           ├── useFormState.ts\n│           └── useTagInput.ts\n└── pages\n    └── createPost\n        └── ui\n```\n\n### 기존 스타일과 비교\n\nFSD를 적용하기 전에는 코드 타입별로 폴더를 분류했습니다. 기존 방식으로 createPost 기능을 재구성하면 다음과 같은 모습입니다\n\n```\n.\n├── api\n│   └── createPost\n│       ├── index.ts\n│       └── type.ts\n├── components\n│   ├── common\n│   └── createPost\n│       └── CreateForm.tsx\n├── pages\n│   └── createPost.tsx\n├── hooks\n│   ├── useFormState.ts\n│   └── useImageInput.ts\n├── libs\n│   └── validateForm.ts\n└── types\n    └── post.ts\n```\n\n이 방식은 간단해 보이지만, 다음과 같은 문제점이 있었습니다:\n\n- 타입 관리의 혼란: 특정 타입이 여러 곳에서 사용되더라도, 어디서 관리해야 하는지 모호함.\n- 응집도 부족: 관련 코드가 분산되어, 하나의 기능을 수정하려면 여러 폴더를 오가야 했음.\n\nFSD 적용 전후의 import 관계를 대략적으로 그려보았습니다.\n\nFSD 적용 후: 기능병로 코드가 모여 있어 의존 관계가 단순해짐\n![fsd 적용](./fsd-적용.png)\n\nFSD 미적용: 코드가 분산되어 있어 의존 관계가 복잡함\n![fsd 미적용](./fsd-미적용.png)\n\n## 정리\n\nFSD는 러닝 커브가 높지만, 다음과 같은 이점을 제공합니다:\n\n1. **유지보수성 향상**: 도메인별로 코드가 나뉘어 기능 수정이 용이.\n2. **응집도 증가**: 관련 코드가 한곳에 모여 있어 가독성과 확장성이 개선.\n3. **결합도 감소**: 코드 간 의존성이 줄어 변경 사항의 영향을 최소화.\n\n---\n\n참조:\n\n- https://feature-sliced.design/docs\n- https://velog.io/@teo/fsd\n"},{"id":"16c12736-a3ac-5bcf-b947-bae3fb5a471b","frontmatter":{"title":"반응형 레이아웃 퍼블리싱 스터디 회고 🤓","slug":"/반응형-퍼블리싱-스터디-회고-🤓","date":"2024-12-10","tags":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAAGi0lEQVR42nWV228bxxXGmYsRIYlly7paokSJokguyeXuci8kl/ebRFKiLtbVlmTLMWTnYtmOKse149ZAqgSB4rhFDdtIW9tBg7qAi6LIQ18KBIVbFOhrH4o+F8j/8euMLKFAgT4c7M6cme+cmXO+bzzpdJpEwsR2HAzdIhDS8Ad1YnETxxZzwpdKpchks6QPzEmnsFIHlkxiH/y7bgZPOBzilSNttPUM4FVDLK+5XDpvkchHeXNghFffaMfn8+PUKqgTVeLi68xM4U43sOrjhAsF+uManWEF3bbxBEZHOer1k19e4vbGAr8+W+HJgsPTi2XOrK/QFYrSf9JLuj7BWKnIxtYGz39zj2d/+h1Pnn/F9rWLhETW3eHwS8CQliAZG2dK0Vkc7KLaeZzMsXZmu3u5GLaw03WGTYtkpUi4VuPd9xapjxf54usvWd+6RDBqo6cdumNxDHF8T8xMMtzXx2zSzz+uxniweIwv597k+50oj5cVunp6UARgoljEqJS5c32TSx9usv30EadvXSeZzRAMhjkxGkIXdfAEg0FeO9pFIBLj45kYlWQPtVw/n80HKCSjeNo68Q0OYVYqBNIu5z98n43rO8ytrpGbniNiphjwjfLW4Ahxy8IzFgjS1utjwK3wSl+QxfUya1sLePqGOTv/Div6NL39QxiFIj6R6YWb23zyzQPe/fgq1u2PCMy36O3q5+jAMNrLO4zTtTDFyaU5vJkG9x5c4ZNHO6xuNnl6Ns7uhEXTzRJ0UgTjOmomR2ZpifMX5ghVS7wdVGk/3k+HdwTNEoBjUZUuxY+mD3D58nm++e0tfvyzy9x9dIXKKR074sWNRAgl0/SFY3QEIuQbTT69sUEzY3Csa5D2wTE6RkIvAROGQVo05dT0JHXRGpVyiXwhT6lcpi7mLMcUwTQSpombyQpfkWZjgmazQUP0oW1bKIpCJBrFkUXRjQSteoXlxXkmJhrCJsiKjZJBGddFVVVMAWaIwI1agaXFBRrNJq3WNMVSGV3MR8QJooeAlkgzocVQY5H9KNIZFk2qSBORpUnARCJBVPjkWG6OxWL7a/fBYtH/AsrFMstsPi+OlRCgEWLCmUo6lIoF3FRyH9AUPjmXE32XMHQBoKDFY+QyLmXRo44t9EBWOZ0UxBZ3ZAtQU9fFIo2oqqHEDRTNFJVNkHCSIqjNaEQjLJg1qhj4w/q+jcUShDSDsYiBI7A8togYFrSK12vo4pJLzRqr02Wuz2f50akku3MWC6U051Zy3L9c4vNzZX6+nePhDzI82Mly7708e+tV9q4UxR1n8Sg5QeyZJsrGGZZufcDzX37A33bz/PWaw4stl39uRrnTNPjVVQHWSjPpM3n+03We/eUO3353k73VKSrdUf54o8D2ek5wWQAOzzYZW1ngs7tbvHg4xbdbXaxkIny05LI7n+JMyeTJVIMfBg3aUi38v3hC5/MXdP7+O9p+cp+eoQR/GC9wtVHCo4oj+ydr+OemuXF7lbs7FR6ue0XLWOTLltDAItFMisfVcf7dnGLzVIuJcot8NsV4piCavMX9ZoXvp6e4ILTRk8i6RIQcBScbnF5v8PXCCXbTHvKDx7Ebeex6nnjB5XG+wp9nV0kVGri+GE/OaOxVAliiQO/MnuZfU9NsZvOiDzNpokWXkVIOpVJgQNVp8wbo0w2MWo6IyE4R2TyzJ/giu8ZrXtEJ/T5O5SeZTGTx9viFaNT5u73IZlIe2bHxuQ6nNpdYXiqTruQYWT1HT89J9GqG+mIDv63zlfo+M+Y1Xh0y6TjWT/fbnfS0d9HRLoRhqMCe9TmX1BaeUU3HqjpcuzTLzpkCazmFybCXZHiIhh1ifk4otWjkRmmb18tXaItUOTKa4fU2L0feGuaNEZcjepO++k0m3UU8mmUybo/i6+0hPtDHjOFnJjZILuQj5PWijI3sMyXglDihZOiIpjlhFOgeMOgdTdFrlOlXXbrVHJorimIKjhbyOVZWlmm2WtREJav1STL5IorgqarGsASgJURgUjT/ypJ8U2rMzc0IqplElZDQgShqRCEprs9jCnFwTE3wNkdRSFO1WiGfyxGPq/tCED4UB0HNlKmTEz75TuuCplIgZFDlQCSS8pGSeqbGxYslMpVSJVVDmtwgyS6/h2ojeS7Hct2hZMl5S7wlmqYdype1v8gV2mccaJs0CSI1UfoPAaXJ7OTmQxmTIId799VGDuSP3Ci//2tyXgJLOxz/v7US6z9By8R0nCBqYQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png","srcSet":"/static/17ad8121ccf87c6ce98490d2626d88cd/eb5fe/07.png 750w,\n/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png 924w","sizes":"100vw"},"sources":[{"srcSet":"/static/17ad8121ccf87c6ce98490d2626d88cd/5c34d/07.webp 750w,\n/static/17ad8121ccf87c6ce98490d2626d88cd/6b2ec/07.webp 924w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":1.4004329004329006}}}},"body":"\n퍼블리싱 속도를 높이고 레이아웃을 잡는 연습을 하기 위해 2024.11.10부터 4주간 퍼블리싱\n스터디에 참여했다. 동일한 Figma 디자인 시안으로 퍼블리싱을 진행해 다른 스터디원의\n노하우를 엿볼 수 있었다. 스터디에 참여하면서 grid, flex를 더 적극적으로 활용할 수\n있게 되었고, 퍼블리싱 팁뿐만 아니라 디렉토리 구조에 대해서도 지식을 넓힐 수 있었다.\n\n## week01\n\n**TL;DR**\n\n- 이미지 사이즈를 주는 방법은 3가지로 있고, 적재적소에 알맞게 사용하는게 좋다.\n- scss도 module을 지원한다. 하지만 CSS-in-JS가 선호되는 이유를 알겠다.\n\n**Figma 디자인 시안**\n\n![image01](01.png)\n\n**scss**\n\n개인적으로 CSS로 처리할 수 있는 작업은 CSS를 사용하는 것을 선호해 SCSS로 스타일링을 시도해보았다. 하지만 SCSS에서는 변수를 사용하려면 스타일 파일에서 명시적으로 연결해주어야 하는 점이 불편했다. 반면 CSS-in-JS는 변수를 쉽게 받아와 사용할 수 있다는 점이 큰 장점으로 느껴졌다.\n\n```\n// /styles/variables.scss\n\n// breakpoint를 변수로 관리했다.\n$tablet-breakpoint: 767px;\n$pc-breakpoint: 1024px;\n```\n\n```\n// button.module.scss에서 정의한 변수를 사용하려면 @use를 한다.\n@use '/styles/variables.scss' as var;\n\n.foo {\n  @media (min-width: var.$tablet-breakpoint) {\n    // ...\n  }\n}\n```\n\n**이미지 사이즈는 어떤 방법으로 줄까?**\n\n이미지 사이즈를 조정하는 방법은 이렇게 3가지가 있다. 어떤 방식으로 이미지를 넣어줘야 하는지 애매모호해서 스터디원의 의견과 구글링을 통해 기준을 정리해보았다.\n\n1.  이미지 태그에 직접 `width`, `height` 값 주기\n2.  이미지 `width`는 100%로 하고 부모 요소를 통해 스타일 제어하기\n3.  요소의 `background-image`속성으로 `object-position` 값을 주기\n\n> 이미지에 직접 width, height 값 주기\n\n- 디자인이 정적으로 고정되는 요소 (예: 해당 Fimga의 프로필 이미지)\n- CLS를 방지하고 브라우저가 이미지 크기를 미리 알고 효율적으로 로드\n\n> 이미지 width는 100%로 하고 부모 요소에 의존하기\n\n- 컨테이너 레이아웃, 가변적으로 적용되는 요소 (예: 해당 Fimga의 카드 컴포넌트 썸네일)\n\n> 요소의 background-image속성으로 object-position 값을 주기\n\n- 꾸밈 이미지와 같이 내용에 영향을 주지 않는 요소\n- 렌더 트리 생성 단계 이후에 이미지를 요청해 우선순위가 낮음\n\n**상단 컨텐츠 레이아웃**\n\n![image02](02.png)\n\nPC, 태블릿, 모바일 화면에서 레이아웃이 달라지는 디자인이다. 이 영역은 공통되는 초록생 영역을 기준으로 잡았다.\n\n초록색 영역은 `flex-direction`을 `column` 으로 레이아웃을 잡았다. 모바일 화면에서는 버튼 컨테이너와 Active Users 위치를 각각 `absolute`로 했다.\n\n**카드 리스트 레이아웃**\n\n![image03](03.png) ![image04](04.png)\n\n`Featured NFTs`와 `Cretors` 의 카드 영역은 모두 grid 레이아웃을 적용했다.\n\n**새로 알게된 사실**\n\nscss에서 `&__` 를 사용하면 상위 클래스 네임을 상속받을 수 있어 BEM 규칙을 따를 수 있다.\n\n```\n\n// 이것은\n.text-box {\n  &__title {\n  }\n}\n\n// 이렇게 컴파일 된다.\n.text-box{\n}\n.text-box__title {\n}\n```\n\n**작업 결과**\n\n![05](./05.gif)\n\n## Week02\n\n**TL;DR**\n\n- `flex: 1 1 auto` 를 이해하고 사용했다.\n- grid 레이아웃을 사용하면, 최대한 많은 요소를 보여주는 레이아웃을 그릴 수 있다.\n\n**Figma 디자인 시안**\n\n![06](06.png)\n\n**emotion 사용**\n\n디자인 재사용성을 높여보도록 `emotion`를 사용했는데, 퍼블리싱에만 집중했다. ^^;\n\n**reset css**\n\n[https://www.joshwcomeau.com/css/custom-css-reset/](https://www.joshwcomeau.com/css/custom-css-reset/) 를 사용했다.\n\n그 중에, isolation 속성이 인상깊은데,\n\n```\n/* https://www.joshwcomeau.com/css/custom-css-reset/ */\n\n/*\n  9. Create a root stacking context\n*/\n#root, #__next {\n  isolation: isolate;\n}\n```\n\n> This is beneficial since it allows us to guarantee that certain high-priority elements (modals, dropdowns, tooltips) will always show up above the other elements in our application. No weird stacking context bugs, no z-index arms race.\n\n모달, 드롭다운, 툴팁이 항상 다른 요소들 위에 표시되도록 보장할 수 있다고 한다.\n\n**카드 레이아웃**\n\n![07](07.png)\n\n화면 해상도가 넓어지면 최대한 많은 카드를 보여주기 위해 `grid-template-columns` 속성을 사용하고 최소 카드 width를 `315px` 를 주었다.\n\n```\nconst CardLayout = styled.div`\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(315px, 1fr));\n  grid-gap: 20px;\n`;\n```\n\n**탭 레이아웃**\n\n![08](08.png)\n\n두 버튼의 width 간격을 같은 비율로 맞춰주기 위해 `flex: 1 1 auto;` 를 적용했다. (미루고 미뤄왔던,,, `flex: 1 1 auto`를 이해했다. 😆)\n\nButton을 width 100%로 둬도 동일한 효과를 줄 수 있다고 한다.\n\n```\nconst TabContainer = styled.div`\n  display:flx;\n`\nconst Button = styled.div`\n    width: 100%;\n`\n```\n\n**Collection 하위 아이템 레이아웃**\n\n![09](09.png)\n\n하위 아이템의 레이아웃은 최소 너비를 95px를 보장하고 균등하게 나누기 위해 `flex: 1 1 95px;` 을 사용했다.\n\n하위 아이템 개수가 모자른 경우에는 조건문으로 빈 element를 넣어줬는데, grid-template-columns를 이용해 같은 공간을 3개로 균등하게 나누면 스크립트롤 작성하지 않아도 된다!\n\n```\ndisplay: grid;\ngrid-template-columns: 1fr 1fr 1fr;\n```\n\n**작업 결과**\n\n![10](10.gif)\n\n## week03\n\n**TL;DR**\n\n- Grid로 공백있는 레이아웃 표현하기\n\n**Figma 디자인 시안**\n\n![11](11.png)\n\n**그리드 시스템으로 공백이 있는 레이아웃 표현하기**\n\n모바일에서는 컨텐츠가 일렬로 배치되어 있고 태블릿 이상부터는 두 열로 배치된다. flex를 사용하면 태블릿 이상부터는 표현하기 어려워진다. 그리드 시스템을 사용하면 일렬, 두 열 레이아웃을 간결하게 구현할 수 있다.\n\n![12](12.png) <br /> ![13](13.png) <br /> ![14](14.png)\n\n`grid-template-areas`를 사용하면 이름을 지정해 레이아웃을 배치할 수 있다. 각 그리드\n아이템은 `grid-area` 속성으로 이름을 지정할 수 있다.\n\n각 영역에 `grid-area` 로 적당한 이름으로 준 뒤, 컨테이너에 이렇게 하면 일렬로 배치할 수 있다.\n\n```\nconst ContentsContainer = styled.div`\n    grid-template-areas:\n    'title'\n    'endsIn'\n    'creator'\n    'description'\n    'details'\n    'tags';\n  // ...\n`;\n```\n\n![15](15.png)\n\n태블릿 크기 이상에서는 그리드 아이템을 두 열로 나누어 배치한다. endsIn 영역은 오른쪽 열에 위치시키고 title부터 description 영역까지 세로로 걸치게 했다. 나머지 영역은 '.'을 사용하여 공백 처리한다.\n\n```\nconst ContentsContainer = styled.div`\n  // ...\n\n  @media (min-width: 834px) {\n    grid-template-areas:\n      'title title endsIn'\n      'creator creator endsIn'\n      'description description endsIn'\n      'details details .'\n      'tags tags .';\n    // ...\n    }\n`;\n```\n\n`endsIn` 영역(타이머)이 `description`까지 늘어나게 되는데, 이는 해당 요소에 `height`를 지정하지 않아 왼쪽 컨텐츠의 높이값을 따라가기 때문이다. 이 문제를 해결하기 위해 `endsIn` 컨텐츠에 `min-content` 값을 적용하여 자신의 내용물 크기만큼만 높이를 가지도록 했다.\n\n![16](16.png)\n\n```\nconst EndsInBlock = styled.div`\n  height: min-content;\n  // ...\n `\n```\n\n아래는 전체 코드의 일부이다. 흥미로운 점은 마크업 순서와 관계없이 `grid-area`의 이름 속성만으로 요소 배치가 결정된다.\n\n```\n<ContentsContainer>\n  <Title />\n  <Creator />\n  <Description />\n  <Details />\n  <Tags />\n  <EndsIn />\n</ContentsContainer>\n\nconst ContentsContainer = styled.div`\n  gap: 20px;\n  padding: 40px 30px;\n  display: grid;\n  grid-template-areas:\n    'title'\n    'endsIn'\n    'creator'\n    'description'\n    'details'\n    'tags';\n\n  @media (min-width: 834px) {\n    padding: 40px 72px;\n    grid-template-columns: 1fr 295px;\n    grid-template-areas:\n      'title title endsIn'\n      'creator creator endsIn'\n      'description description endsIn'\n      'details details .'\n      'tags tags .';\n    column-gap: 30px;\n  }\n\n  @media (min-width: 1280px) {\n    padding: 40px 115px;\n    column-gap: 150px;\n  }\n`;\n```\n\n**작업 결과**\n\n![17](17.gif)\n\n### week04\n\n**TL;DR**\n\n- 레이아웃 흐름을 방해하지 않고 스타일 주기\n\n**Figma 디자인 시안**\n\n![18](18.png)\n\n**Form 레이아웃**\n\ngrid 레이아웃으로 모바일에서는 1열로 배치하고 태블릿 이상부터는 `grid-template-areas`로 2열로 배치하도록 했다.\n\n```\n<FormContainer>\n    <HeroBox />\n    <FormBox />\n</FormContainer>\n```\n\n```\nconst FormContainer = styled.div`\n  display: grid;\n  grid-template-columns: 1fr;\n\n  @media (min-width: 834px) {\n    grid-template-areas: 'hero form';\n    grid-template-columns: 1fr 1fr;\n  }\n`;\n\nconst HeroBox = styled.div`\n  // ...\n  grid-area: 'hero';\n`;\n\nconst FormBox = styled(FlexColumnBox)`\n  // ...\n  grid-area: 'form';\n `\n```\n\n**Input focus 스타일**\n\nInput border스타일은 레이아웃에 영향을 주지 않는 `box-shadow`속성을 사용하고 `<InputEle/>` 에 focus가 활성화 됐을 때, 부모 컴포넌트에 포커스 스타일을 주기위해서 네이티브 focus스타일을 주지않고`:focus-within` 를 사용했다.\n\n![19](19.png)\n\n<br />\n![20](20.png)\n\n```\n<InputContainer>\n  <InputWrapper>\n    <InputEle/>\n  </InputWrapper>\n  <ErrorMessage>\n</InputContainer>\n```\n\n```\nconst InputWrapper = styled(FlexRowBox)`\n  // ...\n  box-shadow: 0px 0px 0px 1px rgba(133, 133, 132, 1);\n  &:focus-within {\n    box-shadow: 0px 0px 0px 1.5px rgba(162, 89, 255, 1);\n  }\n`;\n\nconst InputEle = styled.input`\n  // ...\n  outline: none;\n`;\n```\n\n**에러 메세지 레이아웃**\n\n에러메세지가 보여지면서 레이아웃 영향을 주지않도록 `absolute`를 사용했다.\n\n![21](21.png)\n\n```\n<InputContainer>\n  <InputWrapper>\n    <InputEle/>\n  </InputWrapper>\n  <ErrorMessage>\n</InputContainer>\n```\n\n```\nconst InputContainer = styled.div`\n  position: relative;\n`;\n\nconst ErrorMessage = styled.span`\n  // ...\n  position: absolute;\n  margin-top: 1px;\n`;\n```\n\n**작업 결과**\n\n![22](22.gif)\n"},{"id":"6424f936-a130-507d-a274-404279f174eb","frontmatter":{"title":"Jest에선 성공인데... 브라우저에선 실패?","slug":"/Jest에선 성공인데 브라우저에선 실패","date":"2024-10-24","tags":null,"thumbnail":null},"body":"\nimport hashtagGif from './해시태그입력.gif';\n\n프로젝트에서 한글 입력 시 마지막 글자가 지워지지 않는 IME 버그를 겪었습니다. “유닛 테스트에서 잡을 수 있었다면 좋았을 텐데…” 싶어 앞으로는 TDD도 해보자는 마음으로 Jest로 폼 테스트를 학습해봤습니다.\n그런데 예상과 달리 Jest에선 이 문제가 드러나지 않고 테스트가 성공했습니다.\n\n이번 글은 그 과정에서 배운 Jest 디바운스 테스트와 API 모킹 경험, 그리고 브라우저 환경에서의 E2E 테스트가 필요한 이유를 정리한 글입니다.\n\n## 테스트할 기능\n\n테스트할 기능은 입력 후 API 호출로 메타데이터를 불러오는 기능입니다.\n\n![링크미리보기.gif](./링크미리보기.gif)\n\n1. 사용자가 링크를 입력한다.\n2. 해당 링크로 API 요청을 보내 메타데이터를 가져온다.\n3. 결과를 화면에 표시한다.\n\n여기서 입력이 변경될 때마다 불필요한 API 요청이 발생하지 않도록 `2000ms` 디바운스를 적용했습니다.\n\n### 디바운스 모방하기\n\n```jsx\nconst urlInput = screen.getByLabelText('링크');\n\nfireEvent.change(urlInput, { target: { value: 'https://www.naver.com/' } });\nawait act(async () => {\n  jest.advanceTimersByTime(2000); // 디바운스 적용\n});\n```\n\n- `jest.advanceTimersByTime(ms)` : 지정한 ms만큼 시간이 흐른 것처럼 시뮬레이션\n\n테스트 후에는 타이머를 초기화해줍니다.\n\n```jsx\nafterEach(() => {\n  jest.clearAllTimers();\n  jest.useRealTimers();\n});\n```\n\n### API 요청 mocking하기\n\n실제 API 호출을 막기 위해 msw로 응답을 모킹했습니다.\n\n```jsx\nconst handlers = [\n  rest.get(`${API_BASE_URL}/link/metadata`, (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json({\n        metaDescription: '링크 설명',\n        metaThumbnail: '링크 썸네일',\n        metaTitle: '링크 타이틀',\n        titleText: '타이틀 텍스트',\n      })\n    );\n  }),\n];\n```\n\n### 해시태그 입력 테스트하기\n\n엔터 키 입력 시 해시태그가 추가되도록 구현했습니다. 아래 이미지처럼 현재 한글로 해시태그를 입력하는 경우에는 마지막 글자인 ‘녕’이 input에 남아있는 문제가 있습니다.\n\n<img src={hashtagGif} alt=\"해시태그 입력\" style={{ width: '100%' }} />\n\n문제 시나리오에 대해서 테스트 코드를 작성했습니다.\n\n```jsx\ndescribe('해시 태그 입력 테스트', () => {\n  test ('여러 개의 해시 태그를 입력하면, 입력한 해시 태그의 수만큼 Chip 컴포넌트가 렌더링된다.',\n  // 해시태그 추가\n  fireEvent.change(tagInput, { target: { value: '안녕' } });\n  fireEvent.keyDown(tagInput, { key: 'Enter' });\n  // input value가 빈값이어야 함\n  expect(tagInput.value).toBe(''):\n\n\n  // 연달아 새로운 해시태그 추가\n  fireEvent.change(tagInput, { target: { value: '하이' } });\n  fireEvent.keyDown(tagInput, { key: 'Enter' });\n  // input value가 빈값이어야 함\n  expect (tagInput.value).toBe('');\n  // ...\n```\n\n하지만 테스트 결과는 실패하지 않고, 성공하고 말았습니다... ![양성거짓](양성거짓.png)\n\n## Jest에서는 왜 성공할까?\n\n한글이 input에 여전히 남는 원인은 IME 입니다. `ㅇ ㅑ ㅎ ㅗ` 를 순서대로 입력하면 자음과 모음을 조합해 `야호` 를 출력합니다. 브라우저에서는 이 조합 과정을 `compositionstart`, `compositionend`같은 이벤트가 발생합니다. 하지만, Jest는 `야호’라는 value의 값을 넣었을 때, 이미 조합이 완료된 값을 넣으므로 마지막 글자가 남지 않아 해당 버그는 재현되지 않습니다.\n\n## 브라우저 E2E 테스트 필요성\n\nJest만으론 브라우저가 가진 특징을 재현하기 어려운걸 깨달았습니다. 이를 보완할 수 있는 Cypress나 Playwright와 같은 E2E 도구의 필요성을 느꼈습니다.\n\n---\n\n참고\n\n- [https://ko.wikipedia.org/wiki/입력기](https://ko.wikipedia.org/wiki/%EC%9E%85%EB%A0%A5%EA%B8%B0)\n- [https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionstart_event](https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionstart_event)\n- [https://ui.toast.com/posts/ko_20220624](https://ui.toast.com/posts/ko_20220624)\n- [https://minjung-jeon.github.io/IME-keyCode-229-issue/](https://minjung-jeon.github.io/IME-keyCode-229-issue/)\n"},{"id":"4253f32f-690c-5d73-b285-f1cf87c157ec","frontmatter":{"title":"[type-challenges] medium 도전","slug":"/type-challenges/medium","date":"2024-10-17","tags":null,"thumbnail":null},"body":"\n## **Get Return Type**\n\n### 문제\n\n내장 제네릭 `ReturnType<T>`을 이를 사용하지 않고 구현하자\n\n### 코드\n\n```\n// 아쉬운 정답\ntype MyReturnType<T extends (...args: any) => unknown> =\n  T extends (...args:any) => infer U\n      ? U\n      : never;\n```\n\n함수 인자 타입을 `never[]` 로 하면 모든 테스트 케이스가 통과된다.\n\n```\n// 정답\ntype MyReturnType<T extends (...args: never[]) => unknown> =\n  T extends (...args: never[]) => infer R\n    ? R\n    : never\n```\n\n### 해설\n\n리턴되는 타입을 `infer U`로 추론하고 U를 반환한다. 하지만 함수 인수를 받는 타입을 `unknown[]` 으로 하면 테스트 케이스가 일부만 통과해서 `any`로 변경해 모두 통과되도록 했다.\n\n**`unknown[]`이 안되는 이유**\n\n`unknown` 은 모든 타입의 상위 타입이므로 모든 타입은 `unknown`에 할당할 수 있다. 그렇기 때문에 `unknown` 은 가장 일반적인 타입이기 때문에 구체적인 타입과 호환되지 않는다.\n\n```\ntype foo = unknown extends string ? true : false; // false\n```\n\n**`never[]` 를 사용하는 이유**\n\nnever는 존재하지 않는 공집합이기 때문에 any를 포함해 어떤 값도 가질 수 없는 가장 구체적인 타입이어서 다른 타입들과 호환될 수 있다.\n\n```\ntype foo = never extends string ? true : false; // true\n```\n\n## **Omit**\n\n### 문제\n\n`T`에서 `K` 프로퍼티만 제거해 새로운 오브젝트 타입을 만드는 내장 제네릭 `Omit<T, K>`를 이를 사용하지 않고 구현하자.\n\n### 코드\n\nT의 프로퍼티 키에서 K가 아니라면 키값을 추출하는 코드를 의도했다. 이 코드는 infer의 잘못된 사용으로 동작하지 않는다.\n\n```\n// 오답\ntype MyOmit<T, K extends keyof T> = K extends infer Key keyof T ?\n  never :\n  { Key: T[Key] }\n```\n\n정답 코드는 이렇다.\n\n```\n// 정답\ntype MyOmit<T, K extends keyof T> = {[Key in keyof T as Key extends K ? never: Key]: T[Key]}\n```\n\n### 해설\n\n**`as` 키워드**\n\nas 키용해 이용해 맵드 타입의 키를 다시 매핑할 수 있다. 예를들어 모든 프로퍼티 키를 Hamster라고 키 이름을 다시 매핑할 수 있다.\n\n```\ntype MappedTypeWithNewProperties<Type> = {\n    [Properties in keyof Type as 'Hamster']: Type[Properties]\n}\n```\n\n## **Readonly 2**\n\n### 문제\n\n`T`에서 `K` 프로퍼티만 읽기 전용으로 설정해 새로운 오브젝트 타입을 만드는 제네릭 `MyReadonly2<T, K>`를 구현하세요. `K`가 주어지지 않으면 단순히 `Readonly<T>`처럼 모든 프로퍼티를 읽기 전용으로 설정해야 합니다.\n\n### 코드\n\n```\ntype MyReadonly2<T, K extends keyof T = keyof T> = { readonly [k in K]: T[k] } & Omit<T, K>;\n```\n\n### 해설\n\nK 프로퍼티는 readonly 속성을 부여하면 된다. 구현은 정답을 참고했다.\n\nK가 주어지지 않는 경우를 위해 `K extends keyof T = keyof T` default 값을 설정한다.\n\n**교차 타입 &**\n\n두 개 이상의 타입을 결합해 모든 타입의 속성을 포함하는 새로운 타입을 생성할 수 있다. `A & B`는 `A`와 `B`의 모든 속성을 포함하는 새로운 타입이 된다.\n\n**유니온 타입 |**\n\n두 개 이상의 타입 중 하나를 선택할 수 있는 새로운 타입을 생성한다. `A | B` 는 `A`또는 `B` 중 하나의 타입을 가질 수 있다.\n\n## **Deep Readonly**\n\n### 문제\n\n객체의 프로퍼티와 모든 하위 객체를 재귀적으로 읽기 전용으로 설정하는 제네릭 `DeepReadonly<T>`를 구현하세요.\n\n이 챌린지에서는 타입 파라미터 `T`를 객체 타입으로 제한하고 있습니다. 객체뿐만 아니라 배열, 함수, 클래스 등 가능한 다양한 형태의 타입 파라미터를 사용하도록 도전해 보세요.\n\n### 코드\n\n중첩된 객체 프로퍼티의 타입을 반환하는 타입은 만들었는데 다음은 어떻게 해야할까?\n\n```\n// 오답\ntype DeepReadonly<T> = T extends object ? DeepReadonly<T[keyof T]> : T\n```\n\n정답을 참고해서 `readonly` 타입을 반환하도록 했는데, 중첩된 객체에서는 `readonly`가 안된다. (아래 코드가 왜 잘못됐는지 모르겠다🥲 )\n\n```\n// 오답\ntype DeepReadonly<T> = T extends Record<PropertyKey, unknown> ?\n  { readonly [P in keyof T]: DeepReadonly<T[P]> }\n  :\n  T;\n\ntype x = DeepReadonly<{l: [\n        'hi',\n        {\n          m: ['hey']\n        },\n      ]}>;\n\n// 결과\n// type x = {\n//  readonly l: [\"hi\", {\n//      m: [\"hey\"];\n//    }];\n//  }\n\n// 기댓값\n// type x = {\n//  readonly l: readonly [\"hi\", {\n//      readonly m: readonly [\"hey\"];\n//    }];\n//  }\n```\n\n정답 코드를 보면 `T`에 프로퍼티 키로 접근할 수 있는 값이 없다면 T\\[K\\]를 반환하고 그렇지 않다면 재귀적으로 `DeepReadonly<T[K]>` 를 호출한다.\n\n```\n// 정답\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: keyof T[K] extends never ? T[K] : DeepReadonly<T[K]>\n}\n```\n\n### 해설\n\n**TypeScript 에서 `{}` vs `Object` vs `object`**\n\n- `{}` 는 빈 객체가 아닌 any non-nullsih value이므로 `undefined`, `null`을 제외한 모든 타입을 할당할 수 있다.\n- `Object` 도 `{}` 와 동일하다.\n- `object` 는 원시값을 제외한 모든 값이 할당 가능하다.\n\n빈 객체`{}` 타입만을 허용하고 싶다면 `never`를 사용하자. 자바스크립트의 객체 타입(중괄호로 이루어진 객체)만을 허용하고 싶다면 Record를 사용하면 된다.\n\n![mind](mind.jpeg)_타입스크립트는 어렵네요_\n\n## 문제 풀기에 앞서…\n\n문제 풀기에 앞서 아직 헷갈리는 내용을 짚고 넘어가보자.\n\n**정적 타입 검사:**\n\n타입스크립트는 프로그램을 실행시키지 않고 오류를 검출한다.\n\n**점진적 타입 시스템:**\n\n타입스크립트는 타입 검사를 점진적으로 적용해 동적 타입처럼 자유롭게 타입을 작성할 수 있다.\n\n```\nlet a = 10;  // 타입스크립트가 자동으로 number로 추론 (자동 타입 추론)\nlet b;       // 타입 명시가 없으므로 b는 암시적으로 any 타입을 가짐\nb = \"hello\"; // b에 어떤 값이든 할당 가능 (any 타입)\nb = 42;      // any 타입이기 때문에 타입 오류 없음\n```\n\n**구조적 타입 시스템이란:**\n\n타입스크립트 컴파일러는 두 타입의 명시적 선언이 아닌 **프로퍼티를 비교**하여 타입을 비교한다. 그러니까 타입 `Hamster`과 `Animal`이 있을 때, `Hamster` ⊂ `Animal`를 만족한다. `Hamster`의 프로퍼티는 `Animal`를 만족시키기 때문에 `Hamster`타입에 `Animal`을 할당할 수 있고 `Hamster`은 `Animal`타입과 호환이 가능하다.\n\n**Indexed Access Type:**\n\n인덱스를 사용해 객체의 프로퍼티 타입을 추출할 수 있다. 배열 요소의 타입을 가져오려면 `Foo[number]` 로 하면 된다.\n\n**infer:**\n\n조건부 타입의 `extends` 절 안에서 infer을 이용해 타입 변수를 추론할 수 있다. 이렇게 추론된 타입은 분기에서 참조될 수 있다.\n\n## **Tuple to Union**\n\n> 튜플 값으로 유니온 타입을 생성하는 제네릭 `TupleToUnion<T>`를 구현하세요.\n\n배열의 인덱스를 number로 접근해서 타입을 가져오면 된다.\n\n```\ntype TupleToUnion<T extends unknown[]> = T[number];\n```\n\n## **Chainable Options**\n\n> 체인 가능 옵션은 일반적으로 Javascript에서 사용됩니다. 하지만 TypeScript로 전환하면 제대로 구현할 수 있나요?\n>\n> 이 챌린지에서는 `option(key, value)`과 `get()` 두가지 함수를 제공하는 객체(또는 클래스) 타입을 구현해야 합니다. 현재 타입을 `option`으로 지정된 키와 값으로 확장할 수 있고 `get`으로 최종 결과를 가져올 수 있어야 합니다.\n\n너무 어려워서 정답을 봤다. R 타입은 option 메서드로 점진적으로 타입이 확장된다.\n\n```\ntype Chainable<T = object> = {\n  option<K extends PropertyKey, V>(\n    key: K extends keyof T\n         ? (V extends T[K] ? never : K)\n         : K,\n    value: V\n  ): Chainable<Omit<T, K> & Record<K, V>>; // Omit K from T\n  get(): T;\n}\n```\n\n### declare\n\n문제에서 a를 declare로 선언했는데, declare에 대해 알아보자.\n\n```\ndeclare const a: Chainable\n```\n\ndeclare는 타입이나 값을 설명하기 위해 사용할 수 있다. 변수, 객체, 함수 또는 외부 모듈 등에서 타입 정보를 제공하는 용도로 사용할 수 있다. declare 키워드로 선언된 변수는 javascript로 컴파일되지 않는다.\n\n## **Last of Array**\n\n> 배열 T를 사용하고 마지막 요소를 반환하는 제네릭 `Last<T>`를 구현합니다.\n\n`T[length - 1]` 식으로 접근하고 싶은데, 타입스크립트는 런타입 값을 알 수 없기 때문에 계산이 안된다.\n\n정답 코드에서는 새로운 배열을 만들고, 이 배열의 `T['length']` 를 접근한다.\n\n```\ntype Last<T extends unknown[]> = [unknown, ...T][T[\"length\"]]\n```\n\n## **Pop**\n\n> 배열 T를 사용해 마지막 요소를 제외한 배열을 반환하는 제네릭 `Pop<T>`를 구현합니다.\n\ninfer로 추론하고 P를 반환하면 된다.\n\n```\ntype Pop<T extends unknown[]> = T extends [...infer P, unknown] ? P : [];\n```\n\n### Shift, Push, Unshift 구현하기\n\n```\ntype Shift<T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push<T extends unknown[], X> = [...T, X];\n\ntype Unshift<T extends unknown[], X> = [X, ...T];\n```\n\n## **Promise.all**\n\n> Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array.\n\n09번은 너무 어려워서 패스하고 다음에 도전해본다!\n\n## **Type Lookup**\n\n> 때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다.\n>\n> 이 챌린지에서는 유니온 타입 `Cat | Dog`에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 `LookUp<Cat | Dog, 'dog'>`으로 Dog 타입을,` LookUp<Cat | Dog, 'cat'>`으로 `Cat` 타입을 얻을 수 있습니다.\n\n```\ntype LookUp<U, T> = U extends { type: T } ? U : never;\n```\n\n### Shift, Push, Unshift 구현하기\n\n```\ntype Shift<T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push<T extends unknown[], X> = [...T, X];\n\ntype Unshift<T extends unknown[], X> = [X, ...T];\n```\n\n## **Promise.all**\n\n> Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array.\n\n09번은 너무 어려워서 패스하고 다음에 도전해본다!\n\n## **Type Lookup**\n\n> 때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다.\n>\n> 이 챌린지에서는 유니온 타입 `Cat | Dog`에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 `LookUp<Cat | Dog, 'dog'>`으로 Dog 타입을, `LookUp<Cat | Dog, 'cat'>`으로 Cat 타입을 얻을 수 있습니다.\n\n```\ntype LookUp<U, T> = U extends { type: T } ? U : never;\n```\n\n## **Trim Left**\n\n> 정확한 문자열 타입이고 시작 부분의 공백이 제거된 새 문자열을 반환하는 TrimLeft를 구현하십시오.\n\n빈 공백을 제거하고 재귀적으로 trim을 하려고 했는데 U는 string이 아니라 배열 타입이 되므로 오답이다.\n\n```\ntype TrimLeft<S extends string> = S[number] extends [' ', ...infer U] ?  TrimLeft<U> : S;\n```\n\n리터럴을 이용해 처리할 수 있다.\n\n```\ntype Space = ' ' | '\\t' | '\\n';\ntype TrimLeft<S extends string> = S extends `${Space}${infer U}` ?  TrimLeft<U> : S;\n```\n\n## **Trim**\n\n> 정확한 문자열 타입이고 양쪽 끝의 공백이 제거된 새 문자열을 반환하는 Trim를 구현하십시오.\n\nTrimLeft 코드에서 분기 처리를 추가하면 된다.\n\n```\ntype Space = ' ' | '\\t' | '\\n';\n\ntype Trim<S extends string> = S extends `${Space}${infer U}`\n  ? Trim<U>\n  : S extends `${infer T}${Space}`\n  ? Trim<T>\n  : S;\n```\n\n유니언으로 처리하면 더 깔끔하게 처리할 수 있다.\n\n```\ntype Space = ' ' | '\\t' | '\\n';\n\ntype Trim<S extends string> = S extends `${Space}${infer T}` | `${infer T}${Space}` ? Trim<T> : S;\n```\n\n## **Capitalize**\n\n> 문자열의 첫 글자만 대문자로 바꾸고 나머지는 그대로 놔두는 Capitalize를 구현하세요.\n\nCapitalize 인터페이스를 사용하면 된다.\n\n```\ntype MyCapitalize<S extends string> = S extends `${infer X}${infer T}` ? `${Capitalize<X>}${T}` : S;\n```\n\n**Replace**\n\n> 문자열 S에서 From를 찾아 한 번만 To로 교체하는 `Replace<S, From, To>`를 구현하세요.\n\n리터럴 타입을 이용해 조건부로 넘겼지만, From이 `''` 케이스인 경우 통과하지 않는다.\n\n```\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string\n> = S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;\n```\n\nFrom이 공백 문자열인지 확인하는 분기를 추가하면 된다.\n\n```\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends ''\n  ? S\n  : S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;\n```\n\n## **ReplaceAll**\n\n> 주어진 문자열 S에서 부분 문자열 From을 찾아 모두 To로 교체하는 제네릭 `ReplaceAll<S, From, To>`을 구현하세요.\n\nReplace 코드에 재귀적으로 타입을 호출했는데, 이미 교체한 문자열에도 교체를 진행해 `foobarfoobar` 테스트 케이스를 통과하지 못한다.\n\n```\ntype ReplaceAll<\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends ''\n  ? S\n  : S extends `${infer T}${From}${infer X}`\n  ? ReplaceAll<`${T}${To}${X}`, From, To>\n  : S extends `${From}${infer T}`\n  ? ReplaceAll<`${To}${T}`, From, To>\n  : S;\n```\n\n리터럴 타입 내부에서 ReplaceAll 타입을 재귀적으로 호출하면 된다.\n\n```\ntype ReplaceAll<S extends string, From extends string, To extends string> = From extends ''\n  ? S\n  : S extends `${infer R1}${From}${infer R2}`\n  ? `${R1}${To}${ReplaceAll<R2, From, To>}`\n  : S\n```\n\n## **Append Argument**\n\n> 함수 타입 Fn과 어떤 타입 A가 주어질 때 Fn의 인수와 A를 마지막 인수로 받는 Fn과 동일한 함수 유형인 G를 생성하세요.\n\nFn의 인자 타입을 추론하고 A를 추가하고자 아래처럼 작성했는데, 문법상에 오류가 있다.\n\n```\ntype AppendArgument<Fn extends (...args: any[]) => unknown, A> = Fn extends (...X: any[]) => unknown ? (...X, A) => unknown : false;\n```\n\narguments를 올바르게 타입을 추론하면 된다.\n\n```\ntype AppendArgument<Fn, A> = Fn extends (...args: infer T) => infer U ? (...arg: [...T, A]) => U : never;\n```\n\n**arguments 객체**\n\narguments 객체는 함수에 전달된 인수에 해당하는 Array 형태의 객체이다.\n\n```\nfunction foo(a, b, c){\n    console.log(arguments[0] === a);\n    console.log(arguments[1] === b);\n    console.log(arguments[2] === c);\n}\n```\n\n---\n\n타입 챌린지는 임시 중단합니다.\n\n다양한 타입을 만드는건 재미있지만 자주 쓰이는 케이스로 타입스크립트를 학습하겠습니다~\n"},{"id":"fcaa218a-3740-5fb5-872b-4ca73addb772","frontmatter":{"title":"[type-challenges] easy 도전","slug":"/type-challenges/easy","date":"2024-10-11","tags":null,"thumbnail":null},"body":"\n## PICK-4\n\n### 문제\n\npick을 사용하지 않고 Pick을 구현하는 문제이다.\n\n- `keyof` 는 객체의 키 값들을 숫자나 문자열 리터럴 유니언을 생성한다.\n- `in` 는 객체에 특정 속성이 존재하는지 확인할 수 있다.\n\n### 코드\n\n```\ntype MyPick<T, K extends keyof T> = {\n  [k in K]: T[k]\n}\n```\n\n### 풀이\n\n`K extends keyof T` K는 T의 프로퍼티 이름을 가진다. 매핑된 타입을 이용하면 키를 통해 타입을 반복적으로 생성할 수 있고 인덱스 시그니처 문법으로 작성하면 된다.\n\n## Readonly\n\n### 문제\n\nReadonly 타입을 사용하지 않고 구현하는 문제이다.\n\n- `readonly` 는 프로퍼티를 읽기 전용으로 지정할 수 있다.\n\n### 코드\n\n```\ntype MyReadonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n```\n\n## **Tuple to Object**\n\n### 문제\n\n각 원소의 값을 key/value로 갖는 오브젝트 타입을 반환하는 타입을 구현하는 문제이다.\n\n```\n// 배열의 원소의 값을 key/value로 갖는 타입을 반환한다.\n['tesla', 'model 3', 'model X', 'model Y']\n\n{ 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}\n```\n\n### 코드\n\n```\ntype TupleToObject<T extends readonly PropertyKey[]> = {\n  [P in T[number]] : P\n}\n```\n\n### 풀이\n\n- 배열 순회하기: `T[number]`을 통해 배열을 순회하여 타입을 가져올 수 있다. `T[number]` 은 인덱스가 숫자형인 요소들의 타입을 가져오므로 배열에 있는 모든 요소의 타입을 가져올 수 있다.\n- PropertyKey: `keyof` 를 통해 생성되는 key의 집합이다. 여기에는 string, number, symbol이 있다.\n\n## **First of Array**\n\n### 문제\n\n`T`를 받아 첫번째 원소의 타입을 반환하는 제네릭 `First<T>`를 구현하는 문제이다.\n\n### 코드\n\n```\n// 오답: 빈 배열인 경우 T[0]은 undefeind가 된다\ntype First<T extends any[]> = T[0] extends never ? never : T[0]; // 원소가 없다면 never 타입 반환\n\n// 정답1\ntype First<T extends unknown[]> = T[number] extends never ? never : T[0];\n// 정답2\ntype First<T extends unknown[]> = T extends [] ? never : T[0];\n```\n\n### 풀이\n\n- 조건부 타입: 배열이 빈 배열이라면 `never` 타입을 반환한다.\n\n## **Length of Tuple**\n\n### 문제\n\n튜블(배열)의 길이를 반환하는 제네릭 타입을 구현하는 문제이다.\n\n### 코드\n\n```\n// 오답: Length<5>인 경우 타입 에러가 나지 않는다.\ntype Length<T> = T extends readonly unknown[] ? T['length'] : never;\n```\n\n`<T extends readonly unknown[]>` 는 T가 `readonly unknown[ ]`이라는 타입을 반드시 만족해야 하므로 배열이 아닌 경우 타입 에러를 발생한다.\n\n```\n// 정답\ntype Length<T extends readonly unknown[]> = T[\"length\"];\n```\n\n### 풀이\n\n- `readonly`: 튜플은 고정된 요소를 저장하므로 readonly이다.\n\n`T extends readonly unknown[]` 에서 T가 배열 타입인지 조건부로 타입을 할당한다. 이런 경우 배열이 아닌 경우 `never`를 반환하기 때문에 타입 에러가 나지 않는다.\n\n## **Exclude**\n\n### 문제\n\nT에서 U에 할당할 수 있는 타입을 제외하는 내장 제네릭 Exclude를 사용하지 않고 구현하는 문제이다.\n\n### 코드\n\n```\ntype MyExclude<T, U> = T extends U ? never : T;\n```\n\n### 풀이\n\n- `Exclude`: `Exclude<T, U>` 는 U에 할당할 수 있는 타입을 제외한다. 차집합으로 이해할 수 있다.\n- 분배법칙: 조건부 타입에서 분배법칙이 적용된다. 예를 들어 `A | B | C extends U ? X : Y` 는 `A extends U ? X : Y`, `B extends U ? X : Y`, `C extends U ? X : Y` 가 된다. `T extends U ? X : Y` 에서 T 유니언 타입은 개별 구성 요소를 확인한다.\n\nT가 U에 속한다면, never를 반환한다.\n\n## **Awaited**\n\n### 문제\n\nPromise와 같은 타입에 감싸인 타입이 있을 때, 안에 감싸인 타입이 무엇인지 가르키는 타입을 구현하는 문제이다.\n\n### 코드\n\n```\ntype MyAwaited<T> = T extends PromiseLike<infer D> ? MyAwaited<D> : T;\n```\n\n### 풀이\n\nPromise에 감싸진 리턴 타입을 반환하기 위해 T가 Promise라면 Promise를 재귀적으로 풀어주고 그렇지 않다면 T를 반환하면 된다.\n\n예를 들어 타입 `X`에서 Promise로 감싸진 타입을 가져올 때 다음처럼 동작한다.\n\n```\ntype MyAwaited<T> = T extends PromiseLike<infer D> ? MyAwaited<D> : T;\n\ntype X = Promise<string>\ntype Foo = MyAwaited<X> // string\n```\n\n`MyAwaited<Promise<string>>`은 `PromiseLike<infer D>`타입에 해당하므로 다시 `MyAwaited<D>` 을 호출한다. 여기서 `infer D` 로 string을 추론한다. `MyAwaited<string>` 은 `PromiseLike`타입이 아니므로 타입 `string`을 반환한다.\n\n### `infer`란?\n\n조건부 타입에서 `infer` 키워드를 이용해 새로운 타입 변수를 선언적으로 정의할 수 있다. `type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;`\n\n### `Promise`가 아닌 `PromiseLike`를 사용하는 이유\n\n`Promise`가 아닌 `PromiseLike`를 사용하는 이유는 아래 테스트 케이스가 존재하기 때문이다.\n\n```\ntype T = { then: (onfulfilled: (arg: number) => any) => any }\n```\n\n`PromiseLike`타입에는 후속처리 메서드인 then만 가지고 있다. 이를 통해 커스텀 비동기 처리를 유연하게 정의할 수 있다.\n\n```\n// https://github.com/microsoft/TypeScript/blob/main/src/lib/es5.d.ts\n\ninterface PromiseLike<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n      ): PromiseLike<TResult1 | TResult2>;\n}\n```\n\n## **If**\n\n### 문제\n\n조건 C가 참이면 A, 아니면 B를 반환하는 타입을 구현하자.\n\n### 코드\n\n```\ntype If<C extends boolean, T, F> = C extends true ? T : F;\n```\n\n### 풀이\n\nC는 true, false만 가능하도록 `boolean` 타입으로 제한하고 C 조건에 따라 T, F를 리턴하면 된다.\n\n## Concat\n\n### 문제\n\nArray.concat 함수를 타입 시스템에서 구현하자. 인수를 왼쪽부터 concat한 새로운 배열을 반환하자.\n\n### 코드\n\n```\n// 오답\ntype Concat<T extends unknown[], U extends unknown[]> = [\n  T extends [] ? never : T[number],\n  U extends [] ? never : U[number]\n];\n\ntype Foo = Concat<['1', 2, 3], []>; // [2 | 3 | \"1\", never]\n```\n\n```\n// 정답\ntype Tuple = readonly unknown[];\ntype Concat<T extends Tuple, U extends Tuple> = [...T, ...U];\n\ntype Foo = Concat<['1', 2, 3], []>; //  [\"1\", 2, 3]\n```\n\n### 풀이\n\nT와 U를 concat할 수 있도록 T와 U를 배열로 타입을 제한했다. 요소의 타입으로 이루어진 튜플을 반환할 수 있도록 `T[number]` 를 했다. 그러나 `T[number]`는 배열의 요소 타입으로 이뤄진 유니언 타입을 추출한다. 그리고 빈 배열인 경우 never 타입이 반환되므로 오답이다.\n\n여기서 T와 U를 배열타입으로 제한했으므로 열거 가능하다.\n\n## **Includes**\n\n### 문제\n\nJavaScript의 `Array.includes` 함수를 타입 시스템에서 구현하세요. 타입은 두 인수를 받고, `true` 또는 `false`를 반환하자.\n\n### 코드\n\n```\n// 오답\ntype Includes<T extends readonly unknown[], U> = U extends T[number] ? true : false;\n```\n\nT 배열의 요소를 키로 갖는 타입을 만들고 U가 T의 키인지 확인하면 해결할 수 있을 것 같지만, U가 프로퍼티 키로 사용할 수 있을 때만 통과된다. ([참고](https://github.com/type-challenges/type-challenges/issues/1568))\n\n```\n// 오답\ntype Includes<T extends readonly any[], U> = {\n  [P in T[number]]: true\n}[U] extends true ? true : false;\n```\n\n이를 해결하기 위해 배열의 첫번째 요소와 타입이 같은지 재귀적으로 타입을 확인해야 한다.\n\n```\n// 정답\ntype Includes<T extends readonly unknown[], U> =\n  T extends [infer First, ...infer Rest]\n    ? Equal<First, U> extends true ? true : Includes<Rest, U>\n    : false;\n```\n\n### 풀이\n\nU가 T의 구성 요소인지 확인하기 위해 T를 인덱스 접근 타입으로 변경하고 U가 이 유니온 타입에 속하는지 조건부로 true 또는 false를 반환한다. 그런데 이 코드는 primitive type만 통과하고 객체나 타입 자체는 통과하지 않는다. 예를 들어 `{ a: 'A'}` 는 `{ }`의 서브 타입으로 true를 반환한다.\n\n> `infer` 키워드를 복습하고 가자. `infer`은 조건부 타입에서 **참으로 평가**될 때 사용할 수 있는 타입을 추론하는 데 사용한다.\n\n참고로 `@type-challenges/utils` 의 Equal은 아래처럼 구현되어 있다.\n\n```\nEqual<X, Y> =\n    (<T>() => T extends X ? 1 : 2) extends\n    (<T>() => T extends Y ? 1 : 2) ? true : false;\n```\n\n## **Push**\n\n### 문제\n\n`Array.push`의 제네릭 버전을 구현하자.\n\n### 코드\n\n```\ntype Push<T extends unknown[], U> = [...T, U];\n```\n\n### 풀이\n\nT를 배열로 타입을 제한하고 배열 디스트럭쳐링을 이용해 배열 타입을 반환한다.\n\n## **Unshift**\n\n### 문제\n\n`Array.unshift`의 타입 버전을 구현하자.\n\n### 코드\n\n```\ntype Unshift<T extends unknown[], U> = [U, ...T];\n```\n\n### 풀이\n\nPush 문제와 동일하다. T와 U 순서만 바꿔주면 된다.\n\n## **Parameters**\n\n### 문제\n\n내장 제네릭 `Parameters<T>`를 이를 사용하지 않고 구현하자.\n\n### 코드\n\n```\ntype MyParameters<T> = T extends (...args: infer D) => unknown ? D : any;\n\nconst temp = ['1'];\ntype x = MyParameters<typeof temp>; // 타입 에러가 나지 않는다.\n```\n\n타입 에러가 나지 않는데, 이를 막으려면 타입 T를 함수로 제한하면 된다.\n\n```\ntype MyParameters<T extends (...args: any[]) => any> = T extends (...any: infer S) => any ? S : any\n```\n\n### 풀이\n\n조건부 타입으로 함수 타입이라면 args를 추론한 D 타입을 반환한다. 하지만 T타입이 함수로 제한하지 않아 함수가 아닌 타입에서 에러가 나지 않아서 아쉽다.\n"},{"id":"58931655-f87a-5a8f-9881-6a2b3a68fe83","frontmatter":{"title":"드래그 이벤트 구현기2 - 왜 transform은 더 빠를까","slug":"/드래그 이벤트 구현기2 - 왜 transform은 더 빠를까","date":"2024-06-16","tags":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACCUlEQVR42pWS7U/aUBTGmyWLyYw6N1/m5jKHlrb2DVqhRbsUBKS0tMXotoyhKIKa7NP+/w+/XbqXZB/98Mtzz33Oc3KSe6WTJOJYcDKICeM+n6KIVhLTyQaE/b4gKrSVDmgNM9p5TitPOc0zwYBAZE4WdJucXj8idW5GtCcjzqZXpNMJ6e2EbHpDPrslu7slv5uKeko6m5HeP5DO52TzB+HPBHPh35ELfyhmDH/8RKrUQhyviaL7yLpH2fQKNa2AklorUG0f3W5gWD6G7Ql8zOLOL/w9pca7fQej4iNtuDlvGxds2hmrhwmLetsd0ojmLMsxq3rCq2qKHH7hKJngxN8xuyNqyZhKf1xklko9nn3o8d46Q1rRElbVAS+NjKWDHmt6ymb1HDOe8PxjjxVtwHI5QW6N8S4ecfN77GRKXZwr6azwF32LgbtmF2lL67PlJOwKdtQhO3rOhhkjB595UeqypkSCHqrY0E2uxYZXVKIxfj7BPhuxLvLLpQ5Lex327DaS1fyGdv5VNF5gN2bs+2Ne1xM26xkbNbFtXSB028950/jD8W+2/azwF33rbkIpvEQKTkPKmoVRPaLqOeJRTGTNQD78nwNNF/xV/V9d+LrBvnqIfVRH6rZbVCs2zTAkFv/NEWelLKOpypNYZFyniuQ4LoZhEAQBdd/DsiwURUFV1SdRLpdxHIdfiO9KJpqU4n4AAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/44f0d9ea98aed905a50559e9b9bbdc08/4e630/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png","srcSet":"/static/44f0d9ea98aed905a50559e9b9bbdc08/c4c25/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 750w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/ca77f/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1080w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/c8ae2/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1366w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/4e630/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/44f0d9ea98aed905a50559e9b9bbdc08/edf46/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 750w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/e2d70/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1080w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/3577c/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1366w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/f19ee/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.4848958333333333}}}},"body":"\n## 목차\n\n- 들어가며\n- `transform`으로 개선 전 후 성능 비교하기\n- Layout, Reflow, Paint, Repaint\n- 애니메이션은 어떻게 처리될까?\n\n---\n\n## 들어가며\n\n드래그 이벤트 구현시 초기에는 엘리먼트의 위치를 `top` 과 `left` 값으로 업데이트해주었다. 그런데 드래그시 미세하게 버벅거려 `transform` 으로 변경해 매끄러운 드래그 이벤트를 구현했다. `transform`은 Layout(Reflow)를 발생시키지 않아 더 빠르게 위치를 업데이트 할 수 있다.\n\n이 포스트에서 실제로 성능을 비교해보고 브라우저 렌더링 과정을 이해하고 마지막으로 `transform`은 어떻게 처리하는지 알아보자.\n\n## 개선 전, 후 성능 비교하기\n\n크롬 성능 측정을 이용해 드래그 이벤트를 발생시킨 후, 드래그가 본격적으로 발생한 약 4초 동안의 구간을 확인해 보았다.\n\n개선 전, 개선 후의 요약 탭을 확인해보면 렌더링은 38ms에서 24ms 로 단축되고 페인팅은 41ms에서 24ms로 로 개선됐다.\n\n개선 전:\n![개선전](./개선전.png)\n\n<br />\n개선 후: ![개선후](./개선후.png)\n\n다음 사진은 드래그가 발생하는 동안 실행된 작업들이다. 여기서 하나를 확대해보자.\n![드래그시 실행 중인 작업](./드래그-실행중인-작업들.png)\n\nmousemove가 드래그 이벤트가 발생한 시점이다. 개선 전 작업을 보면 레이아웃과 페인트 작업을 볼 수 있다.\n![개선 전 작업](./개선전작업.png)\n\n반면에 개선 후 작업에서는 페인트 단계만 볼 수 있다.\n![개선 후 작업](./개선후작업.png)\n\n왜 transform 은 레이아웃 작업이 없을까? 브라우저 렌더링 과정에서 알아보자.\n\n## Layout, Reflow, Paint, Repaint\n\n브라우저 렌더링 과정에은 Style, Layout, Paint, 때때로 Compositing이 포함된다. 오늘은 Layout부터 Repaint까지 알아보자.\n\n### Layout\n\n렌더 트리가 만들어진 후, 각 노드의 도형 값을 계산하기 위해 레이아웃을 실행한다. 렌더 트리에 있는 모든 노드의 너비, 높이, 위치를 결정하는 프로세스이다. 처음 노드의 사이즈와 위치가 결정된다.\n\n### Reflow\n\n레이아웃 이후 페이지의 일부분이나 전체 문서에 대한 크기나 위치에 대한 결정한다. 레이아웃 이후에 노드의 크기와 위치를 다시 계산한다. (크롬 개발자 도구에서는 Layout 용어로 통일)\n\n### Paint\n\n텍스트, 색깔, 경계, 그림자 및 버튼인자 이미지 같은 대체 요소를 포함하여 모든 요소의 **시각적인 부분**을 화면에 그리는 작업이다.\n\n### Repaint\n\n첫 페인트 이후 UI변경으로 시각적 업데이트를 표시하기 위해 다시 그릴 때 발생한다. 일반적으로 리플로우 이후에 발생한다.\n\ncss 속성별로 렌더링을 발생시키는 작업이 있다. 각 속성이 어떤 렌더링 과정을 일으키는지는 [https://lab.skk.moe/css-triggers](https://lab.skk.moe/css-triggers%EC%97%90%EC%84%9C)에서 확인할 수 있다.\n\n처음으로 구현했던 방법은 left와 top속성을 직접 업데이트하는 것이었는데, Layout을 발생시키는 요소를 확인할 수 있다.\n![left 트리거](./left-트리거.png)\n\n반대로 transform은 Composite만 발생시킨다. (Blink, 크롬기준)\n![transform 트리거](./transform-트리거.png)\n\n여기까지 transform이 실제로 Reflow작업을 방지해 성능을 개선한 것을 눈으로 알아봤다.\n\n## `transform`은 어떻게 처리될까?\n\n`transform`은 합성 단계에서 처리된다. 합성 단계는 메인 쓰레드가 아닌, GPU를 이용해 레이어를 합성해 정확하게 화면에 그린다. 레이어는 video, canvas, 3d 또는 원근 변화 css 속성 등 사용시 생성된다.\n\n즉, transform 속성을 사용하면 레이어를 생성한다. 그리고 GPU를 사용해 변경이 일어나면, 기존 레이어를 합성하여 더 빠르게 렌더링을 할 수 있다. 레이어를 이용하면 성능이 향상되지만, 메모리 관리 측면에서는 비싼 작업이므로 주의해야한다.\n\n---\n\n참고\n\n- [https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work](https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work)\n- [https://blog.seokho.dev/ko/development/2021/03/08/ReflowRepaint.html](https://blog.seokho.dev/ko/development/2021/03/08/ReflowRepaint.html)\n- [https://developer.mozilla.org/ko/docs/Glossary/Repaint](https://developer.mozilla.org/ko/docs/Glossary/Repaint)\n- [https://lab.skk.moe/css-triggers](https://lab.skk.moe/css-triggers)\n- [https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work](https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work)\n- [https://web.dev/articles/speed-layers#introducing_layers](https://web.dev/articles/speed-layers#introducing_layers)\n"},{"id":"99c1a095-0418-5735-80ae-22cbe6c9f075","frontmatter":{"title":"드래그 이벤트 구현기1","slug":"/드래그 이벤트 구현기1","date":"2024-06-16","tags":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIElEQVR42n2SW08TURSF+V8mqAREegMvYAxGEtTEoMQQhSiiRAhUaKfTFgq9QGuFTu+dFigtCmoElCg8gOIjiQ+amPgfPndb9MXSh5XJzpz5Zq29Tp0lrmCOOSqKixadNMyqNPhdnJ1zUR92c1qbxphwy3snrX/PVpElplJnXJjBFHViiSqYMio3FDd3e0J09YW49zjFSG+Wsb5lIqM63cEADVG7nK8BbNM8mAVoFqBZn6LLOkTwyUPe5nQOtrb4NZ3nx80AP29p+MRp/+tJricdGKIlQBXg1bSHNolSGpq0SRxrWT7mX7G7/Zmjg2+81xfQfRN8vR9kQFnkgqRoT6iYTnLYHpuRvVR20xi1oeY1fh9953BvF++YjdSolS876+zHcvSO5zijTcmHysmR2zWBHds/n3TyyGdlJxEW2DhX6puZHRgk/WyCfMTPlL5Jc8RVG9gRV8vuSsBmifI07GLjpZ/psedY+x8wfLubzlONjNzpEfdZTLIecy2g6YW0FlFoFXCTNGgvRvhUWOJw+w177zYY6LxGNjDP5nCIIdWBMV0qsEbLhpDjH/CcZsNeiLOeyZGYd/Nho0gqvMBKUGN7METvnFNSKP+1az5OWAZaUk6MMpTUotnL8S8n3eWfXEy46Mh4uCSzZdFevvgGuV7V1CJrMIjq7NEwniVNFMe7EhOlmVlJ4S1k8Bd1/KuVZ2Atx1yxugKrOt7lJL58mj+B6UXuYyQ9fAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/b25dfd39144083a82bdaf66033dd54b7/61fb6/thumbnail.png","srcSet":"/static/b25dfd39144083a82bdaf66033dd54b7/27806/thumbnail.png 750w,\n/static/b25dfd39144083a82bdaf66033dd54b7/1af68/thumbnail.png 1080w,\n/static/b25dfd39144083a82bdaf66033dd54b7/eff31/thumbnail.png 1366w,\n/static/b25dfd39144083a82bdaf66033dd54b7/61fb6/thumbnail.png 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/b25dfd39144083a82bdaf66033dd54b7/81950/thumbnail.webp 750w,\n/static/b25dfd39144083a82bdaf66033dd54b7/86e93/thumbnail.webp 1080w,\n/static/b25dfd39144083a82bdaf66033dd54b7/51b5c/thumbnail.webp 1366w,\n/static/b25dfd39144083a82bdaf66033dd54b7/a518e/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5572916666666666}}}},"body":"\n## 목차\n\n1. 목표 기능\n2. 구현 아이디어\n3. 상세 구현 내용\n4. 마무리\n\n---\n\n## 목표 기능\n\n![드래그 이벤트 구현](./드래그-이벤트-구현.gif)\n\n윈도우 창을 드래그 할 수 있는 기능이다. react-draggable 라이브러리를 이용하면 손쉽게 구현할 수 있지만 어떻게 구현해야 하는지 알아보기 위해 구현한다.\n\n## 구현 아이디어\n\n**react-draggable 구현 참고하기**\n\nreact-draggable 라이브러리를 사용하면 아이템을 드래그앤 드롭 이벤트를 쉽게 구현할 수 있다. 아이템은 CSS transform을 이용해 위치를 움직인다.\n\n[react-draggable 라이브러리](https://github.com/react-grid-layout/react-draggable)는 어떻게 구현했는지 짧게 확인해보았다.\n\n```tsx\n// /lib/Draggable.js\n\ntype DraggableState = {\n  dragging: boolean,\n  dragged: boolean,\n  x: number, y: number,\n  slackX: number, slackY: number,\n  isElementSVG: boolean,\n  prevPropsPosition: ?ControlPosition,\n};\n\nexport type DraggableDefaultProps = {\n  ...DraggableCoreDefaultProps,\n  axis: 'both' | 'x' | 'y' | 'none',\n  bounds: Bounds | string | false,\n  defaultClassName: string,\n  defaultClassNameDragging: string,\n  defaultClassNameDragged: string,\n  defaultPosition: ControlPosition,\n  scale: number,\n};\n\nexport type DraggableProps = {\n  ...DraggableCoreProps,\n  ...DraggableDefaultProps,\n  positionOffset: PositionOffsetControlPosition,\n  position: ControlPosition,\n};\n\nclass Draggable extends React.Component<DraggableProps, DraggableState> {\n    // ...\n  onDrag: DraggableEventHandler = (e, coreData) => {\n    if (!this.state.dragging) return false;\n    log('Draggable: onDrag: %j', coreData);\n\n    const uiData = createDraggableData(this, coreData);\n\n    const newState = {\n      x: uiData.x,\n      y: uiData.y,\n      slackX: 0,\n      slackY: 0,\n    };\n// ...\n```\n\n`DraggableProps` 보면 드래그 하는 상태(dragging, dragged)와 엘리먼트 위치(x, y)를 확인할 수 있다. 또 드래그 이벤트 구현체인 `onDrag` 메서드에서 `createDraggableData` 함수를 이용해 엘리먼트 위치를 업데이트한다.\n\n`createDraggableData` 함수는 현재 위치, 이동한 델타 값 그리고 마지막 위치를 반환하고 있다.\n\n```tsx\n// /lib/utils.positionFns.js\n\nexport function createDraggableData(draggable: Draggable, coreData: DraggableData): DraggableData {\n  const scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + (coreData.deltaX / scale),\n    y: draggable.state.y + (coreData.deltaY / scale),\n    deltaX: (coreData.deltaX / scale),\n    deltaY: (coreData.deltaY / scale),\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n```\n\n이를 통해 알 수 있는 것은 아이템의 현재 위치, 이동한 델타 값, 마지막 위치를 활용해서 위치를 업데이트 하는 것을 알 수 있다.\n\n**아이템 위치 업데이트하기**\n\n아이템의 현재 위치, 이동한 델타 값은 마우스 이벤트에서 제공하는 뷰포트의 좌표값인 `clientX`, `clientY` 를 사용하면 된다.\n\n먼저 마우스가 이동한 델타값을 구해보자. `현재 마우스 위치 - 마지막 마우스 위치` 을 계산하면 된다.\n\n아이템의 위치는 아이템의 좌측 상단의 값으로 계산해줘야 한다. 아이템은 transform을 이용해 업데이트 하는데 transform의 기준은 아이템의 좌측 상단이기 때문이다. `현재 좌측 상단의 값 + 델타값` 을 계산하면 된다.\n\n![드래그 위치](./드래그-위치.png)\n\n## 상세 구현 내용\n\n### 드래그 앤 드롭이벤트 구현하기\n\n드래그 앤 드롭 이벤트를 구현하기 위해 `isDragging`인 상태를 추가했다. 이 상태 값이 true인 경우 `handleDrag` 를 실행시킨다.\n\n```tsx\nconst [isDragging, setIsDragging] = useState(false);\nconst ref = useRef<HTMLDivElement>(null);\n\nconst handleDragStart = () => {\n  setIsDragging(true);\n};\n\nconst handleDragStop = () => {\n  if (!isDragging) return;\n\n  setIsDragging(false);\n};\n\nconst handleDrag = () => {\n  if (!ref.current) return;\n  if (!isDragging) return;\n\n  // TODO: 아이템 위치 업데이트\n};\n\nuseEffect(() => {\n  if (isDragging) {\n    document.addEventListener('mousemove', handleDrag);\n  }\n\n  return () => {\n    document.removeEventListener('mousemove', handleDrag);\n  };\n}, [isDragging]);\n\nreturn (\n    <div\n      ref={ref}\n      onMouseDown={handleDragStart}\n      onMouseUp={handleDragStop}\n    >\n      {children}\n    </div>\n  );\n}\n```\n\n### 아이템 위치 업데이트 하기\n\n아이템 위치를 업데이트하기 위해 아이템의 현재 위치, 이동한 델타 값, 마지막 위치 값이 필요하다.\n\n아이템의 현재 위치와 마지막 위치 정보를 저장하기 위해 `position` 과 `last` 상태 값을 추가했다.\n\n```tsx\n// 아이템 위치\nconst [position, setPosition] = useState({\n  x: 0,\n  y: 0,\n});\n// 마지막 위치\nconst [last, setLast] = useState({\n  x: defaultPosition.x,\n  y: defaultPosition.y,\n});\n```\n\n마우스가 이동한 델타 값은 현재 마우스 위치 - 마지막 마우스 위치 로 구할 수 있다.\n\n```tsx\nconst deltaX = e.clientX - last.x;\nconst deltaY = e.clientY - last.y;\n```\n\n마지막으로 아이템의 위치를 업데이트할 값인 좌측 상단의 값은 `현재 좌측 상단의 값 + 델타값` 로 구하면 된다.\n\n```tsx\nconst deltaX = position.x + e.clientX - last.x;\nconst deltaY = position.y + e.clientY - last.y;\n```\n\n구한 delta값으로 아이템의 위치를 업데이트 하면 끝이다.\n\n```tsx\nref.current.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n```\n\n전체 코드는 이렇다.\n\n```tsx\nconst [isDragging, setIsDragging] = useState(false);\n// 아이템 위치\nconst [position, setPosition] = useState({\n  x: 0,\n  y: 0,\n});\n// 마지막 위치\nconst [last, setLast] = useState({\n  x: defaultPosition.x,\n  y: defaultPosition.y,\n});\nconst ref = useRef<HTMLDivElement>(null);\n\nconst handleDragStart = (\n  e: MouseEvent | React.MouseEvent<HTMLDivElement, MouseEvent>\n) => {\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  setIsDragging(true);\n};\n\nconst handleDragStop = (\n  e: MouseEvent | React.MouseEvent<HTMLDivElement, MouseEvent>\n) => {\n  if (!isDragging) return;\n\n  setIsDragging(false);\n};\n\nconst handleDrag = (e: MouseEvent) => {\n  if (!ref.current) return;\n  if (!isDragging) return;\n  e.preventDefault();\n\n  const deltaX = e.clientX - last.x + position.x;\n  const deltaY = e.clientY - last.y + position.y;\n\n  setPosition({ x: deltaX, y: deltaY });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n\n  ref.current.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n};\n\nuseEffect(() => {\n  if (isDragging) {\n    document.addEventListener('mousemove', handleDrag);\n  }\n\n  return () => {\n    document.removeEventListener('mousemove', handleDrag);\n  };\n}, [isDragging]);\n\nreturn (\n    <div\n      ref={ref}\n      style={{\n        position: 'absolute',\n        top: defaultPosition.y,\n        left: defaultPosition.x,\n      }}\n      onMouseDown={handleDragStart}\n      onMouseUp={handleDragStop}\n    >\n      {children}\n    </div>\n  );\n}\n```\n\n### 화면 밖으로 벗어나지 않기\n\n드래그는 이제 잘 된다! 그러나 아이템이 화면 밖으로 벗어나는 문제점이 있다. 상하좌우 밖으로 벗어나지 않도록 개선해보자.\n\n![화면 밖으로 나가기](./화면-밖으로-나가기.png)\n\n**상단 밖으로 벗어나는 경우**\n\n`아이템의 초기 y + 델타 y` 이 0보다 작은 경우 상단 밖으로 벗어나는 케이스이다. 아이템을 상단에 고정시키기 위해 `-아이템의 초기 y` 로 위치를 업데이트 하면 된다.\n\n```tsx\nconst fixToTop = (ref: HTMLDivElement) => {\n  setPosition({ x: deltaX, y: -defaultPosition.y });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  ref.style.transform = `translate(${deltaX}px, ${-defaultPosition.y}px)`;\n};\n```\n\n**하단 밖으로 벗어나는 경우**\n\n`아이템의 초기 y + 델타 y + 아이템의 높이` 가 뷰포트의 높이보다 큰 경우 하단 밖으로 벗어나는 케이스이다. 아이템을 하단에 고정시키기 위해 `뷰포트 높이 - 아이템 높이 - 아이템의 초기 y` 로 위치를 업데이트 하면 된다.\n\n```tsx\nconst eleHeight = ref.current.clientHeight || 0;\n\nconst fixToBottom = (ref: HTMLDivElement) => {\n  setPosition({\n    x: deltaX,\n    y: window.innerHeight - eleHeight - defaultPosition.y,\n  });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  ref.style.transform = `translate(${deltaX}px, ${\n    window.innerHeight - eleHeight - defaultPosition.y\n  }px)`;\n};\n```\n\n**좌측 밖으로 벗어나는 경우**\n\n아이템이 상단 밖으로 벗어나는 경우처럼 계산하면 된다.\n\n```tsx\nconst fixToLeftTop = (ref: HTMLDivElement) => {\n  setPosition({ x: -defaultPosition.x, y: -defaultPosition.y });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  ref.style.transform = `translate(${-defaultPosition.x}px, ${-defaultPosition.y}px)`;\n};\n```\n\n**우측 밖으로 벗어나는 경우**\n\n아이템이 하단 밖으로 벗어나는 경우처럼 계산하면 된다.\n\n```tsx\nconst eleWidth = ref.current.clientWidth || 0;\n\nconst fixToRight = (ref: HTMLDivElement) => {\n  setPosition({\n    x: window.innerWidth - eleWidth - defaultPosition.x,\n    y: deltaY,\n  });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  ref.style.transform = `translate(${\n    window.innerWidth - eleWidth - defaultPosition.x\n  }px, ${deltaY}px)`;\n};\n```\n\n여기서 대각선 방향으로 벗어나는 경우까지 추가하면 외부로 벗어나지 않는 드래그 이벤트를 구현할 수 있다.\n\n![드래그 이벤트 구현](./드래그-이벤트-구현.gif)\n\n## 마무리\n\n드래그 이벤트를 구현하면서 뷰포트, 마우스 좌표값을 활용하는 것을 익힐 수 있었다. 또한 라이브러리 의존성을 성공적으로 제거하여 구현 능력을 키울 수 있었다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}