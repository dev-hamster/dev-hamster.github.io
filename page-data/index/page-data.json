{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allMdx":{"nodes":[{"id":"16c12736-a3ac-5bcf-b947-bae3fb5a471b","frontmatter":{"title":"반응형 레이아웃 퍼블리싱 스터디 회고 🤓","slug":"/반응형-퍼블리싱-스터디-회고-🤓","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAAGi0lEQVR42nWV228bxxXGmYsRIYlly7paokSJokguyeXuci8kl/ebRFKiLtbVlmTLMWTnYtmOKse149ZAqgSB4rhFDdtIW9tBg7qAi6LIQ18KBIVbFOhrH4o+F8j/8euMLKFAgT4c7M6cme+cmXO+bzzpdJpEwsR2HAzdIhDS8Ad1YnETxxZzwpdKpchks6QPzEmnsFIHlkxiH/y7bgZPOBzilSNttPUM4FVDLK+5XDpvkchHeXNghFffaMfn8+PUKqgTVeLi68xM4U43sOrjhAsF+uManWEF3bbxBEZHOer1k19e4vbGAr8+W+HJgsPTi2XOrK/QFYrSf9JLuj7BWKnIxtYGz39zj2d/+h1Pnn/F9rWLhETW3eHwS8CQliAZG2dK0Vkc7KLaeZzMsXZmu3u5GLaw03WGTYtkpUi4VuPd9xapjxf54usvWd+6RDBqo6cdumNxDHF8T8xMMtzXx2zSzz+uxniweIwv597k+50oj5cVunp6UARgoljEqJS5c32TSx9usv30EadvXSeZzRAMhjkxGkIXdfAEg0FeO9pFIBLj45kYlWQPtVw/n80HKCSjeNo68Q0OYVYqBNIu5z98n43rO8ytrpGbniNiphjwjfLW4Ahxy8IzFgjS1utjwK3wSl+QxfUya1sLePqGOTv/Div6NL39QxiFIj6R6YWb23zyzQPe/fgq1u2PCMy36O3q5+jAMNrLO4zTtTDFyaU5vJkG9x5c4ZNHO6xuNnl6Ns7uhEXTzRJ0UgTjOmomR2ZpifMX5ghVS7wdVGk/3k+HdwTNEoBjUZUuxY+mD3D58nm++e0tfvyzy9x9dIXKKR074sWNRAgl0/SFY3QEIuQbTT69sUEzY3Csa5D2wTE6RkIvAROGQVo05dT0JHXRGpVyiXwhT6lcpi7mLMcUwTQSpombyQpfkWZjgmazQUP0oW1bKIpCJBrFkUXRjQSteoXlxXkmJhrCJsiKjZJBGddFVVVMAWaIwI1agaXFBRrNJq3WNMVSGV3MR8QJooeAlkgzocVQY5H9KNIZFk2qSBORpUnARCJBVPjkWG6OxWL7a/fBYtH/AsrFMstsPi+OlRCgEWLCmUo6lIoF3FRyH9AUPjmXE32XMHQBoKDFY+QyLmXRo44t9EBWOZ0UxBZ3ZAtQU9fFIo2oqqHEDRTNFJVNkHCSIqjNaEQjLJg1qhj4w/q+jcUShDSDsYiBI7A8togYFrSK12vo4pJLzRqr02Wuz2f50akku3MWC6U051Zy3L9c4vNzZX6+nePhDzI82Mly7708e+tV9q4UxR1n8Sg5QeyZJsrGGZZufcDzX37A33bz/PWaw4stl39uRrnTNPjVVQHWSjPpM3n+03We/eUO3353k73VKSrdUf54o8D2ek5wWQAOzzYZW1ngs7tbvHg4xbdbXaxkIny05LI7n+JMyeTJVIMfBg3aUi38v3hC5/MXdP7+O9p+cp+eoQR/GC9wtVHCo4oj+ydr+OemuXF7lbs7FR6ue0XLWOTLltDAItFMisfVcf7dnGLzVIuJcot8NsV4piCavMX9ZoXvp6e4ILTRk8i6RIQcBScbnF5v8PXCCXbTHvKDx7Ebeex6nnjB5XG+wp9nV0kVGri+GE/OaOxVAliiQO/MnuZfU9NsZvOiDzNpokWXkVIOpVJgQNVp8wbo0w2MWo6IyE4R2TyzJ/giu8ZrXtEJ/T5O5SeZTGTx9viFaNT5u73IZlIe2bHxuQ6nNpdYXiqTruQYWT1HT89J9GqG+mIDv63zlfo+M+Y1Xh0y6TjWT/fbnfS0d9HRLoRhqMCe9TmX1BaeUU3HqjpcuzTLzpkCazmFybCXZHiIhh1ifk4otWjkRmmb18tXaItUOTKa4fU2L0feGuaNEZcjepO++k0m3UU8mmUybo/i6+0hPtDHjOFnJjZILuQj5PWijI3sMyXglDihZOiIpjlhFOgeMOgdTdFrlOlXXbrVHJorimIKjhbyOVZWlmm2WtREJav1STL5IorgqarGsASgJURgUjT/ypJ8U2rMzc0IqplElZDQgShqRCEprs9jCnFwTE3wNkdRSFO1WiGfyxGPq/tCED4UB0HNlKmTEz75TuuCplIgZFDlQCSS8pGSeqbGxYslMpVSJVVDmtwgyS6/h2ojeS7Hct2hZMl5S7wlmqYdype1v8gV2mccaJs0CSI1UfoPAaXJ7OTmQxmTIId799VGDuSP3Ci//2tyXgJLOxz/v7US6z9By8R0nCBqYQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png","srcSet":"/static/17ad8121ccf87c6ce98490d2626d88cd/eb5fe/07.png 750w,\n/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png 924w","sizes":"100vw"},"sources":[{"srcSet":"/static/17ad8121ccf87c6ce98490d2626d88cd/5c34d/07.webp 750w,\n/static/17ad8121ccf87c6ce98490d2626d88cd/6b2ec/07.webp 924w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":1.4004329004329006}}}},"body":"\n퍼블리싱 속도를 높이고 레이아웃을 잡는 연습을 하기 위해 2024.11.10부터 4주간 퍼블리싱\n스터디에 참여했다. 동일한 Figma 디자인 시안으로 퍼블리싱을 진행해 다른 스터디원의\n노하우를 엿볼 수 있었다. 스터디에 참여하면서 grid, flex를 더 적극적으로 활용할 수\n있게 되었고, 퍼블리싱 팁뿐만 아니라 디렉토리 구조에 대해서도 지식을 넓힐 수 있었다.\n\n## week01\n\n**TL;DR**\n\n- 이미지 사이즈를 주는 방법은 3가지로 있고, 적재적소에 알맞게 사용하는게 좋다.\n- scss도 module을 지원한다. 하지만 CSS-in-JS가 선호되는 이유를 알겠다.\n\n**Figma 디자인 시안**\n\n![image01](01.png)\n\n**scss**\n\n개인적으로 CSS로 처리할 수 있는 작업은 CSS를 사용하는 것을 선호해 SCSS로 스타일링을 시도해보았다. 하지만 SCSS에서는 변수를 사용하려면 스타일 파일에서 명시적으로 연결해주어야 하는 점이 불편했다. 반면 CSS-in-JS는 변수를 쉽게 받아와 사용할 수 있다는 점이 큰 장점으로 느껴졌다.\n\n```\n// /styles/variables.scss\n\n// breakpoint를 변수로 관리했다.\n$tablet-breakpoint: 767px;\n$pc-breakpoint: 1024px;\n```\n\n```\n// button.module.scss에서 정의한 변수를 사용하려면 @use를 한다.\n@use '/styles/variables.scss' as var;\n\n.foo {\n  @media (min-width: var.$tablet-breakpoint) {\n    // ...\n  }\n}\n```\n\n**이미지 사이즈는 어떤 방법으로 줄까?**\n\n이미지 사이즈를 조정하는 방법은 이렇게 3가지가 있다. 어떤 방식으로 이미지를 넣어줘야 하는지 애매모호해서 스터디원의 의견과 구글링을 통해 기준을 정리해보았다.\n\n1.  이미지 태그에 직접 `width`, `height` 값 주기\n2.  이미지 `width`는 100%로 하고 부모 요소를 통해 스타일 제어하기\n3.  요소의 `background-image`속성으로 `object-position` 값을 주기\n\n> 이미지에 직접 width, height 값 주기\n\n- 디자인이 정적으로 고정되는 요소 (예: 해당 Fimga의 프로필 이미지)\n- CLS를 방지하고 브라우저가 이미지 크기를 미리 알고 효율적으로 로드\n\n> 이미지 width는 100%로 하고 부모 요소에 의존하기\n\n- 컨테이너 레이아웃, 가변적으로 적용되는 요소 (예: 해당 Fimga의 카드 컴포넌트 썸네일)\n\n> 요소의 background-image속성으로 object-position 값을 주기\n\n- 꾸밈 이미지와 같이 내용에 영향을 주지 않는 요소\n- 렌더 트리 생성 단계 이후에 이미지를 요청해 우선순위가 낮음\n\n**상단 컨텐츠 레이아웃**\n\n![image02](02.png)\n\nPC, 태블릿, 모바일 화면에서 레이아웃이 달라지는 디자인이다. 이 영역은 공통되는 초록생 영역을 기준으로 잡았다.\n\n초록색 영역은 `flex-direction`을 `column` 으로 레이아웃을 잡았다. 모바일 화면에서는 버튼 컨테이너와 Active Users 위치를 각각 `absolute`로 했다.\n\n**카드 리스트 레이아웃**\n\n![image03](03.png) ![image04](04.png)\n\n`Featured NFTs`와 `Cretors` 의 카드 영역은 모두 grid 레이아웃을 적용했다.\n\n**새로 알게된 사실**\n\nscss에서 `&__` 를 사용하면 상위 클래스 네임을 상속받을 수 있어 BEM 규칙을 따를 수 있다.\n\n```\n\n// 이것은\n.text-box {\n  &__title {\n  }\n}\n\n// 이렇게 컴파일 된다.\n.text-box{\n}\n.text-box__title {\n}\n```\n\n**작업 결과**\n\n![05](./05.gif)\n\n## Week02\n\n**TL;DR**\n\n- `flex: 1 1 auto` 를 이해하고 사용했다.\n- grid 레이아웃을 사용하면, 최대한 많은 요소를 보여주는 레이아웃을 그릴 수 있다.\n\n**Figma 디자인 시안**\n\n![06](06.png)\n\n**emotion 사용**\n\n디자인 재사용성을 높여보도록 `emotion`를 사용했는데, 퍼블리싱에만 집중했다. ^^;\n\n**reset css**\n\n[https://www.joshwcomeau.com/css/custom-css-reset/](https://www.joshwcomeau.com/css/custom-css-reset/) 를 사용했다.\n\n그 중에, isolation 속성이 인상깊은데,\n\n```\n/* https://www.joshwcomeau.com/css/custom-css-reset/ */\n\n/*\n  9. Create a root stacking context\n*/\n#root, #__next {\n  isolation: isolate;\n}\n```\n\n> This is beneficial since it allows us to guarantee that certain high-priority elements (modals, dropdowns, tooltips) will always show up above the other elements in our application. No weird stacking context bugs, no z-index arms race.\n\n모달, 드롭다운, 툴팁이 항상 다른 요소들 위에 표시되도록 보장할 수 있다고 한다.\n\n**카드 레이아웃**\n\n![07](07.png)\n\n화면 해상도가 넓어지면 최대한 많은 카드를 보여주기 위해 `grid-template-columns` 속성을 사용하고 최소 카드 width를 `315px` 를 주었다.\n\n```\nconst CardLayout = styled.div`\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(315px, 1fr));\n  grid-gap: 20px;\n`;\n```\n\n**탭 레이아웃**\n\n![08](08.png)\n\n두 버튼의 width 간격을 같은 비율로 맞춰주기 위해 `flex: 1 1 auto;` 를 적용했다. (미루고 미뤄왔던,,, `flex: 1 1 auto`를 이해했다. 😆)\n\nButton을 width 100%로 둬도 동일한 효과를 줄 수 있다고 한다.\n\n```\nconst TabContainer = styled.div`\n  display:flx;\n`\nconst Button = styled.div`\n    width: 100%;\n`\n```\n\n**Collection 하위 아이템 레이아웃**\n\n![09](09.png)\n\n하위 아이템의 레이아웃은 최소 너비를 95px를 보장하고 균등하게 나누기 위해 `flex: 1 1 95px;` 을 사용했다.\n\n하위 아이템 개수가 모자른 경우에는 조건문으로 빈 element를 넣어줬는데, grid-template-columns를 이용해 같은 공간을 3개로 균등하게 나누면 스크립트롤 작성하지 않아도 된다!\n\n```\ndisplay: grid;\ngrid-template-columns: 1fr 1fr 1fr;\n```\n\n**작업 결과**\n\n![10](10.gif)\n\n## week03\n\n**TL;DR**\n\n- Grid로 공백있는 레이아웃 표현하기\n\n**Figma 디자인 시안**\n\n![11](11.png)\n\n**그리드 시스템으로 공백이 있는 레이아웃 표현하기**\n\n모바일에서는 컨텐츠가 일렬로 배치되어 있고 태블릿 이상부터는 두 열로 배치된다. flex를 사용하면 태블릿 이상부터는 표현하기 어려워진다. 그리드 시스템을 사용하면 일렬, 두 열 레이아웃을 간결하게 구현할 수 있다.\n\n![12](12.png) <br /> ![13](13.png) <br /> ![14](14.png)\n\n`grid-template-areas`를 사용하면 이름을 지정해 레이아웃을 배치할 수 있다. 각 그리드\n아이템은 `grid-area` 속성으로 이름을 지정할 수 있다.\n\n각 영역에 `grid-area` 로 적당한 이름으로 준 뒤, 컨테이너에 이렇게 하면 일렬로 배치할 수 있다.\n\n```\nconst ContentsContainer = styled.div`\n    grid-template-areas:\n    'title'\n    'endsIn'\n    'creator'\n    'description'\n    'details'\n    'tags';\n  // ...\n`;\n```\n\n![15](15.png)\n\n태블릿 크기 이상에서는 그리드 아이템을 두 열로 나누어 배치한다. endsIn 영역은 오른쪽 열에 위치시키고 title부터 description 영역까지 세로로 걸치게 했다. 나머지 영역은 '.'을 사용하여 공백 처리한다.\n\n```\nconst ContentsContainer = styled.div`\n  // ...\n\n  @media (min-width: 834px) {\n    grid-template-areas:\n      'title title endsIn'\n      'creator creator endsIn'\n      'description description endsIn'\n      'details details .'\n      'tags tags .';\n    // ...\n    }\n`;\n```\n\n`endsIn` 영역(타이머)이 `description`까지 늘어나게 되는데, 이는 해당 요소에 `height`를 지정하지 않아 왼쪽 컨텐츠의 높이값을 따라가기 때문이다. 이 문제를 해결하기 위해 `endsIn` 컨텐츠에 `min-content` 값을 적용하여 자신의 내용물 크기만큼만 높이를 가지도록 했다.\n\n![16](16.png)\n\n```\nconst EndsInBlock = styled.div`\n  height: min-content;\n  // ...\n `\n```\n\n아래는 전체 코드의 일부이다. 흥미로운 점은 마크업 순서와 관계없이 `grid-area`의 이름 속성만으로 요소 배치가 결정된다.\n\n```\n<ContentsContainer>\n  <Title />\n  <Creator />\n  <Description />\n  <Details />\n  <Tags />\n  <EndsIn />\n</ContentsContainer>\n\nconst ContentsContainer = styled.div`\n  gap: 20px;\n  padding: 40px 30px;\n  display: grid;\n  grid-template-areas:\n    'title'\n    'endsIn'\n    'creator'\n    'description'\n    'details'\n    'tags';\n\n  @media (min-width: 834px) {\n    padding: 40px 72px;\n    grid-template-columns: 1fr 295px;\n    grid-template-areas:\n      'title title endsIn'\n      'creator creator endsIn'\n      'description description endsIn'\n      'details details .'\n      'tags tags .';\n    column-gap: 30px;\n  }\n\n  @media (min-width: 1280px) {\n    padding: 40px 115px;\n    column-gap: 150px;\n  }\n`;\n```\n\n**작업 결과**\n\n![17](17.gif)\n\n### week04\n\n**TL;DR**\n\n- 레이아웃 흐름을 방해하지 않고 스타일 주기\n\n**Figma 디자인 시안**\n\n![18](18.png)\n\n**Form 레이아웃**\n\ngrid 레이아웃으로 모바일에서는 1열로 배치하고 태블릿 이상부터는 `grid-template-areas`로 2열로 배치하도록 했다.\n\n```\n<FormContainer>\n    <HeroBox />\n    <FormBox />\n</FormContainer>\n```\n\n```\nconst FormContainer = styled.div`\n  display: grid;\n  grid-template-columns: 1fr;\n\n  @media (min-width: 834px) {\n    grid-template-areas: 'hero form';\n    grid-template-columns: 1fr 1fr;\n  }\n`;\n\nconst HeroBox = styled.div`\n  // ...\n  grid-area: 'hero';\n`;\n\nconst FormBox = styled(FlexColumnBox)`\n  // ...\n  grid-area: 'form';\n `\n```\n\n**Input focus 스타일**\n\nInput border스타일은 레이아웃에 영향을 주지 않는 `box-shadow`속성을 사용하고 `<InputEle/>` 에 focus가 활성화 됐을 때, 부모 컴포넌트에 포커스 스타일을 주기위해서 네이티브 focus스타일을 주지않고`:focus-within` 를 사용했다.\n\n![19](19.png)\n\n<br />\n![20](20.png)\n\n```\n<InputContainer>\n  <InputWrapper>\n    <InputEle/>\n  </InputWrapper>\n  <ErrorMessage>\n</InputContainer>\n```\n\n```\nconst InputWrapper = styled(FlexRowBox)`\n  // ...\n  box-shadow: 0px 0px 0px 1px rgba(133, 133, 132, 1);\n  &:focus-within {\n    box-shadow: 0px 0px 0px 1.5px rgba(162, 89, 255, 1);\n  }\n`;\n\nconst InputEle = styled.input`\n  // ...\n  outline: none;\n`;\n```\n\n**에러 메세지 레이아웃**\n\n에러메세지가 보여지면서 레이아웃 영향을 주지않도록 `absolute`를 사용했다.\n\n![21](21.png)\n\n```\n<InputContainer>\n  <InputWrapper>\n    <InputEle/>\n  </InputWrapper>\n  <ErrorMessage>\n</InputContainer>\n```\n\n```\nconst InputContainer = styled.div`\n  position: relative;\n`;\n\nconst ErrorMessage = styled.span`\n  // ...\n  position: absolute;\n  margin-top: 1px;\n`;\n```\n\n**작업 결과**\n\n![22](22.gif)\n"},{"id":"58931655-f87a-5a8f-9881-6a2b3a68fe83","frontmatter":{"title":"드래그 이벤트 구현기2 - 왜 transform은 더 빠를까","slug":"/드래그 이벤트 구현기2 - 왜 transform은 더 빠를까","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACCUlEQVR42pWS7U/aUBTGmyWLyYw6N1/m5jKHlrb2DVqhRbsUBKS0tMXotoyhKIKa7NP+/w+/XbqXZB/98Mtzz33Oc3KSe6WTJOJYcDKICeM+n6KIVhLTyQaE/b4gKrSVDmgNM9p5TitPOc0zwYBAZE4WdJucXj8idW5GtCcjzqZXpNMJ6e2EbHpDPrslu7slv5uKeko6m5HeP5DO52TzB+HPBHPh35ELfyhmDH/8RKrUQhyviaL7yLpH2fQKNa2AklorUG0f3W5gWD6G7Ql8zOLOL/w9pca7fQej4iNtuDlvGxds2hmrhwmLetsd0ojmLMsxq3rCq2qKHH7hKJngxN8xuyNqyZhKf1xklko9nn3o8d46Q1rRElbVAS+NjKWDHmt6ymb1HDOe8PxjjxVtwHI5QW6N8S4ecfN77GRKXZwr6azwF32LgbtmF2lL67PlJOwKdtQhO3rOhhkjB595UeqypkSCHqrY0E2uxYZXVKIxfj7BPhuxLvLLpQ5Lex327DaS1fyGdv5VNF5gN2bs+2Ne1xM26xkbNbFtXSB028950/jD8W+2/azwF33rbkIpvEQKTkPKmoVRPaLqOeJRTGTNQD78nwNNF/xV/V9d+LrBvnqIfVRH6rZbVCs2zTAkFv/NEWelLKOpypNYZFyniuQ4LoZhEAQBdd/DsiwURUFV1SdRLpdxHIdfiO9KJpqU4n4AAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/44f0d9ea98aed905a50559e9b9bbdc08/4e630/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png","srcSet":"/static/44f0d9ea98aed905a50559e9b9bbdc08/c4c25/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 750w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/ca77f/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1080w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/c8ae2/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1366w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/4e630/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/44f0d9ea98aed905a50559e9b9bbdc08/edf46/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 750w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/e2d70/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1080w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/3577c/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1366w,\n/static/44f0d9ea98aed905a50559e9b9bbdc08/f19ee/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.4848958333333333}}}},"body":"\n## 목차\n\n- 들어가며\n- `transform`으로 개선 전 후 성능 비교하기\n- Layout, Reflow, Paint, Repaint\n- 애니메이션은 어떻게 처리될까?\n\n---\n\n## 들어가며\n\n드래그 이벤트 구현시 초기에는 엘리먼트의 위치를 `top` 과 `left` 값으로 업데이트해주었다. 그런데 드래그시 미세하게 버벅거려 `transform` 으로 변경해 매끄러운 드래그 이벤트를 구현했다. `transform`은 Layout(Reflow)를 발생시키지 않아 더 빠르게 위치를 업데이트 할 수 있다.\n\n이 포스트에서 실제로 성능을 비교해보고 브라우저 렌더링 과정을 이해하고 마지막으로 `transform`은 어떻게 처리하는지 알아보자.\n\n## 개선 전, 후 성능 비교하기\n\n크롬 성능 측정을 이용해 드래그 이벤트를 발생시킨 후, 드래그가 본격적으로 발생한 약 4초 동안의 구간을 확인해 보았다.\n\n개선 전, 개선 후의 요약 탭을 확인해보면 렌더링은 38ms에서 24ms 로 단축되고 페인팅은 41ms에서 24ms로 로 개선됐다.\n\n개선 전:\n![개선전](./개선전.png)\n\n<br />\n개선 후: ![개선후](./개선후.png)\n\n다음 사진은 드래그가 발생하는 동안 실행된 작업들이다. 여기서 하나를 확대해보자.\n![드래그시 실행 중인 작업](./드래그-실행중인-작업들.png)\n\nmousemove가 드래그 이벤트가 발생한 시점이다. 개선 전 작업을 보면 레이아웃과 페인트 작업을 볼 수 있다.\n![개선 전 작업](./개선전작업.png)\n\n반면에 개선 후 작업에서는 페인트 단계만 볼 수 있다.\n![개선 후 작업](./개선후작업.png)\n\n왜 transform 은 레이아웃 작업이 없을까? 브라우저 렌더링 과정에서 알아보자.\n\n## Layout, Reflow, Paint, Repaint\n\n브라우저 렌더링 과정에은 Style, Layout, Paint, 때때로 Compositing이 포함된다. 오늘은 Layout부터 Repaint까지 알아보자.\n\n### Layout\n\n렌더 트리가 만들어진 후, 각 노드의 도형 값을 계산하기 위해 레이아웃을 실행한다. 렌더 트리에 있는 모든 노드의 너비, 높이, 위치를 결정하는 프로세스이다. 처음 노드의 사이즈와 위치가 결정된다.\n\n### Reflow\n\n레이아웃 이후 페이지의 일부분이나 전체 문서에 대한 크기나 위치에 대한 결정한다. 레이아웃 이후에 노드의 크기와 위치를 다시 계산한다. (크롬 개발자 도구에서는 Layout 용어로 통일)\n\n### Paint\n\n텍스트, 색깔, 경계, 그림자 및 버튼인자 이미지 같은 대체 요소를 포함하여 모든 요소의 **시각적인 부분**을 화면에 그리는 작업이다.\n\n### Repaint\n\n첫 페인트 이후 UI변경으로 시각적 업데이트를 표시하기 위해 다시 그릴 때 발생한다. 일반적으로 리플로우 이후에 발생한다.\n\ncss 속성별로 렌더링을 발생시키는 작업이 있다. 각 속성이 어떤 렌더링 과정을 일으키는지는 [https://lab.skk.moe/css-triggers](https://lab.skk.moe/css-triggers%EC%97%90%EC%84%9C)에서 확인할 수 있다.\n\n처음으로 구현했던 방법은 left와 top속성을 직접 업데이트하는 것이었는데, Layout을 발생시키는 요소를 확인할 수 있다.\n![left 트리거](./left-트리거.png)\n\n반대로 transform은 Composite만 발생시킨다. (Blink, 크롬기준)\n![transform 트리거](./transform-트리거.png)\n\n여기까지 transform이 실제로 Reflow작업을 방지해 성능을 개선한 것을 눈으로 알아봤다.\n\n## `transform`은 어떻게 처리될까?\n\n`transform`은 합성 단계에서 처리된다. 합성 단계는 메인 쓰레드가 아닌, GPU를 이용해 레이어를 합성해 정확하게 화면에 그린다. 레이어는 video, canvas, 3d 또는 원근 변화 css 속성 등 사용시 생성된다.\n\n즉, transform 속성을 사용하면 레이어를 생성한다. 그리고 GPU를 사용해 변경이 일어나면, 기존 레이어를 합성하여 더 빠르게 렌더링을 할 수 있다. 레이어를 이용하면 성능이 향상되지만, 메모리 관리 측면에서는 비싼 작업이므로 주의해야한다.\n\n---\n\n참고\n\n- [https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work](https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work)\n- [https://blog.seokho.dev/ko/development/2021/03/08/ReflowRepaint.html](https://blog.seokho.dev/ko/development/2021/03/08/ReflowRepaint.html)\n- [https://developer.mozilla.org/ko/docs/Glossary/Repaint](https://developer.mozilla.org/ko/docs/Glossary/Repaint)\n- [https://lab.skk.moe/css-triggers](https://lab.skk.moe/css-triggers)\n- [https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work](https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work)\n- [https://web.dev/articles/speed-layers#introducing_layers](https://web.dev/articles/speed-layers#introducing_layers)\n"},{"id":"99c1a095-0418-5735-80ae-22cbe6c9f075","frontmatter":{"title":"드래그 이벤트 구현기1","slug":"/드래그 이벤트 구현기1","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIElEQVR42n2SW08TURSF+V8mqAREegMvYAxGEtTEoMQQhSiiRAhUaKfTFgq9QGuFTu+dFigtCmoElCg8gOIjiQ+amPgfPndb9MXSh5XJzpz5Zq29Tp0lrmCOOSqKixadNMyqNPhdnJ1zUR92c1qbxphwy3snrX/PVpElplJnXJjBFHViiSqYMio3FDd3e0J09YW49zjFSG+Wsb5lIqM63cEADVG7nK8BbNM8mAVoFqBZn6LLOkTwyUPe5nQOtrb4NZ3nx80AP29p+MRp/+tJricdGKIlQBXg1bSHNolSGpq0SRxrWT7mX7G7/Zmjg2+81xfQfRN8vR9kQFnkgqRoT6iYTnLYHpuRvVR20xi1oeY1fh9953BvF++YjdSolS876+zHcvSO5zijTcmHysmR2zWBHds/n3TyyGdlJxEW2DhX6puZHRgk/WyCfMTPlL5Jc8RVG9gRV8vuSsBmifI07GLjpZ/psedY+x8wfLubzlONjNzpEfdZTLIecy2g6YW0FlFoFXCTNGgvRvhUWOJw+w177zYY6LxGNjDP5nCIIdWBMV0qsEbLhpDjH/CcZsNeiLOeyZGYd/Nho0gqvMBKUGN7METvnFNSKP+1az5OWAZaUk6MMpTUotnL8S8n3eWfXEy46Mh4uCSzZdFevvgGuV7V1CJrMIjq7NEwniVNFMe7EhOlmVlJ4S1k8Bd1/KuVZ2Atx1yxugKrOt7lJL58mj+B6UXuYyQ9fAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/b25dfd39144083a82bdaf66033dd54b7/61fb6/thumbnail.png","srcSet":"/static/b25dfd39144083a82bdaf66033dd54b7/27806/thumbnail.png 750w,\n/static/b25dfd39144083a82bdaf66033dd54b7/1af68/thumbnail.png 1080w,\n/static/b25dfd39144083a82bdaf66033dd54b7/eff31/thumbnail.png 1366w,\n/static/b25dfd39144083a82bdaf66033dd54b7/61fb6/thumbnail.png 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/b25dfd39144083a82bdaf66033dd54b7/81950/thumbnail.webp 750w,\n/static/b25dfd39144083a82bdaf66033dd54b7/86e93/thumbnail.webp 1080w,\n/static/b25dfd39144083a82bdaf66033dd54b7/51b5c/thumbnail.webp 1366w,\n/static/b25dfd39144083a82bdaf66033dd54b7/a518e/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5572916666666666}}}},"body":"\n## 목차\n\n1. 목표 기능\n2. 구현 아이디어\n3. 상세 구현 내용\n4. 마무리\n\n---\n\n## 목표 기능\n\n![드래그 이벤트 구현](./드래그-이벤트-구현.gif)\n\n윈도우 창을 드래그 할 수 있는 기능이다. react-draggable 라이브러리를 이용하면 손쉽게 구현할 수 있지만 어떻게 구현해야 하는지 알아보기 위해 구현한다.\n\n## 구현 아이디어\n\n**react-draggable 구현 참고하기**\n\nreact-draggable 라이브러리를 사용하면 아이템을 드래그앤 드롭 이벤트를 쉽게 구현할 수 있다. 아이템은 CSS transform을 이용해 위치를 움직인다.\n\n[react-draggable 라이브러리](https://github.com/react-grid-layout/react-draggable)는 어떻게 구현했는지 짧게 확인해보았다.\n\n```tsx\n// /lib/Draggable.js\n\ntype DraggableState = {\n  dragging: boolean,\n  dragged: boolean,\n  x: number, y: number,\n  slackX: number, slackY: number,\n  isElementSVG: boolean,\n  prevPropsPosition: ?ControlPosition,\n};\n\nexport type DraggableDefaultProps = {\n  ...DraggableCoreDefaultProps,\n  axis: 'both' | 'x' | 'y' | 'none',\n  bounds: Bounds | string | false,\n  defaultClassName: string,\n  defaultClassNameDragging: string,\n  defaultClassNameDragged: string,\n  defaultPosition: ControlPosition,\n  scale: number,\n};\n\nexport type DraggableProps = {\n  ...DraggableCoreProps,\n  ...DraggableDefaultProps,\n  positionOffset: PositionOffsetControlPosition,\n  position: ControlPosition,\n};\n\nclass Draggable extends React.Component<DraggableProps, DraggableState> {\n    // ...\n  onDrag: DraggableEventHandler = (e, coreData) => {\n    if (!this.state.dragging) return false;\n    log('Draggable: onDrag: %j', coreData);\n\n    const uiData = createDraggableData(this, coreData);\n\n    const newState = {\n      x: uiData.x,\n      y: uiData.y,\n      slackX: 0,\n      slackY: 0,\n    };\n// ...\n```\n\n`DraggableProps` 보면 드래그 하는 상태(dragging, dragged)와 엘리먼트 위치(x, y)를 확인할 수 있다. 또 드래그 이벤트 구현체인 `onDrag` 메서드에서 `createDraggableData` 함수를 이용해 엘리먼트 위치를 업데이트한다.\n\n`createDraggableData` 함수는 현재 위치, 이동한 델타 값 그리고 마지막 위치를 반환하고 있다.\n\n```tsx\n// /lib/utils.positionFns.js\n\nexport function createDraggableData(draggable: Draggable, coreData: DraggableData): DraggableData {\n  const scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + (coreData.deltaX / scale),\n    y: draggable.state.y + (coreData.deltaY / scale),\n    deltaX: (coreData.deltaX / scale),\n    deltaY: (coreData.deltaY / scale),\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n```\n\n이를 통해 알 수 있는 것은 아이템의 현재 위치, 이동한 델타 값, 마지막 위치를 활용해서 위치를 업데이트 하는 것을 알 수 있다.\n\n**아이템 위치 업데이트하기**\n\n아이템의 현재 위치, 이동한 델타 값은 마우스 이벤트에서 제공하는 뷰포트의 좌표값인 `clientX`, `clientY` 를 사용하면 된다.\n\n먼저 마우스가 이동한 델타값을 구해보자. `현재 마우스 위치 - 마지막 마우스 위치` 을 계산하면 된다.\n\n아이템의 위치는 아이템의 좌측 상단의 값으로 계산해줘야 한다. 아이템은 transform을 이용해 업데이트 하는데 transform의 기준은 아이템의 좌측 상단이기 때문이다. `현재 좌측 상단의 값 + 델타값` 을 계산하면 된다.\n\n![드래그 위치](./드래그-위치.png)\n\n## 상세 구현 내용\n\n### 드래그 앤 드롭이벤트 구현하기\n\n드래그 앤 드롭 이벤트를 구현하기 위해 `isDragging`인 상태를 추가했다. 이 상태 값이 true인 경우 `handleDrag` 를 실행시킨다.\n\n```tsx\nconst [isDragging, setIsDragging] = useState(false);\nconst ref = useRef<HTMLDivElement>(null);\n\nconst handleDragStart = () => {\n  setIsDragging(true);\n};\n\nconst handleDragStop = () => {\n  if (!isDragging) return;\n\n  setIsDragging(false);\n};\n\nconst handleDrag = () => {\n  if (!ref.current) return;\n  if (!isDragging) return;\n\n  // TODO: 아이템 위치 업데이트\n};\n\nuseEffect(() => {\n  if (isDragging) {\n    document.addEventListener('mousemove', handleDrag);\n  }\n\n  return () => {\n    document.removeEventListener('mousemove', handleDrag);\n  };\n}, [isDragging]);\n\nreturn (\n    <div\n      ref={ref}\n      onMouseDown={handleDragStart}\n      onMouseUp={handleDragStop}\n    >\n      {children}\n    </div>\n  );\n}\n```\n\n### 아이템 위치 업데이트 하기\n\n아이템 위치를 업데이트하기 위해 아이템의 현재 위치, 이동한 델타 값, 마지막 위치 값이 필요하다.\n\n아이템의 현재 위치와 마지막 위치 정보를 저장하기 위해 `position` 과 `last` 상태 값을 추가했다.\n\n```tsx\n// 아이템 위치\nconst [position, setPosition] = useState({\n  x: 0,\n  y: 0,\n});\n// 마지막 위치\nconst [last, setLast] = useState({\n  x: defaultPosition.x,\n  y: defaultPosition.y,\n});\n```\n\n마우스가 이동한 델타 값은 현재 마우스 위치 - 마지막 마우스 위치 로 구할 수 있다.\n\n```tsx\nconst deltaX = e.clientX - last.x;\nconst deltaY = e.clientY - last.y;\n```\n\n마지막으로 아이템의 위치를 업데이트할 값인 좌측 상단의 값은 `현재 좌측 상단의 값 + 델타값` 로 구하면 된다.\n\n```tsx\nconst deltaX = position.x + e.clientX - last.x;\nconst deltaY = position.y + e.clientY - last.y;\n```\n\n구한 delta값으로 아이템의 위치를 업데이트 하면 끝이다.\n\n```tsx\nref.current.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n```\n\n전체 코드는 이렇다.\n\n```tsx\nconst [isDragging, setIsDragging] = useState(false);\n// 아이템 위치\nconst [position, setPosition] = useState({\n  x: 0,\n  y: 0,\n});\n// 마지막 위치\nconst [last, setLast] = useState({\n  x: defaultPosition.x,\n  y: defaultPosition.y,\n});\nconst ref = useRef<HTMLDivElement>(null);\n\nconst handleDragStart = (\n  e: MouseEvent | React.MouseEvent<HTMLDivElement, MouseEvent>\n) => {\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  setIsDragging(true);\n};\n\nconst handleDragStop = (\n  e: MouseEvent | React.MouseEvent<HTMLDivElement, MouseEvent>\n) => {\n  if (!isDragging) return;\n\n  setIsDragging(false);\n};\n\nconst handleDrag = (e: MouseEvent) => {\n  if (!ref.current) return;\n  if (!isDragging) return;\n  e.preventDefault();\n\n  const deltaX = e.clientX - last.x + position.x;\n  const deltaY = e.clientY - last.y + position.y;\n\n  setPosition({ x: deltaX, y: deltaY });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n\n  ref.current.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n};\n\nuseEffect(() => {\n  if (isDragging) {\n    document.addEventListener('mousemove', handleDrag);\n  }\n\n  return () => {\n    document.removeEventListener('mousemove', handleDrag);\n  };\n}, [isDragging]);\n\nreturn (\n    <div\n      ref={ref}\n      style={{\n        position: 'absolute',\n        top: defaultPosition.y,\n        left: defaultPosition.x,\n      }}\n      onMouseDown={handleDragStart}\n      onMouseUp={handleDragStop}\n    >\n      {children}\n    </div>\n  );\n}\n```\n\n### 화면 밖으로 벗어나지 않기\n\n드래그는 이제 잘 된다! 그러나 아이템이 화면 밖으로 벗어나는 문제점이 있다. 상하좌우 밖으로 벗어나지 않도록 개선해보자.\n\n![화면 밖으로 나가기](./화면-밖으로-나가기.png)\n\n**상단 밖으로 벗어나는 경우**\n\n`아이템의 초기 y + 델타 y` 이 0보다 작은 경우 상단 밖으로 벗어나는 케이스이다. 아이템을 상단에 고정시키기 위해 `-아이템의 초기 y` 로 위치를 업데이트 하면 된다.\n\n```tsx\nconst fixToTop = (ref: HTMLDivElement) => {\n  setPosition({ x: deltaX, y: -defaultPosition.y });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  ref.style.transform = `translate(${deltaX}px, ${-defaultPosition.y}px)`;\n};\n```\n\n**하단 밖으로 벗어나는 경우**\n\n`아이템의 초기 y + 델타 y + 아이템의 높이` 가 뷰포트의 높이보다 큰 경우 하단 밖으로 벗어나는 케이스이다. 아이템을 하단에 고정시키기 위해 `뷰포트 높이 - 아이템 높이 - 아이템의 초기 y` 로 위치를 업데이트 하면 된다.\n\n```tsx\nconst eleHeight = ref.current.clientHeight || 0;\n\nconst fixToBottom = (ref: HTMLDivElement) => {\n  setPosition({\n    x: deltaX,\n    y: window.innerHeight - eleHeight - defaultPosition.y,\n  });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  ref.style.transform = `translate(${deltaX}px, ${\n    window.innerHeight - eleHeight - defaultPosition.y\n  }px)`;\n};\n```\n\n**좌측 밖으로 벗어나는 경우**\n\n아이템이 상단 밖으로 벗어나는 경우처럼 계산하면 된다.\n\n```tsx\nconst fixToLeftTop = (ref: HTMLDivElement) => {\n  setPosition({ x: -defaultPosition.x, y: -defaultPosition.y });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  ref.style.transform = `translate(${-defaultPosition.x}px, ${-defaultPosition.y}px)`;\n};\n```\n\n**우측 밖으로 벗어나는 경우**\n\n아이템이 하단 밖으로 벗어나는 경우처럼 계산하면 된다.\n\n```tsx\nconst eleWidth = ref.current.clientWidth || 0;\n\nconst fixToRight = (ref: HTMLDivElement) => {\n  setPosition({\n    x: window.innerWidth - eleWidth - defaultPosition.x,\n    y: deltaY,\n  });\n  setLast({\n    x: e.clientX,\n    y: e.clientY,\n  });\n  ref.style.transform = `translate(${\n    window.innerWidth - eleWidth - defaultPosition.x\n  }px, ${deltaY}px)`;\n};\n```\n\n여기서 대각선 방향으로 벗어나는 경우까지 추가하면 외부로 벗어나지 않는 드래그 이벤트를 구현할 수 있다.\n\n![드래그 이벤트 구현](./드래그-이벤트-구현.gif)\n\n## 마무리\n\n드래그 이벤트를 구현하면서 뷰포트, 마우스 좌표값을 활용하는 것을 익힐 수 있었다. 또한 라이브러리 의존성을 성공적으로 제거하여 구현 능력을 키울 수 있었다.\n"},{"id":"9fd83ddc-1461-567a-b98f-06ea260bba3b","frontmatter":{"title":"useQuery를 만들어보자","slug":"/useQuery를 만들어보자","thumbnail":null},"body":"\n## 들어가며\n\nReact Query는 제가 애정하는 라이브러리 중 하나입니다. 데이터 패칭 상태 관리를 마법 처럼 우아하게 처리하고 캐싱을 통해 불필요한 네트워크 요청을 줄여 리소스를 절약할 수도 있습니다. 예전에는 `useEffect`로 구현했는데 반복되는 중복 코드때문에 고민이 많았던 기억이 납니다.\n\n그런데 React Query에 너무 익숙해진 나머지, 정작 `useEffect`로 데이터 패칭을 구현하는 방법을 잊어버렸습니다. 그래서 이번에는 `useQuery` 훅을 직접 구현해보며 학습한 과정을 정리해보겠습니다.\n\n## 구현 목표\n\n이렇게 4가지를 구현해보았습니다.\n\n1. 상태 관리: `isPending`, `isError`, `data` 상태를 관리\n2. 경쟁 상태 방지: 여러번의 요청이 발생해도 최신 데이터만 화면에 보여지도록 보장\n3. 캐싱: 캐싱된 데이터가 있으면 이를 우선적으로 보여주고, 데이터가 stale한 상태라면 새로운 데이터를 패치\n4. retry 지원: 네트워크 요청 실패 시, 지정된 횟수만큼 재시도 할 수 있음\n\n## 구현 과정\n\n### 1. 상태 관리\n\n`useEffect`를 사용해 `isPending`, `isError`, `data` 상태를 관리하는 기능을 구현하면서 무한 렌더링에 빠졌습니다.\n\n`useEffect` 로직 내부에서 `queryKey`와 `queryFn`을 참조하여 `react-hooks` 린터 규칙에 따라 의존성 배열에 두 변수를 포함해야 합니다. 하지만 `queryFn`을 포함하면 무한 렌더링이 발생합니다.\n\n이는 `queryFn`이 리렌더링이 될때마다 **새로운 객체로 평가**되기 때문에 무한 렌더링에 빠지게 됩니다. 그래서 이를 방지하기 위해 의존성 배열에 `queryKey`만 포함했습니다.\n\n```tsx\n// useQuery.ts\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype UseQueryProps<T = any> = {\n  queryKey: string;\n  queryFn: () => Promise<T>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useQuery<TData = any, TError = any>({\n  queryKey,\n  queryFn,\n}: UseQueryProps) {\n  const [isPending, setIsPending] = useState(true);\n  const [data, setData] = useState<TData | undefined>();\n  const [error, setError] = useState<TError | undefined>();\n\n  useEffect(() => {\n    setIsPending(true);\n    setData(undefined);\n    setError(undefined);\n\n    try {\n      const result = await queryFn();\n      setData(result);\n      setError(undefined);\n      setIsPending(false);\n    } catch (error) {\n      setData(undefined);\n      setError(error as TError);\n      setIsPending(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [queryKey]);\n\n  return {\n    isPending,\n    error,\n    data,\n  };\n}\n```\n\n### 2. 경쟁 상태 방지\n\n![경쟁상태](./race-condition.png)\n\n만약에 동시에 여러 번의 요청이 발생했을 때 첫 번째 요청이 나중에 완료되면 두 번째 요청의 결과를 덮어씁니다.\n\n이를 방지하기 위해 현재 컴포넌트가 활성상태인지 나타내는 `active` flag를 통해 해결할 수 있습니다.\n\n새로운 요청이 발생할 때마다 `active`플래그를 `true`로 설정하고, 기존 요청에 대해서 클린업 함수를 실행해 `false`로 설정해 기존 요청의 결과를 무시합니다. 그러면 항상 마지막으로 요청한 요청에 대해서만 상태를 업데이트 하도록 보장할 수 있습니다.\n\n```tsx\n// useQuery.ts\n\nuseEffect(() => {\n  let active = true;\n  setIsPending(true);\n  setData(undefined);\n  setError(undefined);\n\n  const handleResult = (result: TData) => {\n    // 활성 상태가 아님\n    if (!active) return;\n\n    setData(result);\n    setError(undefined);\n    setIsPending(false);\n  };\n\n  const handleError = (error: TError) => {\n    // 활성 상태가 아님\n    if (!active) return;\n\n    setData(undefined);\n    setError(error as TError);\n    setIsPending(false);\n  };\n\n  try {\n    const result = await queryFn();\n    handleResult(result);\n  } catch (error) {\n    handleError(error as TError);\n  }\n\n  return () => {\n    active = false;\n  };\n}, [queryKey]);\n```\n\n### 3. retry 구현\n\n네트워크 요청 실패 시, `MAXIMUM_RETRY`만큼 재시도하도록 재귀적으로 `fetchWithRetry`를 호출했습니다.\n\n```tsx\n// useQuery.ts\n\n// ...\nconst fetchWithRetry = async (retry = 0) => {\n  try {\n    const result = await queryFn();\n    handleResult(result);\n  } catch (error) {\n    if (retry + 1 < MAXIMUM_RETRY) {\n      fetchWithRetry(retry + 1);\n    } else {\n      handleError(error as TError);\n    }\n  }\n};\n\nif (retry) {\n  fetchWithRetry();\n} else {\n  fetchWithoutRetry();\n}\n```\n\n### 4. cache 구현\n\n캐시를 관리하기 위해 싱글톤 클래스를 사용해 다른 useQuery에서도 동일한 캐시 데이터에 데이터를 저장할 수 있도록 했습니다.\n\nqueryKey를 기준으로 데이터를 저장하고 유효한 cacheTime 과 함께 데이터를 저장해 데이터를 읽었을 때 stale하다면 삭제하도록 했습니다.\n\n```tsx\n// queryCache.ts\n\ninterface CacheData<TData> {\n  createdAt: Date; // 데이터 생성 시간\n  cacheTime: number;\n  value: TData;\n}\n\nexport class QueryCache<TData> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private static instance: QueryCache<any>;\n  private cache: Record<string, CacheData<TData>> = {};\n\n  private constructor() {}\n\n  static getInstance<TData>(): QueryCache<TData> {\n    if (!QueryCache.instance) {\n      QueryCache.instance = new QueryCache();\n    }\n    return QueryCache.instance;\n  }\n\n  writeCache({\n    key,\n    value,\n    cacheTime,\n  }: {\n    key: string;\n    value: TData;\n    cacheTime: number;\n  }) {\n    this.cache[key] = { value, createdAt: new Date(), cacheTime };\n  }\n\n  readCache(key: string) {\n    if (key in this.cache) {\n      const cachedItem = this.cache[key];\n      const isStale =\n        new Date().getTime() - cachedItem.createdAt.getTime() >\n        cachedItem.cacheTime;\n      if (isStale) {\n        // 데이터 삭제\n        this.#deleteCache(key);\n        return null;\n      } else {\n        return cachedItem;\n      }\n    }\n    return null;\n  }\n\n  #deleteCache(key: string): void {\n    delete this.cache[key];\n  }\n}\n```\n\n```tsx\n// useQuery.ts\n\n// ...\nconst handleResult = (result: TData) => {\n  // 활성 상태가 아님\n  if (!active) return;\n\n  // 캐시에 저장\n  if (cache) {\n    queryCache.writeCache({ key: queryKey, value: result, cacheTime });\n  }\n\n  setData(result);\n  setError(undefined);\n  setIsPending(false);\n};\n\n// ...\nconst cachedData = queryCache.readCache(queryKey);\nif (cache && cachedData) {\n  setData(cachedData.value as TData);\n  setIsPending(false);\n  setError(undefined);\n} else {\n  if (retry) {\n    fetchWithRetry();\n  } else {\n    fetchWithoutRetry();\n  }\n}\n```\n\n### 전체코드\n\n```tsx\n// queryCache.ts\n\ninterface CacheData<TData> {\n  createdAt: Date; // 데이터 생성 시간\n  cacheTime: number;\n  value: TData;\n}\n\nexport class QueryCache<TData> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private static instance: QueryCache<any>;\n  private cache: Record<string, CacheData<TData>> = {};\n\n  private constructor() {}\n\n  static getInstance<TData>(): QueryCache<TData> {\n    if (!QueryCache.instance) {\n      QueryCache.instance = new QueryCache();\n    }\n    return QueryCache.instance;\n  }\n\n  writeCache({\n    key,\n    value,\n    cacheTime,\n  }: {\n    key: string;\n    value: TData;\n    cacheTime: number;\n  }) {\n    this.cache[key] = { value, createdAt: new Date(), cacheTime };\n  }\n\n  readCache(key: string) {\n    if (key in this.cache) {\n      const cachedItem = this.cache[key];\n      const isStale =\n        new Date().getTime() - cachedItem.createdAt.getTime() >\n        cachedItem.cacheTime;\n      if (isStale) {\n        // 데이터 삭제\n        this.#deleteCache(key);\n        return null;\n      } else {\n        return cachedItem;\n      }\n    }\n    return null;\n  }\n\n  #deleteCache(key: string): void {\n    delete this.cache[key];\n  }\n}\n```\n\n```tsx\n// useQuery.ts\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype UseQueryProps<T = any> = {\n  queryKey: string;\n  queryFn: () => Promise<T>;\n  cache?: boolean;\n  cacheTime?: number;\n  retry?: boolean;\n};\n\nconst MAXIMUM_RETRY = 5; // 최대 retry 횟수\nconst DEFAULT_CACHE_TIME = 60 * 1000; // 캐시 디폴트 저장 시간, 1분\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useQuery<TData = any, TError = any>({\n  queryKey,\n  queryFn,\n  cache,\n  cacheTime = DEFAULT_CACHE_TIME,\n  retry,\n}: UseQueryProps) {\n  const [isPending, setIsPending] = useState(true);\n  const [data, setData] = useState<TData | undefined>();\n  const [error, setError] = useState<TError | undefined>();\n  const queryCache = useMemo(() => QueryCache.getInstance(), []);\n\n  useEffect(() => {\n    let active = true;\n    setIsPending(true);\n    setData(undefined);\n    setError(undefined);\n\n    const handleResult = (result: TData) => {\n      // 활성 상태가 아님\n      if (!active) return;\n\n      // 캐시에 저장\n      if (cache) {\n        queryCache.writeCache({ key: queryKey, value: result, cacheTime });\n      }\n\n      setData(result);\n      setError(undefined);\n      setIsPending(false);\n    };\n\n    const handleError = (error: TError) => {\n      // 활성 상태가 아님\n      if (!active) return;\n\n      setData(undefined);\n      setError(error as TError);\n      setIsPending(false);\n    };\n\n    const fetchWithRetry = async (retry = 0) => {\n      try {\n        const result = await queryFn();\n        handleResult(result);\n      } catch (error) {\n        if (retry + 1 < MAXIMUM_RETRY) {\n          fetchWithRetry(retry + 1);\n        } else {\n          handleError(error as TError);\n        }\n      }\n    };\n\n    const fetchWithoutRetry = async () => {\n      try {\n        const result = await queryFn();\n        handleResult(result);\n      } catch (error) {\n        handleError(error as TError);\n      }\n    };\n\n    const cachedData = queryCache.readCache(queryKey);\n    if (cache && cachedData) {\n      setData(cachedData.value as TData);\n      setIsPending(false);\n      setError(undefined);\n    } else {\n      if (retry) {\n        fetchWithRetry();\n      } else {\n        fetchWithoutRetry();\n      }\n    }\n\n    return () => {\n      active = false;\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [queryKey, cache, cacheTime, retry]);\n\n  return {\n    isPending,\n    error,\n    data,\n  };\n}\n```\n"},{"id":"81103934-4eeb-5da0-9dd1-5d141cde9e49","frontmatter":{"title":"FSD로 코드 경계 그리기","slug":"/FSD로 코드 경계 그리기","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVR42p2SW0/CQBCF+f+PvvkffNcXEx40GhVjQA0aDchFLi0tO5dtwZjjtIsGiAXjw6Sd2d1vz5zZGovgwzPO3zIcNJYYJorcC4q6WKgKiBW3fUZKAq+hXhW19YSZDMQbG1QCvBcX4JDvBzJD/QI+hxV1a5NH6gStcY7UlOp+haZIc7iojVn3GDSPSiVEVH5dMoBLx5gkjLlzZRflmgUzVwEXcNMmZq9HEIos97ZIEFOt4zo0urE8K2Gi+r+WVTOL3IbAq0FkcCtlfwQaIFsGmMF51gaNLsCTO8jkEvRet32JAeXXVjeB1iLFAyS9pnk4M+88OOmCpvdw8TMoeoAzMLkEztGP0moPTRn1rhFfHULnk/KCouXC22JghZflv3kiL6fQYSvUhHe1bH4tPreezdoBDkPycccunQZ4JXD9kFT4UyiOe5CoCx49Qebfr4F3ACuDQ4v9BrRzhvTxBBy9BZVbPn4BYJ6VlEM7qVUAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png","srcSet":"/static/d275c298c762d8b8e94f90601a2df767/fbddd/fsd-%EC%A0%81%EC%9A%A9.png 750w,\n/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png 867w","sizes":"100vw"},"sources":[{"srcSet":"/static/d275c298c762d8b8e94f90601a2df767/4c146/fsd-%EC%A0%81%EC%9A%A9.webp 750w,\n/static/d275c298c762d8b8e94f90601a2df767/7e940/fsd-%EC%A0%81%EC%9A%A9.webp 867w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.6228373702422145}}}},"body":"\n## 들어가며\n\n이번 프로젝트에서 코드의 유지보수성과 확장성을 높일 수 있는 FSD 아키텍처를 도입했습니다. 그 중 `createPost` 기능을 구현하며 기존 방식에서 느꼈던 문제점들과 FSD를 적용한 후 느낀 점을 회고해보려고 합니다.\n\n### FSD란?\n\nFSD는 `Feature-Sliced Design`로 코드를 **목적**에 따라 애플리케이션 구조를 잡는 아키텍처 방법론입니다. 이를 통해 **코드의 응집도를 높이고 결합도를 낮추어** 프로젝트 유지보수성을 극대화하는 데 중점을 둡니다.\n\n**FSD의 주요 개념**\n\n![fsd 계층 구조](fsd.jpg)\n\n- **레이어**: 애플리케이션의 전반적인 구조를 7가지 계층(App, Pages, Features 등)으로 나눔.\n- **슬라이스**: 각 비즈니스 도메인에 맞게 코드를 분리.\n- **세그먼트**: 슬라이스와 레이어 내에서 목적별로 코드를 분리 (예: UI, API, Model).\n\nFSD의 import 규칙은 **상위 레이어가 하위 레이어를 참조 가능**하다는 점과 **슬라이스는 Public API를 가진다**는 점이 핵심입니다.\n\n## FSD 구조를 적용한 createPost\n\nFSD를 적용하여 `createPost` 기능을 다음과 같이 구조화했습니다.\n\n### FSD 구조 적용\n\n- `pages/createPost/ui`: 페이지의 UI 구성.\n- `features/createPost/lib`: 폼 유효성 검사 로직.\n- `features/createPost/model`: 상태 관리 및 데이터 모델 정의.\n- ...\n\n```plaintext\n.\n├── entities\n│   └── post\n│       ├── api\n│       │   ├── createPostDto.ts\n│       │   └── createPost.ts\n│       └── ui\n│           └── createForm.tsx\n├── features\n│   └── createPost\n│       ├── lib\n│       │   └── validateForm.ts\n│       └── model\n│           ├── tag.ts\n│           ├── useFormState.ts\n│           └── useTagInput.ts\n└── pages\n    └── createPost\n        └── ui\n```\n\n### 기존 스타일과 비교\n\nFSD를 적용하기 전에는 코드 타입별로 폴더를 분류했습니다. 기존 방식으로 createPost 기능을 재구성하면 다음과 같은 모습입니다\n\n```\n.\n├── api\n│   └── createPost\n│       ├── index.ts\n│       └── type.ts\n├── components\n│   ├── common\n│   └── createPost\n│       └── CreateForm.tsx\n├── pages\n│   └── createPost.tsx\n├── hooks\n│   ├── useFormState.ts\n│   └── useImageInput.ts\n├── libs\n│   └── validateForm.ts\n└── types\n    └── post.ts\n```\n\n이 방식은 간단해 보이지만, 다음과 같은 문제점이 있었습니다:\n\n- 타입 관리의 혼란: 특정 타입이 여러 곳에서 사용되더라도, 어디서 관리해야 하는지 모호함.\n- 응집도 부족: 관련 코드가 분산되어, 하나의 기능을 수정하려면 여러 폴더를 오가야 했음.\n\nFSD 적용 전후의 import 관계를 대략적으로 그려보았습니다.\n\nFSD 적용 후: 기능병로 코드가 모여 있어 의존 관계가 단순해짐\n![fsd 적용](./fsd-적용.png)\n\nFSD 미적용: 코드가 분산되어 있어 의존 관계가 복잡함\n![fsd 미적용](./fsd-미적용.png)\n\n## 정리\n\nFSD는 러닝 커브가 높지만, 다음과 같은 이점을 제공합니다:\n\n1. **유지보수성 향상**: 도메인별로 코드가 나뉘어 기능 수정이 용이.\n2. **응집도 증가**: 관련 코드가 한곳에 모여 있어 가독성과 확장성이 개선.\n3. **결합도 감소**: 코드 간 의존성이 줄어 변경 사항의 영향을 최소화.\n\n---\n\n참조:\n\n- https://feature-sliced.design/docs\n- https://velog.io/@teo/fsd\n"},{"id":"6424f936-a130-507d-a274-404279f174eb","frontmatter":{"title":"Jest에선 성공인데... 브라우저에선 실패?","slug":"/Jest에선 성공인데 브라우저에선 실패","thumbnail":null},"body":"\nimport hashtagGif from './해시태그입력.gif';\n\n프로젝트에서 한글 입력 시 마지막 글자가 지워지지 않는 IME 버그를 겪었습니다. “유닛 테스트에서 잡을 수 있었다면 좋았을 텐데…” 싶어 앞으로는 TDD도 해보자는 마음으로 Jest로 폼 테스트를 학습해봤습니다.\n그런데 예상과 달리 Jest에선 이 문제가 드러나지 않고 테스트가 성공했습니다.\n\n이번 글은 그 과정에서 배운 Jest 디바운스 테스트와 API 모킹 경험, 그리고 브라우저 환경에서의 E2E 테스트가 필요한 이유를 정리한 글입니다.\n\n## 테스트할 기능\n\n테스트할 기능은 입력 후 API 호출로 메타데이터를 불러오는 기능입니다.\n\n![링크미리보기.gif](./링크미리보기.gif)\n\n1. 사용자가 링크를 입력한다.\n2. 해당 링크로 API 요청을 보내 메타데이터를 가져온다.\n3. 결과를 화면에 표시한다.\n\n여기서 입력이 변경될 때마다 불필요한 API 요청이 발생하지 않도록 `2000ms` 디바운스를 적용했습니다.\n\n### 디바운스 모방하기\n\n```jsx\nconst urlInput = screen.getByLabelText('링크');\n\nfireEvent.change(urlInput, { target: { value: 'https://www.naver.com/' } });\nawait act(async () => {\n  jest.advanceTimersByTime(2000); // 디바운스 적용\n});\n```\n\n- `jest.advanceTimersByTime(ms)` : 지정한 ms만큼 시간이 흐른 것처럼 시뮬레이션\n\n테스트 후에는 타이머를 초기화해줍니다.\n\n```jsx\nafterEach(() => {\n  jest.clearAllTimers();\n  jest.useRealTimers();\n});\n```\n\n### API 요청 mocking하기\n\n실제 API 호출을 막기 위해 msw로 응답을 모킹했습니다.\n\n```jsx\nconst handlers = [\n  rest.get(`${API_BASE_URL}/link/metadata`, (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json({\n        metaDescription: '링크 설명',\n        metaThumbnail: '링크 썸네일',\n        metaTitle: '링크 타이틀',\n        titleText: '타이틀 텍스트',\n      })\n    );\n  }),\n];\n```\n\n### 해시태그 입력 테스트하기\n\n엔터 키 입력 시 해시태그가 추가되도록 구현했습니다. 아래 이미지처럼 현재 한글로 해시태그를 입력하는 경우에는 마지막 글자인 ‘녕’이 input에 남아있는 문제가 있습니다.\n\n<img src={hashtagGif} alt='해시태그 입력' style={{ width: '100%' }} />\n\n문제 시나리오에 대해서 테스트 코드를 작성했습니다.\n\n```jsx\ndescribe('해시 태그 입력 테스트', () => {\n  test ('여러 개의 해시 태그를 입력하면, 입력한 해시 태그의 수만큼 Chip 컴포넌트가 렌더링된다.',\n  // 해시태그 추가\n  fireEvent.change(tagInput, { target: { value: '안녕' } });\n  fireEvent.keyDown(tagInput, { key: 'Enter' });\n  // input value가 빈값이어야 함\n  expect(tagInput.value).toBe(''):\n\n\n  // 연달아 새로운 해시태그 추가\n  fireEvent.change(tagInput, { target: { value: '하이' } });\n  fireEvent.keyDown(tagInput, { key: 'Enter' });\n  // input value가 빈값이어야 함\n  expect (tagInput.value).toBe('');\n  // ...\n```\n\n하지만 테스트 결과는 실패하지 않고, 성공하고 말았습니다... ![양성거짓](양성거짓.png)\n\n## Jest에서는 왜 성공할까?\n\n한글이 input에 여전히 남는 원인은 IME 입니다. `ㅇ ㅑ ㅎ ㅗ` 를 순서대로 입력하면 자음과 모음을 조합해 `야호` 를 출력합니다. 브라우저에서는 이 조합 과정을 `compositionstart`, `compositionend`같은 이벤트가 발생합니다. 하지만, Jest는 `야호’라는 value의 값을 넣었을 때, 이미 조합이 완료된 값을 넣으므로 마지막 글자가 남지 않아 해당 버그는 재현되지 않습니다.\n\n## 브라우저 E2E 테스트 필요성\n\nJest만으론 브라우저가 가진 특징을 재현하기 어려운걸 깨달았습니다. 이를 보완할 수 있는 Cypress나 Playwright와 같은 E2E 도구의 필요성을 느꼈습니다.\n\n---\n\n참고\n\n- [https://ko.wikipedia.org/wiki/입력기](https://ko.wikipedia.org/wiki/%EC%9E%85%EB%A0%A5%EA%B8%B0)\n- [https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionstart_event](https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionstart_event)\n- [https://ui.toast.com/posts/ko_20220624](https://ui.toast.com/posts/ko_20220624)\n- [https://minjung-jeon.github.io/IME-keyCode-229-issue/](https://minjung-jeon.github.io/IME-keyCode-229-issue/)\n"},{"id":"4253f32f-690c-5d73-b285-f1cf87c157ec","frontmatter":{"title":"[type-challenges] medium 도전","slug":"/type-challenges/medium","thumbnail":null},"body":"\n## **Get Return Type**\n\n### 문제\n\n내장 제네릭 `ReturnType<T>`을 이를 사용하지 않고 구현하자\n\n### 코드\n\n```\n// 아쉬운 정답\ntype MyReturnType<T extends (...args: any) => unknown> =\n  T extends (...args:any) => infer U\n      ? U\n      : never;\n```\n\n함수 인자 타입을 `never[]` 로 하면 모든 테스트 케이스가 통과된다.\n\n```\n// 정답\ntype MyReturnType<T extends (...args: never[]) => unknown> =\n  T extends (...args: never[]) => infer R\n    ? R\n    : never\n```\n\n### 해설\n\n리턴되는 타입을 `infer U`로 추론하고 U를 반환한다. 하지만 함수 인수를 받는 타입을 `unknown[]` 으로 하면 테스트 케이스가 일부만 통과해서 `any`로 변경해 모두 통과되도록 했다.\n\n**`unknown[]`이 안되는 이유**\n\n`unknown` 은 모든 타입의 상위 타입이므로 모든 타입은 `unknown`에 할당할 수 있다. 그렇기 때문에 `unknown` 은 가장 일반적인 타입이기 때문에 구체적인 타입과 호환되지 않는다.\n\n```\ntype foo = unknown extends string ? true : false; // false\n```\n\n**`never[]` 를 사용하는 이유**\n\nnever는 존재하지 않는 공집합이기 때문에 any를 포함해 어떤 값도 가질 수 없는 가장 구체적인 타입이어서 다른 타입들과 호환될 수 있다.\n\n```\ntype foo = never extends string ? true : false; // true\n```\n\n## **Omit**\n\n### 문제\n\n`T`에서 `K` 프로퍼티만 제거해 새로운 오브젝트 타입을 만드는 내장 제네릭 `Omit<T, K>`를 이를 사용하지 않고 구현하자.\n\n### 코드\n\nT의 프로퍼티 키에서 K가 아니라면 키값을 추출하는 코드를 의도했다. 이 코드는 infer의 잘못된 사용으로 동작하지 않는다.\n\n```\n// 오답\ntype MyOmit<T, K extends keyof T> = K extends infer Key keyof T ?\n  never :\n  { Key: T[Key] }\n```\n\n정답 코드는 이렇다.\n\n```\n// 정답\ntype MyOmit<T, K extends keyof T> = {[Key in keyof T as Key extends K ? never: Key]: T[Key]}\n```\n\n### 해설\n\n**`as` 키워드**\n\nas 키용해 이용해 맵드 타입의 키를 다시 매핑할 수 있다. 예를들어 모든 프로퍼티 키를 Hamster라고 키 이름을 다시 매핑할 수 있다.\n\n```\ntype MappedTypeWithNewProperties<Type> = {\n    [Properties in keyof Type as 'Hamster']: Type[Properties]\n}\n```\n\n## **Readonly 2**\n\n### 문제\n\n`T`에서 `K` 프로퍼티만 읽기 전용으로 설정해 새로운 오브젝트 타입을 만드는 제네릭 `MyReadonly2<T, K>`를 구현하세요. `K`가 주어지지 않으면 단순히 `Readonly<T>`처럼 모든 프로퍼티를 읽기 전용으로 설정해야 합니다.\n\n### 코드\n\n```\ntype MyReadonly2<T, K extends keyof T = keyof T> = { readonly [k in K]: T[k] } & Omit<T, K>;\n```\n\n### 해설\n\nK 프로퍼티는 readonly 속성을 부여하면 된다. 구현은 정답을 참고했다.\n\nK가 주어지지 않는 경우를 위해 `K extends keyof T = keyof T` default 값을 설정한다.\n\n**교차 타입 &**\n\n두 개 이상의 타입을 결합해 모든 타입의 속성을 포함하는 새로운 타입을 생성할 수 있다. `A & B`는 `A`와 `B`의 모든 속성을 포함하는 새로운 타입이 된다.\n\n**유니온 타입 |**\n\n두 개 이상의 타입 중 하나를 선택할 수 있는 새로운 타입을 생성한다. `A | B` 는 `A`또는 `B` 중 하나의 타입을 가질 수 있다.\n\n## **Deep Readonly**\n\n### 문제\n\n객체의 프로퍼티와 모든 하위 객체를 재귀적으로 읽기 전용으로 설정하는 제네릭 `DeepReadonly<T>`를 구현하세요.\n\n이 챌린지에서는 타입 파라미터 `T`를 객체 타입으로 제한하고 있습니다. 객체뿐만 아니라 배열, 함수, 클래스 등 가능한 다양한 형태의 타입 파라미터를 사용하도록 도전해 보세요.\n\n### 코드\n\n중첩된 객체 프로퍼티의 타입을 반환하는 타입은 만들었는데 다음은 어떻게 해야할까?\n\n```\n// 오답\ntype DeepReadonly<T> = T extends object ? DeepReadonly<T[keyof T]> : T\n```\n\n정답을 참고해서 `readonly` 타입을 반환하도록 했는데, 중첩된 객체에서는 `readonly`가 안된다. (아래 코드가 왜 잘못됐는지 모르겠다🥲 )\n\n```\n// 오답\ntype DeepReadonly<T> = T extends Record<PropertyKey, unknown> ?\n  { readonly [P in keyof T]: DeepReadonly<T[P]> }\n  :\n  T;\n\ntype x = DeepReadonly<{l: [\n        'hi',\n        {\n          m: ['hey']\n        },\n      ]}>;\n\n// 결과\n// type x = {\n//  readonly l: [\"hi\", {\n//      m: [\"hey\"];\n//    }];\n//  }\n\n// 기댓값\n// type x = {\n//  readonly l: readonly [\"hi\", {\n//      readonly m: readonly [\"hey\"];\n//    }];\n//  }\n```\n\n정답 코드를 보면 `T`에 프로퍼티 키로 접근할 수 있는 값이 없다면 T\\[K\\]를 반환하고 그렇지 않다면 재귀적으로 `DeepReadonly<T[K]>` 를 호출한다.\n\n```\n// 정답\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: keyof T[K] extends never ? T[K] : DeepReadonly<T[K]>\n}\n```\n\n### 해설\n\n**TypeScript 에서 `{}` vs `Object` vs `object`**\n\n- `{}` 는 빈 객체가 아닌 any non-nullsih value이므로 `undefined`, `null`을 제외한 모든 타입을 할당할 수 있다.\n- `Object` 도 `{}` 와 동일하다.\n- `object` 는 원시값을 제외한 모든 값이 할당 가능하다.\n\n빈 객체`{}` 타입만을 허용하고 싶다면 `never`를 사용하자. 자바스크립트의 객체 타입(중괄호로 이루어진 객체)만을 허용하고 싶다면 Record를 사용하면 된다.\n\n![mind](mind.jpeg)_타입스크립트는 어렵네요_\n\n## 문제 풀기에 앞서…\n\n문제 풀기에 앞서 아직 헷갈리는 내용을 짚고 넘어가보자.\n\n**정적 타입 검사:**\n\n타입스크립트는 프로그램을 실행시키지 않고 오류를 검출한다.\n\n**점진적 타입 시스템:**\n\n타입스크립트는 타입 검사를 점진적으로 적용해 동적 타입처럼 자유롭게 타입을 작성할 수 있다.\n\n```\nlet a = 10;  // 타입스크립트가 자동으로 number로 추론 (자동 타입 추론)\nlet b;       // 타입 명시가 없으므로 b는 암시적으로 any 타입을 가짐\nb = \"hello\"; // b에 어떤 값이든 할당 가능 (any 타입)\nb = 42;      // any 타입이기 때문에 타입 오류 없음\n```\n\n**구조적 타입 시스템이란:**\n\n타입스크립트 컴파일러는 두 타입의 명시적 선언이 아닌 **프로퍼티를 비교**하여 타입을 비교한다. 그러니까 타입 `Hamster`과 `Animal`이 있을 때, `Hamster` ⊂ `Animal`를 만족한다. `Hamster`의 프로퍼티는 `Animal`를 만족시키기 때문에 `Hamster`타입에 `Animal`을 할당할 수 있고 `Hamster`은 `Animal`타입과 호환이 가능하다.\n\n**Indexed Access Type:**\n\n인덱스를 사용해 객체의 프로퍼티 타입을 추출할 수 있다. 배열 요소의 타입을 가져오려면 `Foo[number]` 로 하면 된다.\n\n**infer:**\n\n조건부 타입의 `extends` 절 안에서 infer을 이용해 타입 변수를 추론할 수 있다. 이렇게 추론된 타입은 분기에서 참조될 수 있다.\n\n## **Tuple to Union**\n\n> 튜플 값으로 유니온 타입을 생성하는 제네릭 `TupleToUnion<T>`를 구현하세요.\n\n배열의 인덱스를 number로 접근해서 타입을 가져오면 된다.\n\n```\ntype TupleToUnion<T extends unknown[]> = T[number];\n```\n\n## **Chainable Options**\n\n> 체인 가능 옵션은 일반적으로 Javascript에서 사용됩니다. 하지만 TypeScript로 전환하면 제대로 구현할 수 있나요?\n>\n> 이 챌린지에서는 `option(key, value)`과 `get()` 두가지 함수를 제공하는 객체(또는 클래스) 타입을 구현해야 합니다. 현재 타입을 `option`으로 지정된 키와 값으로 확장할 수 있고 `get`으로 최종 결과를 가져올 수 있어야 합니다.\n\n너무 어려워서 정답을 봤다. R 타입은 option 메서드로 점진적으로 타입이 확장된다.\n\n```\ntype Chainable<T = object> = {\n  option<K extends PropertyKey, V>(\n    key: K extends keyof T\n         ? (V extends T[K] ? never : K)\n         : K,\n    value: V\n  ): Chainable<Omit<T, K> & Record<K, V>>; // Omit K from T\n  get(): T;\n}\n```\n\n### declare\n\n문제에서 a를 declare로 선언했는데, declare에 대해 알아보자.\n\n```\ndeclare const a: Chainable\n```\n\ndeclare는 타입이나 값을 설명하기 위해 사용할 수 있다. 변수, 객체, 함수 또는 외부 모듈 등에서 타입 정보를 제공하는 용도로 사용할 수 있다. declare 키워드로 선언된 변수는 javascript로 컴파일되지 않는다.\n\n## **Last of Array**\n\n> 배열 T를 사용하고 마지막 요소를 반환하는 제네릭 `Last<T>`를 구현합니다.\n\n`T[length - 1]` 식으로 접근하고 싶은데, 타입스크립트는 런타입 값을 알 수 없기 때문에 계산이 안된다.\n\n정답 코드에서는 새로운 배열을 만들고, 이 배열의 `T['length']` 를 접근한다.\n\n```\ntype Last<T extends unknown[]> = [unknown, ...T][T[\"length\"]]\n```\n\n## **Pop**\n\n> 배열 T를 사용해 마지막 요소를 제외한 배열을 반환하는 제네릭 `Pop<T>`를 구현합니다.\n\ninfer로 추론하고 P를 반환하면 된다.\n\n```\ntype Pop<T extends unknown[]> = T extends [...infer P, unknown] ? P : [];\n```\n\n### Shift, Push, Unshift 구현하기\n\n```\ntype Shift<T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push<T extends unknown[], X> = [...T, X];\n\ntype Unshift<T extends unknown[], X> = [X, ...T];\n```\n\n## **Promise.all**\n\n> Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array.\n\n09번은 너무 어려워서 패스하고 다음에 도전해본다!\n\n## **Type Lookup**\n\n> 때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다.\n>\n> 이 챌린지에서는 유니온 타입 `Cat | Dog`에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 `LookUp<Cat | Dog, 'dog'>`으로 Dog 타입을,` LookUp<Cat | Dog, 'cat'>`으로 `Cat` 타입을 얻을 수 있습니다.\n\n```\ntype LookUp<U, T> = U extends { type: T } ? U : never;\n```\n\n### Shift, Push, Unshift 구현하기\n\n```\ntype Shift<T extends unknown[]> = T extends [unknown, ...infer P] ? P : [];\n\ntype Push<T extends unknown[], X> = [...T, X];\n\ntype Unshift<T extends unknown[], X> = [X, ...T];\n```\n\n## **Promise.all**\n\n> Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array.\n\n09번은 너무 어려워서 패스하고 다음에 도전해본다!\n\n## **Type Lookup**\n\n> 때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다.\n>\n> 이 챌린지에서는 유니온 타입 `Cat | Dog`에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 `LookUp<Cat | Dog, 'dog'>`으로 Dog 타입을, `LookUp<Cat | Dog, 'cat'>`으로 Cat 타입을 얻을 수 있습니다.\n\n```\ntype LookUp<U, T> = U extends { type: T } ? U : never;\n```\n\n## **Trim Left**\n\n> 정확한 문자열 타입이고 시작 부분의 공백이 제거된 새 문자열을 반환하는 TrimLeft를 구현하십시오.\n\n빈 공백을 제거하고 재귀적으로 trim을 하려고 했는데 U는 string이 아니라 배열 타입이 되므로 오답이다.\n\n```\ntype TrimLeft<S extends string> = S[number] extends [' ', ...infer U] ?  TrimLeft<U> : S;\n```\n\n리터럴을 이용해 처리할 수 있다.\n\n```\ntype Space = ' ' | '\\t' | '\\n';\ntype TrimLeft<S extends string> = S extends `${Space}${infer U}` ?  TrimLeft<U> : S;\n```\n\n## **Trim**\n\n> 정확한 문자열 타입이고 양쪽 끝의 공백이 제거된 새 문자열을 반환하는 Trim를 구현하십시오.\n\nTrimLeft 코드에서 분기 처리를 추가하면 된다.\n\n```\ntype Space = ' ' | '\\t' | '\\n';\n\ntype Trim<S extends string> = S extends `${Space}${infer U}`\n  ? Trim<U>\n  : S extends `${infer T}${Space}`\n  ? Trim<T>\n  : S;\n```\n\n유니언으로 처리하면 더 깔끔하게 처리할 수 있다.\n\n```\ntype Space = ' ' | '\\t' | '\\n';\n\ntype Trim<S extends string> = S extends `${Space}${infer T}` | `${infer T}${Space}` ? Trim<T> : S;\n```\n\n## **Capitalize**\n\n> 문자열의 첫 글자만 대문자로 바꾸고 나머지는 그대로 놔두는 Capitalize를 구현하세요.\n\nCapitalize 인터페이스를 사용하면 된다.\n\n```\ntype MyCapitalize<S extends string> = S extends `${infer X}${infer T}` ? `${Capitalize<X>}${T}` : S;\n```\n\n**Replace**\n\n> 문자열 S에서 From를 찾아 한 번만 To로 교체하는 `Replace<S, From, To>`를 구현하세요.\n\n리터럴 타입을 이용해 조건부로 넘겼지만, From이 `''` 케이스인 경우 통과하지 않는다.\n\n```\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string\n> = S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;\n```\n\nFrom이 공백 문자열인지 확인하는 분기를 추가하면 된다.\n\n```\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends ''\n  ? S\n  : S extends `${From}${infer T}`\n  ? `${To}${T}`\n  : S extends `${infer T}${From}${infer X}`\n  ? `${T}${To}${X}`\n  : S;\n```\n\n## **ReplaceAll**\n\n> 주어진 문자열 S에서 부분 문자열 From을 찾아 모두 To로 교체하는 제네릭 `ReplaceAll<S, From, To>`을 구현하세요.\n\nReplace 코드에 재귀적으로 타입을 호출했는데, 이미 교체한 문자열에도 교체를 진행해 `foobarfoobar` 테스트 케이스를 통과하지 못한다.\n\n```\ntype ReplaceAll<\n  S extends string,\n  From extends string,\n  To extends string\n> = From extends ''\n  ? S\n  : S extends `${infer T}${From}${infer X}`\n  ? ReplaceAll<`${T}${To}${X}`, From, To>\n  : S extends `${From}${infer T}`\n  ? ReplaceAll<`${To}${T}`, From, To>\n  : S;\n```\n\n리터럴 타입 내부에서 ReplaceAll 타입을 재귀적으로 호출하면 된다.\n\n```\ntype ReplaceAll<S extends string, From extends string, To extends string> = From extends ''\n  ? S\n  : S extends `${infer R1}${From}${infer R2}`\n  ? `${R1}${To}${ReplaceAll<R2, From, To>}`\n  : S\n```\n\n## **Append Argument**\n\n> 함수 타입 Fn과 어떤 타입 A가 주어질 때 Fn의 인수와 A를 마지막 인수로 받는 Fn과 동일한 함수 유형인 G를 생성하세요.\n\nFn의 인자 타입을 추론하고 A를 추가하고자 아래처럼 작성했는데, 문법상에 오류가 있다.\n\n```\ntype AppendArgument<Fn extends (...args: any[]) => unknown, A> = Fn extends (...X: any[]) => unknown ? (...X, A) => unknown : false;\n```\n\narguments를 올바르게 타입을 추론하면 된다.\n\n```\ntype AppendArgument<Fn, A> = Fn extends (...args: infer T) => infer U ? (...arg: [...T, A]) => U : never;\n```\n\n**arguments 객체**\n\narguments 객체는 함수에 전달된 인수에 해당하는 Array 형태의 객체이다.\n\n```\nfunction foo(a, b, c){\n    console.log(arguments[0] === a);\n    console.log(arguments[1] === b);\n    console.log(arguments[2] === c);\n}\n```\n\n---\n\n타입 챌린지는 임시 중단합니다.\n\n다양한 타입을 만드는건 재미있지만 자주 쓰이는 케이스로 타입스크립트를 학습하겠습니다~\n"},{"id":"fcaa218a-3740-5fb5-872b-4ca73addb772","frontmatter":{"title":"[type-challenges] easy 도전","slug":"/type-challenges/easy","thumbnail":null},"body":"\n## PICK-4\n\n### 문제\n\npick을 사용하지 않고 Pick을 구현하는 문제이다.\n\n- `keyof` 는 객체의 키 값들을 숫자나 문자열 리터럴 유니언을 생성한다.\n- `in` 는 객체에 특정 속성이 존재하는지 확인할 수 있다.\n\n### 코드\n\n```\ntype MyPick<T, K extends keyof T> = {\n  [k in K]: T[k]\n}\n```\n\n### 풀이\n\n`K extends keyof T` K는 T의 프로퍼티 이름을 가진다. 매핑된 타입을 이용하면 키를 통해 타입을 반복적으로 생성할 수 있고 인덱스 시그니처 문법으로 작성하면 된다.\n\n## Readonly\n\n### 문제\n\nReadonly 타입을 사용하지 않고 구현하는 문제이다.\n\n- `readonly` 는 프로퍼티를 읽기 전용으로 지정할 수 있다.\n\n### 코드\n\n```\ntype MyReadonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n```\n\n## **Tuple to Object**\n\n### 문제\n\n각 원소의 값을 key/value로 갖는 오브젝트 타입을 반환하는 타입을 구현하는 문제이다.\n\n```\n// 배열의 원소의 값을 key/value로 갖는 타입을 반환한다.\n['tesla', 'model 3', 'model X', 'model Y']\n\n{ 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}\n```\n\n### 코드\n\n```\ntype TupleToObject<T extends readonly PropertyKey[]> = {\n  [P in T[number]] : P\n}\n```\n\n### 풀이\n\n- 배열 순회하기: `T[number]`을 통해 배열을 순회하여 타입을 가져올 수 있다. `T[number]` 은 인덱스가 숫자형인 요소들의 타입을 가져오므로 배열에 있는 모든 요소의 타입을 가져올 수 있다.\n- PropertyKey: `keyof` 를 통해 생성되는 key의 집합이다. 여기에는 string, number, symbol이 있다.\n\n## **First of Array**\n\n### 문제\n\n`T`를 받아 첫번째 원소의 타입을 반환하는 제네릭 `First<T>`를 구현하는 문제이다.\n\n### 코드\n\n```\n// 오답: 빈 배열인 경우 T[0]은 undefeind가 된다\ntype First<T extends any[]> = T[0] extends never ? never : T[0]; // 원소가 없다면 never 타입 반환\n\n// 정답1\ntype First<T extends unknown[]> = T[number] extends never ? never : T[0];\n// 정답2\ntype First<T extends unknown[]> = T extends [] ? never : T[0];\n```\n\n### 풀이\n\n- 조건부 타입: 배열이 빈 배열이라면 `never` 타입을 반환한다.\n\n## **Length of Tuple**\n\n### 문제\n\n튜블(배열)의 길이를 반환하는 제네릭 타입을 구현하는 문제이다.\n\n### 코드\n\n```\n// 오답: Length<5>인 경우 타입 에러가 나지 않는다.\ntype Length<T> = T extends readonly unknown[] ? T['length'] : never;\n```\n\n`<T extends readonly unknown[]>` 는 T가 `readonly unknown[ ]`이라는 타입을 반드시 만족해야 하므로 배열이 아닌 경우 타입 에러를 발생한다.\n\n```\n// 정답\ntype Length<T extends readonly unknown[]> = T[\"length\"];\n```\n\n### 풀이\n\n- `readonly`: 튜플은 고정된 요소를 저장하므로 readonly이다.\n\n`T extends readonly unknown[]` 에서 T가 배열 타입인지 조건부로 타입을 할당한다. 이런 경우 배열이 아닌 경우 `never`를 반환하기 때문에 타입 에러가 나지 않는다.\n\n## **Exclude**\n\n### 문제\n\nT에서 U에 할당할 수 있는 타입을 제외하는 내장 제네릭 Exclude를 사용하지 않고 구현하는 문제이다.\n\n### 코드\n\n```\ntype MyExclude<T, U> = T extends U ? never : T;\n```\n\n### 풀이\n\n- `Exclude`: `Exclude<T, U>` 는 U에 할당할 수 있는 타입을 제외한다. 차집합으로 이해할 수 있다.\n- 분배법칙: 조건부 타입에서 분배법칙이 적용된다. 예를 들어 `A | B | C extends U ? X : Y` 는 `A extends U ? X : Y`, `B extends U ? X : Y`, `C extends U ? X : Y` 가 된다. `T extends U ? X : Y` 에서 T 유니언 타입은 개별 구성 요소를 확인한다.\n\nT가 U에 속한다면, never를 반환한다.\n\n## **Awaited**\n\n### 문제\n\nPromise와 같은 타입에 감싸인 타입이 있을 때, 안에 감싸인 타입이 무엇인지 가르키는 타입을 구현하는 문제이다.\n\n### 코드\n\n```\ntype MyAwaited<T> = T extends PromiseLike<infer D> ? MyAwaited<D> : T;\n```\n\n### 풀이\n\nPromise에 감싸진 리턴 타입을 반환하기 위해 T가 Promise라면 Promise를 재귀적으로 풀어주고 그렇지 않다면 T를 반환하면 된다.\n\n예를 들어 타입 `X`에서 Promise로 감싸진 타입을 가져올 때 다음처럼 동작한다.\n\n```\ntype MyAwaited<T> = T extends PromiseLike<infer D> ? MyAwaited<D> : T;\n\ntype X = Promise<string>\ntype Foo = MyAwaited<X> // string\n```\n\n`MyAwaited<Promise<string>>`은 `PromiseLike<infer D>`타입에 해당하므로 다시 `MyAwaited<D>` 을 호출한다. 여기서 `infer D` 로 string을 추론한다. `MyAwaited<string>` 은 `PromiseLike`타입이 아니므로 타입 `string`을 반환한다.\n\n### `infer`란?\n\n조건부 타입에서 `infer` 키워드를 이용해 새로운 타입 변수를 선언적으로 정의할 수 있다. `type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;`\n\n### `Promise`가 아닌 `PromiseLike`를 사용하는 이유\n\n`Promise`가 아닌 `PromiseLike`를 사용하는 이유는 아래 테스트 케이스가 존재하기 때문이다.\n\n```\ntype T = { then: (onfulfilled: (arg: number) => any) => any }\n```\n\n`PromiseLike`타입에는 후속처리 메서드인 then만 가지고 있다. 이를 통해 커스텀 비동기 처리를 유연하게 정의할 수 있다.\n\n```\n// https://github.com/microsoft/TypeScript/blob/main/src/lib/es5.d.ts\n\ninterface PromiseLike<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n      ): PromiseLike<TResult1 | TResult2>;\n}\n```\n\n## **If**\n\n### 문제\n\n조건 C가 참이면 A, 아니면 B를 반환하는 타입을 구현하자.\n\n### 코드\n\n```\ntype If<C extends boolean, T, F> = C extends true ? T : F;\n```\n\n### 풀이\n\nC는 true, false만 가능하도록 `boolean` 타입으로 제한하고 C 조건에 따라 T, F를 리턴하면 된다.\n\n## Concat\n\n### 문제\n\nArray.concat 함수를 타입 시스템에서 구현하자. 인수를 왼쪽부터 concat한 새로운 배열을 반환하자.\n\n### 코드\n\n```\n// 오답\ntype Concat<T extends unknown[], U extends unknown[]> = [\n  T extends [] ? never : T[number],\n  U extends [] ? never : U[number]\n];\n\ntype Foo = Concat<['1', 2, 3], []>; // [2 | 3 | \"1\", never]\n```\n\n```\n// 정답\ntype Tuple = readonly unknown[];\ntype Concat<T extends Tuple, U extends Tuple> = [...T, ...U];\n\ntype Foo = Concat<['1', 2, 3], []>; //  [\"1\", 2, 3]\n```\n\n### 풀이\n\nT와 U를 concat할 수 있도록 T와 U를 배열로 타입을 제한했다. 요소의 타입으로 이루어진 튜플을 반환할 수 있도록 `T[number]` 를 했다. 그러나 `T[number]`는 배열의 요소 타입으로 이뤄진 유니언 타입을 추출한다. 그리고 빈 배열인 경우 never 타입이 반환되므로 오답이다.\n\n여기서 T와 U를 배열타입으로 제한했으므로 열거 가능하다.\n\n## **Includes**\n\n### 문제\n\nJavaScript의 `Array.includes` 함수를 타입 시스템에서 구현하세요. 타입은 두 인수를 받고, `true` 또는 `false`를 반환하자.\n\n### 코드\n\n```\n// 오답\ntype Includes<T extends readonly unknown[], U> = U extends T[number] ? true : false;\n```\n\nT 배열의 요소를 키로 갖는 타입을 만들고 U가 T의 키인지 확인하면 해결할 수 있을 것 같지만, U가 프로퍼티 키로 사용할 수 있을 때만 통과된다. ([참고](https://github.com/type-challenges/type-challenges/issues/1568))\n\n```\n// 오답\ntype Includes<T extends readonly any[], U> = {\n  [P in T[number]]: true\n}[U] extends true ? true : false;\n```\n\n이를 해결하기 위해 배열의 첫번째 요소와 타입이 같은지 재귀적으로 타입을 확인해야 한다.\n\n```\n// 정답\ntype Includes<T extends readonly unknown[], U> =\n  T extends [infer First, ...infer Rest]\n    ? Equal<First, U> extends true ? true : Includes<Rest, U>\n    : false;\n```\n\n### 풀이\n\nU가 T의 구성 요소인지 확인하기 위해 T를 인덱스 접근 타입으로 변경하고 U가 이 유니온 타입에 속하는지 조건부로 true 또는 false를 반환한다. 그런데 이 코드는 primitive type만 통과하고 객체나 타입 자체는 통과하지 않는다. 예를 들어 `{ a: 'A'}` 는 `{ }`의 서브 타입으로 true를 반환한다.\n\n> `infer` 키워드를 복습하고 가자. `infer`은 조건부 타입에서 **참으로 평가**될 때 사용할 수 있는 타입을 추론하는 데 사용한다.\n\n참고로 `@type-challenges/utils` 의 Equal은 아래처럼 구현되어 있다.\n\n```\nEqual<X, Y> =\n    (<T>() => T extends X ? 1 : 2) extends\n    (<T>() => T extends Y ? 1 : 2) ? true : false;\n```\n\n## **Push**\n\n### 문제\n\n`Array.push`의 제네릭 버전을 구현하자.\n\n### 코드\n\n```\ntype Push<T extends unknown[], U> = [...T, U];\n```\n\n### 풀이\n\nT를 배열로 타입을 제한하고 배열 디스트럭쳐링을 이용해 배열 타입을 반환한다.\n\n## **Unshift**\n\n### 문제\n\n`Array.unshift`의 타입 버전을 구현하자.\n\n### 코드\n\n```\ntype Unshift<T extends unknown[], U> = [U, ...T];\n```\n\n### 풀이\n\nPush 문제와 동일하다. T와 U 순서만 바꿔주면 된다.\n\n## **Parameters**\n\n### 문제\n\n내장 제네릭 `Parameters<T>`를 이를 사용하지 않고 구현하자.\n\n### 코드\n\n```\ntype MyParameters<T> = T extends (...args: infer D) => unknown ? D : any;\n\nconst temp = ['1'];\ntype x = MyParameters<typeof temp>; // 타입 에러가 나지 않는다.\n```\n\n타입 에러가 나지 않는데, 이를 막으려면 타입 T를 함수로 제한하면 된다.\n\n```\ntype MyParameters<T extends (...args: any[]) => any> = T extends (...any: infer S) => any ? S : any\n```\n\n### 풀이\n\n조건부 타입으로 함수 타입이라면 args를 추론한 D 타입을 반환한다. 하지만 T타입이 함수로 제한하지 않아 함수가 아닌 타입에서 에러가 나지 않아서 아쉽다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}