<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.14.0"/><style data-href="/styles.faa02567c4b32a2dbabf.css" data-identity="gatsby-global-css">.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;word-wrap:break-word;background-color:#fff;color:#1f2328;color-scheme:light;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Noto Sans,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;margin:0}.markdown-body h1:hover .anchor .octicon-link:before,.markdown-body h2:hover .anchor .octicon-link:before,.markdown-body h3:hover .anchor .octicon-link:before,.markdown-body h4:hover .anchor .octicon-link:before,.markdown-body h5:hover .anchor .octicon-link:before,.markdown-body h6:hover .anchor .octicon-link:before{background-color:currentColor;content:" ";display:inline-block;height:16px;-webkit-mask-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 0 0 1.06 1.06l1.25-1.25a2 2 0 1 1 2.83 2.83l-2.5 2.5a2 2 0 0 1-2.83 0 .75.75 0 0 0-1.06 1.06 3.5 3.5 0 0 0 4.95 0l2.5-2.5a3.5 3.5 0 0 0-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 0 1 0-2.83l2.5-2.5a2 2 0 0 1 2.83 0 .75.75 0 0 0 1.06-1.06 3.5 3.5 0 0 0-4.95 0l-2.5 2.5a3.5 3.5 0 0 0 4.95 4.95l1.25-1.25a.75.75 0 0 0-1.06-1.06l-1.25 1.25a2 2 0 0 1-2.83 0z"/></svg>');mask-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 0 0 1.06 1.06l1.25-1.25a2 2 0 1 1 2.83 2.83l-2.5 2.5a2 2 0 0 1-2.83 0 .75.75 0 0 0-1.06 1.06 3.5 3.5 0 0 0 4.95 0l2.5-2.5a3.5 3.5 0 0 0-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 0 1 0-2.83l2.5-2.5a2 2 0 0 1 2.83 0 .75.75 0 0 0 1.06-1.06 3.5 3.5 0 0 0-4.95 0l-2.5 2.5a3.5 3.5 0 0 0 4.95 4.95l1.25-1.25a.75.75 0 0 0-1.06-1.06l-1.25 1.25a2 2 0 0 1-2.83 0z"/></svg>');width:16px}.markdown-body details,.markdown-body figcaption,.markdown-body figure{display:block}.markdown-body summary{display:list-item}.markdown-body [hidden]{display:none!important}.markdown-body a{background-color:transparent;color:#0969da;text-decoration:none}.markdown-body abbr[title]{border-bottom:none;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}.markdown-body b,.markdown-body strong{font-weight:600}.markdown-body dfn{font-style:italic}.markdown-body h1{border-bottom:1px solid #d1d9e0b3;font-size:2em;font-weight:600;margin:.67em 0;padding-bottom:.3em}.markdown-body mark{background-color:#fff8c5;color:#1f2328}.markdown-body small{font-size:90%}.markdown-body sub,.markdown-body sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}.markdown-body sub{bottom:-.25em}.markdown-body sup{top:-.5em}.markdown-body img{border-style:none;box-sizing:content-box;max-width:100%}.markdown-body code,.markdown-body kbd,.markdown-body pre,.markdown-body samp{font-family:monospace;font-size:1em}.markdown-body figure{margin:1em 2.5rem}.markdown-body hr{background:transparent;background-color:#d1d9e0;border:0;box-sizing:content-box;height:.25em;margin:1.5rem 0;overflow:hidden;padding:0}.markdown-body input{font:inherit;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible}.markdown-body [type=button],.markdown-body [type=reset],.markdown-body [type=submit]{-webkit-appearance:button;-moz-appearance:button;appearance:button}.markdown-body [type=checkbox],.markdown-body [type=radio]{box-sizing:border-box;padding:0}.markdown-body [type=number]::-webkit-inner-spin-button,.markdown-body [type=number]::-webkit-outer-spin-button{height:auto}.markdown-body [type=search]::-webkit-search-cancel-button,.markdown-body [type=search]::-webkit-search-decoration{-webkit-appearance:none;appearance:none}.markdown-body ::-webkit-input-placeholder{color:inherit;opacity:.54}.markdown-body ::-webkit-file-upload-button{-webkit-appearance:button;appearance:button;font:inherit}.markdown-body a:hover{text-decoration:underline}.markdown-body ::-moz-placeholder{color:#59636e;opacity:1}.markdown-body ::placeholder{color:#59636e;opacity:1}.markdown-body hr:after,.markdown-body hr:before{content:"";display:table}.markdown-body hr:after{clear:both}.markdown-body table{border-collapse:collapse;border-spacing:0;display:block;font-variant:tabular-nums;max-width:100%;overflow:auto;width:-moz-max-content;width:max-content}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body [role=button]:focus,.markdown-body a:focus,.markdown-body input[type=checkbox]:focus,.markdown-body input[type=radio]:focus{box-shadow:none;outline:2px solid #0969da;outline-offset:-2px}.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body a:focus:not(:focus-visible),.markdown-body input[type=checkbox]:focus:not(:focus-visible),.markdown-body input[type=radio]:focus:not(:focus-visible){outline:1px solid transparent}.markdown-body [role=button]:focus-visible,.markdown-body a:focus-visible,.markdown-body input[type=checkbox]:focus-visible,.markdown-body input[type=radio]:focus-visible{box-shadow:none;outline:2px solid #0969da;outline-offset:-2px}.markdown-body a:not([class]):focus,.markdown-body a:not([class]):focus-visible,.markdown-body input[type=checkbox]:focus,.markdown-body input[type=checkbox]:focus-visible,.markdown-body input[type=radio]:focus,.markdown-body input[type=radio]:focus-visible{outline-offset:0}.markdown-body kbd{background-color:#f6f8fa;border:1px solid #d1d9e0b3;border-radius:6px;box-shadow:inset 0 -1px 0 #d1d9e0b3;color:#1f2328;display:inline-block;font:11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;line-height:10px;padding:.25rem;vertical-align:middle}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{font-weight:600;line-height:1.25;margin-bottom:1rem;margin-top:1.5rem}.markdown-body h2{border-bottom:1px solid #d1d9e0b3;font-size:1.5em;font-weight:600;padding-bottom:.3em}.markdown-body h3{font-size:1.25em;font-weight:600}.markdown-body h4{font-size:1em;font-weight:600}.markdown-body h5{font-size:.875em;font-weight:600}.markdown-body h6{color:#59636e;font-size:.85em;font-weight:600}.markdown-body p{margin-bottom:10px;margin-top:0}.markdown-body blockquote{border-left:.25em solid #d1d9e0;color:#59636e;margin:0;padding:0 1em}.markdown-body ol,.markdown-body ul{margin-bottom:0;margin-top:0;padding-left:2em}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code,.markdown-body pre,.markdown-body samp,.markdown-body tt{font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px}.markdown-body pre{word-wrap:normal;margin-bottom:0;margin-top:0}.markdown-body .octicon{fill:currentColor;display:inline-block;overflow:visible!important;vertical-align:text-bottom}.markdown-body input::-webkit-inner-spin-button,.markdown-body input::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}.markdown-body .mr-2{margin-right:.5rem!important}.markdown-body:after,.markdown-body:before{content:"";display:table}.markdown-body:after{clear:both}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .absent{color:#d1242f}.markdown-body .anchor{float:left;line-height:1;margin-left:-20px;padding-right:.25rem}.markdown-body .anchor:focus{outline:none}.markdown-body blockquote,.markdown-body details,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-bottom:1rem;margin-top:0}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1f2328;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1 code,.markdown-body h1 tt,.markdown-body h2 code,.markdown-body h2 tt,.markdown-body h3 code,.markdown-body h3 tt,.markdown-body h4 code,.markdown-body h4 tt,.markdown-body h5 code,.markdown-body h5 tt,.markdown-body h6 code,.markdown-body h6 tt{font-size:inherit;padding:0 .2em}.markdown-body summary h1,.markdown-body summary h2,.markdown-body summary h3,.markdown-body summary h4,.markdown-body summary h5,.markdown-body summary h6{display:inline-block}.markdown-body summary h1 .anchor,.markdown-body summary h2 .anchor,.markdown-body summary h3 .anchor,.markdown-body summary h4 .anchor,.markdown-body summary h5 .anchor,.markdown-body summary h6 .anchor{margin-left:-40px}.markdown-body summary h1,.markdown-body summary h2{border-bottom:0;padding-bottom:0}.markdown-body ol.no-list,.markdown-body ul.no-list{list-style-type:none;padding:0}.markdown-body ol[type="a s"]{list-style-type:lower-alpha}.markdown-body ol[type="A s"]{list-style-type:upper-alpha}.markdown-body ol[type="i s"]{list-style-type:lower-roman}.markdown-body ol[type="I s"]{list-style-type:upper-roman}.markdown-body div>ol:not([type]),.markdown-body ol[type="1"]{list-style-type:decimal}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-bottom:0;margin-top:0}.markdown-body li>p{margin-top:1rem}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{font-size:1em;font-style:italic;font-weight:600;margin-top:1rem;padding:0}.markdown-body dl dd{margin-bottom:1rem;padding:0 1rem}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{border:1px solid #d1d9e0;padding:6px 13px}.markdown-body table td>:last-child{margin-bottom:0}.markdown-body table tr{background-color:#fff;border-top:1px solid #d1d9e0b3}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body table img{background-color:transparent}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body .emoji{background-color:transparent;max-width:none;vertical-align:text-top}.markdown-body span.frame{display:block;overflow:hidden}.markdown-body span.frame>span{border:1px solid #d1d9e0;display:block;float:left;margin:13px 0 0;overflow:hidden;padding:7px;width:auto}.markdown-body span.frame span img{display:block;float:left}.markdown-body span.frame span span{clear:both;color:#1f2328;display:block;padding:5px 0 0}.markdown-body span.align-center{clear:both;display:block;overflow:hidden}.markdown-body span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}.markdown-body span.align-center span img{margin:0 auto;text-align:center}.markdown-body span.align-right{clear:both;display:block;overflow:hidden}.markdown-body span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}.markdown-body span.align-right span img{margin:0;text-align:right}.markdown-body span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}.markdown-body span.float-left span{margin:13px 0 0}.markdown-body span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}.markdown-body span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}.markdown-body code,.markdown-body tt{background-color:#818b981f;border-radius:6px;font-size:85%;margin:0;padding:.2em .4em;white-space:break-spaces}.markdown-body code br,.markdown-body tt br{display:none}.markdown-body del code{text-decoration:inherit}.markdown-body samp{font-size:85%}.markdown-body pre code{font-size:100%}.markdown-body pre>code{background:transparent;border:0;margin:0;padding:0;white-space:pre;word-break:normal}.markdown-body .highlight{margin-bottom:1rem}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{background-color:#f6f8fa;border-radius:6px;color:#1f2328;font-size:85%;line-height:1.45;overflow:auto;padding:1rem}.markdown-body pre code,.markdown-body pre tt{word-wrap:normal;background-color:transparent;border:0;display:inline;line-height:inherit;margin:0;max-width:auto;overflow:visible;padding:0}.markdown-body .csv-data td,.markdown-body .csv-data th{font-size:12px;line-height:1;overflow:hidden;padding:5px;text-align:left;white-space:nowrap}.markdown-body .csv-data .blob-num{background:#fff;border:0;padding:10px .5rem 9px;text-align:right}.markdown-body .csv-data tr{border-top:0}.markdown-body .csv-data th{background:#f6f8fa;border-top:0;font-weight:600}.markdown-body [data-footnote-ref]:before{content:"["}.markdown-body [data-footnote-ref]:after{content:"]"}.markdown-body .footnotes{border-top:1px solid #d1d9e0;color:#59636e;font-size:12px}.markdown-body .footnotes ol{padding-left:1rem}.markdown-body .footnotes ol ul{display:inline-block;margin-top:1rem;padding-left:1rem}.markdown-body .footnotes li{position:relative}.markdown-body .footnotes li:target:before{border:2px solid #0969da;border-radius:6px;bottom:-.5rem;content:"";left:-1.5rem;pointer-events:none;position:absolute;right:-.5rem;top:-.5rem}.markdown-body .footnotes li:target{color:#1f2328}.markdown-body .footnotes .data-footnote-backref g-emoji{font-family:monospace}.markdown-body body:has(:modal){padding-right:var(--dialog-scrollgutter)!important}.markdown-body .pl-c{color:#59636e}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#0550ae}.markdown-body .pl-e,.markdown-body .pl-en{color:#6639ba}.markdown-body .pl-s .pl-s1,.markdown-body .pl-smi{color:#1f2328}.markdown-body .pl-ent{color:#0550ae}.markdown-body .pl-k{color:#cf222e}.markdown-body .pl-pds,.markdown-body .pl-s,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sra,.markdown-body .pl-sr .pl-sre{color:#0a3069}.markdown-body .pl-smw,.markdown-body .pl-v{color:#953800}.markdown-body .pl-bu{color:#82071e}.markdown-body .pl-ii{background-color:#82071e;color:#f6f8fa}.markdown-body .pl-c2{background-color:#cf222e;color:#f6f8fa}.markdown-body .pl-sr .pl-cce{color:#116329;font-weight:700}.markdown-body .pl-ml{color:#3b2300}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{color:#0550ae;font-weight:700}.markdown-body .pl-mi{color:#1f2328;font-style:italic}.markdown-body .pl-mb{color:#1f2328;font-weight:700}.markdown-body .pl-md{background-color:#ffebe9;color:#82071e}.markdown-body .pl-mi1{background-color:#dafbe1;color:#116329}.markdown-body .pl-mc{background-color:#ffd8b5;color:#953800}.markdown-body .pl-mi2{background-color:#0550ae;color:#d1d9e0}.markdown-body .pl-mdr{color:#8250df;font-weight:700}.markdown-body .pl-ba{color:#59636e}.markdown-body .pl-sg{color:#818b98}.markdown-body .pl-corl{color:#0a3069;text-decoration:underline}.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body [role=tabpanel][tabindex="0"]:focus:not(:focus-visible),.markdown-body a:focus:not(:focus-visible),.markdown-body button:focus:not(:focus-visible),.markdown-body summary:focus:not(:focus-visible){box-shadow:none;outline:none}.markdown-body [tabindex="0"]:focus:not(:focus-visible),.markdown-body details-dialog:focus:not(:focus-visible){outline:none}.markdown-body g-emoji{display:inline-block;font-family:Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-size:1em;font-style:normal!important;font-weight:400;line-height:1;min-width:1ch;vertical-align:-.075em}.markdown-body g-emoji img{height:1em;width:1em}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item label{font-weight:400}.markdown-body .task-list-item.enabled label{cursor:pointer}.markdown-body .task-list-item+.task-list-item{margin-top:.25rem}.markdown-body .task-list-item .handle{display:none}.markdown-body .task-list-item-checkbox{margin:0 .2em .25em -1.4em;vertical-align:middle}.markdown-body ul:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body ol:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body .contains-task-list:focus-within .task-list-item-convert-container,.markdown-body .contains-task-list:hover .task-list-item-convert-container{clip:auto;display:block;height:24px;overflow:visible;width:auto}.markdown-body ::-webkit-calendar-picker-indicator{filter:invert(50%)}.markdown-body .markdown-alert{border-left:.25em solid #d1d9e0;color:inherit;margin-bottom:1rem;padding:.5rem 1rem}.markdown-body .markdown-alert>:first-child{margin-top:0}.markdown-body .markdown-alert>:last-child{margin-bottom:0}.markdown-body .markdown-alert .markdown-alert-title{align-items:center;display:flex;font-weight:500;line-height:1}.markdown-body .markdown-alert.markdown-alert-note{border-left-color:#0969da}.markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title{color:#0969da}.markdown-body .markdown-alert.markdown-alert-important{border-left-color:#8250df}.markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title{color:#8250df}.markdown-body .markdown-alert.markdown-alert-warning{border-left-color:#9a6700}.markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title{color:#9a6700}.markdown-body .markdown-alert.markdown-alert-tip{border-left-color:#1a7f37}.markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title{color:#1a7f37}.markdown-body .markdown-alert.markdown-alert-caution{border-left-color:#cf222e}.markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title{color:#d1242f}.markdown-body>:first-child>.heading-element:first-child{margin-top:0!important}.markdown-body .highlight pre:has(+.zeroclipboard-container){min-height:52px}code[class*=language-],pre[class*=language-]{color:#d4d4d4;direction:ltr;font-family:Menlo,Monaco,Consolas,Andale Mono,Ubuntu Mono,Courier New,monospace;font-size:13px;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;text-shadow:none;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#264f78;text-shadow:none}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{background:#1e1e1e;margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-]{background:#1e1e1e;border-radius:.3em;color:#db4c69;padding:.1em .3em}.namespace{opacity:.7}.token.doctype .token.doctype-tag{color:#569cd6}.token.doctype .token.name{color:#9cdcfe}.token.comment,.token.prolog{color:#6a9955}.language-html .language-css .token.punctuation,.language-html .language-javascript .token.punctuation,.token.punctuation{color:#d4d4d4}.token.boolean,.token.constant,.token.inserted,.token.number,.token.property,.token.symbol,.token.tag,.token.unit{color:#b5cea8}.token.attr-name,.token.builtin,.token.char,.token.deleted,.token.selector,.token.string{color:#ce9178}.language-css .token.string.url{text-decoration:underline}.token.entity,.token.operator{color:#d4d4d4}.token.operator.arrow{color:#569cd6}.token.atrule{color:#ce9178}.token.atrule .token.rule{color:#c586c0}.token.atrule .token.url{color:#9cdcfe}.token.atrule .token.url .token.function{color:#dcdcaa}.token.atrule .token.url .token.punctuation{color:#d4d4d4}.token.keyword{color:#569cd6}.token.keyword.control-flow,.token.keyword.module{color:#c586c0}.token.function,.token.function .token.maybe-class-name{color:#dcdcaa}.token.regex{color:#d16969}.token.important{color:#569cd6}.token.italic{font-style:italic}.token.constant{color:#9cdcfe}.token.class-name,.token.maybe-class-name{color:#4ec9b0}.token.console,.token.interpolation,.token.parameter{color:#9cdcfe}.token.boolean,.token.punctuation.interpolation-punctuation{color:#569cd6}.token.exports .token.maybe-class-name,.token.imports .token.maybe-class-name,.token.property,.token.variable{color:#9cdcfe}.token.escape,.token.selector{color:#d7ba7d}.token.tag{color:#569cd6}.token.cdata,.token.tag .token.punctuation{color:grey}.token.attr-name{color:#9cdcfe}.token.attr-value,.token.attr-value .token.punctuation{color:#ce9178}.token.attr-value .token.punctuation.attr-equals{color:#d4d4d4}.token.entity{color:#569cd6}.token.namespace{color:#4ec9b0}code[class*=language-javascript],code[class*=language-jsx],code[class*=language-tsx],code[class*=language-typescript],pre[class*=language-javascript],pre[class*=language-jsx],pre[class*=language-tsx],pre[class*=language-typescript]{color:#9cdcfe}code[class*=language-css],pre[class*=language-css]{color:#ce9178}code[class*=language-html],pre[class*=language-html]{color:#d4d4d4}.language-regex .token.anchor{color:#dcdcaa}.language-html .token.punctuation{color:grey}pre[class*=language-]>code[class*=language-]{position:relative;z-index:1}.line-highlight.line-highlight{background:#f7ebc6;box-shadow:inset 5px 0 0 #f7d87c;z-index:0}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(58,151,237,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(58,151,237,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/*
! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #f2f2f2;box-sizing:border-box}:after,:before{--tw-content:""}:host,html{-webkit-text-size-adjust:100%;font-feature-settings:normal;-webkit-tap-highlight-color:transparent;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-variation-settings:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-feature-settings:normal;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em;font-variation-settings:normal}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{font-feature-settings:inherit;color:inherit;font-family:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#e2e8f0;opacity:1}input::placeholder,textarea::placeholder{color:#e2e8f0;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]:where(:not([hidden=until-found])){display:none}body{font-family:Noto Sans KR}a{text-decoration:underline}.font-title{font-size:24px}.font-body{font-size:16px}.highlight{--tw-bg-opacity:1;background-color:rgb(187 247 208/var(--tw-bg-opacity,1));border-radius:.25rem;padding-left:.25rem;padding-right:.25rem}.static{position:static}.absolute{position:absolute}.relative{position:relative}.isolate{isolation:isolate}.m-auto{margin:auto}.my-4{margin-bottom:1rem;margin-top:1rem}.ml-6{margin-left:1.5rem}.mr-6{margin-right:1.5rem}.mt-1{margin-top:.25rem}.mt-10{margin-top:2.5rem}.mt-16{margin-top:4rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:.75rem}.mt-5{margin-top:1.25rem}.mt-7{margin-top:1.75rem}.mt-8{margin-top:2rem}.line-clamp-2{-webkit-line-clamp:2}.line-clamp-2,.line-clamp-3{-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.line-clamp-3{-webkit-line-clamp:3}.flex{display:flex}.grid{display:grid}.h-\[145px\]{height:145px}.h-\[2px\]{height:2px}.h-\[323px\]{height:323px}.h-\[55px\]{height:55px}.w-fit{width:-moz-fit-content;width:fit-content}.w-full{width:100%}.min-w-\[192px\]{min-width:192px}.min-w-\[210px\]{min-width:210px}.max-w-\[768px\]{max-width:768px}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-pointer{cursor:pointer}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.justify-center{justify-content:center}.gap-1{gap:.25rem}.gap-10{gap:2.5rem}.gap-2{gap:.5rem}.gap-3{gap:.75rem}.gap-4{gap:1rem}.gap-7{gap:1.75rem}.gap-8{gap:2rem}.gap-\[12px\]{gap:12px}.gap-\[14px\]{gap:14px}.gap-\[2px\]{gap:2px}.gap-\[8px\]{gap:8px}.gap-x-2{-moz-column-gap:.5rem;column-gap:.5rem}.gap-y-4{row-gap:1rem}.self-center{align-self:center}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.whitespace-pre-line{white-space:pre-line}.text-pretty{text-wrap:pretty}.rounded-xl{border-radius:.75rem}.border{border-width:1px}.border-black{--tw-border-opacity:1;border-color:rgb(34 34 34/var(--tw-border-opacity,1))}.bg-\[\#E2E8F0\]{--tw-bg-opacity:1;background-color:rgb(226 232 240/var(--tw-bg-opacity,1))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity,1))}.p-10{padding:2.5rem}.px-14{padding-left:3.5rem;padding-right:3.5rem}.pl-\[14px\]{padding-left:14px}.pr-\[14px\]{padding-right:14px}.pt-4{padding-top:1rem}.font-body,.font-noto{font-family:Noto Sans KR,ui-sans-serif,system-ui,sans-serif}.font-ubuntu{font-family:Ubuntu,ui-sans-serif,system-ui,sans-serif}.text-base{font-size:1rem;line-height:1.5rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.leading-5{line-height:1.25rem}.leading-6{line-height:1.5rem}.text-blue-600{--tw-text-opacity:1;color:rgb(37 99 235/var(--tw-text-opacity,1))}.outline{outline-style:solid}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}@media (min-width:640px){.sm\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}@media (min-width:768px){.md\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}}</style><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="true"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&amp;display=swap"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&amp;display=swap"/><title data-gatsby-head="true">Home Page</title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><main><header class="text-xl m-auto my-4 px-14 max-w-[768px] font-bold font-ubuntu"><a aria-current="page" class="m-auto cursor-pointer" href="/">dev-hamster</a></header><div class="m-auto my-4 px-14 max-w-[768px]"><div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-x-2 gap-y-4"><a href="/반응형-퍼블리싱-스터디-회고-🤓/"><div class="flex flex-col gap-[14px] w-full min-w-[210px] h-[323px] pt-4 pl-[14px] pr-[14px] rounded-xl border border-black bg-white"><div data-gatsby-image-wrapper="" class="gatsby-image-wrapper self-center min-w-[192px] w-full h-[145px] rounded-xl"><div aria-hidden="true" style="padding-top:140.04329004329006%"></div><img aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear" decoding="async" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAAGi0lEQVR42nWV228bxxXGmYsRIYlly7paokSJokguyeXuci8kl/ebRFKiLtbVlmTLMWTnYtmOKse149ZAqgSB4rhFDdtIW9tBg7qAi6LIQ18KBIVbFOhrH4o+F8j/8euMLKFAgT4c7M6cme+cmXO+bzzpdJpEwsR2HAzdIhDS8Ad1YnETxxZzwpdKpchks6QPzEmnsFIHlkxiH/y7bgZPOBzilSNttPUM4FVDLK+5XDpvkchHeXNghFffaMfn8+PUKqgTVeLi68xM4U43sOrjhAsF+uManWEF3bbxBEZHOer1k19e4vbGAr8+W+HJgsPTi2XOrK/QFYrSf9JLuj7BWKnIxtYGz39zj2d/+h1Pnn/F9rWLhETW3eHwS8CQliAZG2dK0Vkc7KLaeZzMsXZmu3u5GLaw03WGTYtkpUi4VuPd9xapjxf54usvWd+6RDBqo6cdumNxDHF8T8xMMtzXx2zSzz+uxniweIwv597k+50oj5cVunp6UARgoljEqJS5c32TSx9usv30EadvXSeZzRAMhjkxGkIXdfAEg0FeO9pFIBLj45kYlWQPtVw/n80HKCSjeNo68Q0OYVYqBNIu5z98n43rO8ytrpGbniNiphjwjfLW4Ahxy8IzFgjS1utjwK3wSl+QxfUya1sLePqGOTv/Div6NL39QxiFIj6R6YWb23zyzQPe/fgq1u2PCMy36O3q5+jAMNrLO4zTtTDFyaU5vJkG9x5c4ZNHO6xuNnl6Ns7uhEXTzRJ0UgTjOmomR2ZpifMX5ghVS7wdVGk/3k+HdwTNEoBjUZUuxY+mD3D58nm++e0tfvyzy9x9dIXKKR074sWNRAgl0/SFY3QEIuQbTT69sUEzY3Csa5D2wTE6RkIvAROGQVo05dT0JHXRGpVyiXwhT6lcpi7mLMcUwTQSpombyQpfkWZjgmazQUP0oW1bKIpCJBrFkUXRjQSteoXlxXkmJhrCJsiKjZJBGddFVVVMAWaIwI1agaXFBRrNJq3WNMVSGV3MR8QJooeAlkgzocVQY5H9KNIZFk2qSBORpUnARCJBVPjkWG6OxWL7a/fBYtH/AsrFMstsPi+OlRCgEWLCmUo6lIoF3FRyH9AUPjmXE32XMHQBoKDFY+QyLmXRo44t9EBWOZ0UxBZ3ZAtQU9fFIo2oqqHEDRTNFJVNkHCSIqjNaEQjLJg1qhj4w/q+jcUShDSDsYiBI7A8togYFrSK12vo4pJLzRqr02Wuz2f50akku3MWC6U051Zy3L9c4vNzZX6+nePhDzI82Mly7708e+tV9q4UxR1n8Sg5QeyZJsrGGZZufcDzX37A33bz/PWaw4stl39uRrnTNPjVVQHWSjPpM3n+03We/eUO3353k73VKSrdUf54o8D2ek5wWQAOzzYZW1ngs7tbvHg4xbdbXaxkIny05LI7n+JMyeTJVIMfBg3aUi38v3hC5/MXdP7+O9p+cp+eoQR/GC9wtVHCo4oj+ydr+OemuXF7lbs7FR6ue0XLWOTLltDAItFMisfVcf7dnGLzVIuJcot8NsV4piCavMX9ZoXvp6e4ILTRk8i6RIQcBScbnF5v8PXCCXbTHvKDx7Ebeex6nnjB5XG+wp9nV0kVGri+GE/OaOxVAliiQO/MnuZfU9NsZvOiDzNpokWXkVIOpVJgQNVp8wbo0w2MWo6IyE4R2TyzJ/giu8ZrXtEJ/T5O5SeZTGTx9viFaNT5u73IZlIe2bHxuQ6nNpdYXiqTruQYWT1HT89J9GqG+mIDv63zlfo+M+Y1Xh0y6TjWT/fbnfS0d9HRLoRhqMCe9TmX1BaeUU3HqjpcuzTLzpkCazmFybCXZHiIhh1ifk4otWjkRmmb18tXaItUOTKa4fU2L0feGuaNEZcjepO++k0m3UU8mmUybo/i6+0hPtDHjOFnJjZILuQj5PWijI3sMyXglDihZOiIpjlhFOgeMOgdTdFrlOlXXbrVHJorimIKjhbyOVZWlmm2WtREJav1STL5IorgqarGsASgJURgUjT/ypJ8U2rMzc0IqplElZDQgShqRCEprs9jCnFwTE3wNkdRSFO1WiGfyxGPq/tCED4UB0HNlKmTEz75TuuCplIgZFDlQCSS8pGSeqbGxYslMpVSJVVDmtwgyS6/h2ojeS7Hct2hZMl5S7wlmqYdype1v8gV2mccaJs0CSI1UfoPAaXJ7OTmQxmTIId799VGDuSP3Ci//2tyXgJLOxz/v7US6z9By8R0nCBqYQAAAABJRU5ErkJggg==" alt=""/><picture><source type="image/webp" data-srcset="/static/17ad8121ccf87c6ce98490d2626d88cd/5c34d/07.webp 750w,/static/17ad8121ccf87c6ce98490d2626d88cd/6b2ec/07.webp 924w" sizes="100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="100vw" decoding="async" loading="lazy" data-src="/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png" data-srcset="/static/17ad8121ccf87c6ce98490d2626d88cd/eb5fe/07.png 750w,/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png 924w" alt="반응형 레이아웃 퍼블리싱 스터디 회고 🤓"/></picture><noscript><picture><source type="image/webp" srcSet="/static/17ad8121ccf87c6ce98490d2626d88cd/5c34d/07.webp 750w,/static/17ad8121ccf87c6ce98490d2626d88cd/6b2ec/07.webp 924w" sizes="100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="100vw" decoding="async" loading="lazy" src="/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png" srcSet="/static/17ad8121ccf87c6ce98490d2626d88cd/eb5fe/07.png 750w,/static/17ad8121ccf87c6ce98490d2626d88cd/5d060/07.png 924w" alt="반응형 레이아웃 퍼블리싱 스터디 회고 🤓"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div><p class="h-[55px] text font-semibold text-pretty line-clamp-2">반응형 레이아웃 퍼블리싱 스터디 회고 🤓</p><div class="w-full line-clamp-3 text-pretty" style="font-size:14px;line-height:16px;color:#666">
퍼블리싱 속도를 높이고 레이아웃을 잡는 연습을 하기 위해 2024.11.10부터 4주간 퍼블리싱
스터디에 참여했다. 동일한 Figma 디자인 시안으로 퍼블리싱을 진행해 다른 스터디원의
노하우를 엿볼 수 있었다. 스터디에 참여하면서 grid, flex를 더 적극적으로 활용할 수
있게 되었고, 퍼블리싱 팁뿐만 아니라 디렉토리 구조에 대해서도 지식을 넓힐 수 있었다.

week01

TL;DR

이미지 사이즈를 주는 방법은 3가지로 있고, 적재적소에 알맞게 사용하는게 좋다.
scss도 module을 지원한다. 하지만 CSS-in-JS가 선호되는 이유를 알겠다.

Figma 디자인 시안

image01

scss

개인적으로 CSS로 처리할 수 있는 작업은 CSS를 사용하는 것을 선호해 SCSS로 스타일링을 시도해보았다. 하지만 SCSS에서는 변수를 사용하려면 스타일 파일에서 명시적으로 연결해주어야 하는 점이 불편했다. 반면 CSS-in-JS는 변수를 쉽게 받아와 사용할 수 있다는 점이 큰 장점으로 느껴졌다.

// /styles/variables.scss

// breakpoint를 변수로 관리했다.
$tablet-breakpoint: 767px;
$pc-breakpoint: 1024px;

// button.module.scss에서 정의한 변수를 사용하려면 @use를 한다.
@use &#x27;/styles/variables.scss&#x27; as var;

.foo {
  @media (min-width: var.$tablet-breakpoint) {
    // ...
  }
}

이미지 사이즈는 어떤 방법으로 줄까?

이미지 사이즈를 조정하는 방법은 이렇게 3가지가 있다. 어떤 방식으로 이미지를 넣어줘야 하는지 애매모호해서 스터디원의 의견과 구글링을 통해 기준을 정리해보았다.

이미지 태그에 직접 width, height 값 주기
이미지 width는 100%로 하고 부모 요소를 통해 스타일 제어하기
요소의 background-image속성으로 object-position 값을 주기

이미지에 직접 width, height 값 주기

디자인이 정적으로 고정되는 요소 (예: 해당 Fimga의 프로필 이미지)
CLS를 방지하고 브라우저가 이미지 크기를 미리 알고 효율적으로 로드

이미지 width는 100%로 하고 부모 요소에 의존하기

컨테이너 레이아웃, 가변적으로 적용되는 요소 (예: 해당 Fimga의 카드 컴포넌트 썸네일)

요소의 background-image속성으로 object-position 값을 주기

꾸밈 이미지와 같이 내용에 영향을 주지 않는 요소
렌더 트리 생성 단계 이후에 이미지를 요청해 우선순위가 낮음

상단 컨텐츠 레이아웃

image02

PC, 태블릿, 모바일 화면에서 레이아웃이 달라지는 디자인이다. 이 영역은 공통되는 초록생 영역을 기준으로 잡았다.

초록색 영역은 flex-direction을 column 으로 레이아웃을 잡았다. 모바일 화면에서는 버튼 컨테이너와 Active Users 위치를 각각 absolute로 했다.

카드 리스트 레이아웃

image03 image04

Featured NFTs와 Cretors 의 카드 영역은 모두 grid 레이아웃을 적용했다.

새로 알게된 사실

scss에서 &amp;__ 를 사용하면 상위 클래스 네임을 상속받을 수 있어 BEM 규칙을 따를 수 있다.


// 이것은
.text-box {
  &amp;__title {
  }
}

// 이렇게 컴파일 된다.
.text-box{
}
.text-box__title {
}

작업 결과

05

Week02

TL;DR

flex: 1 1 auto 를 이해하고 사용했다.
grid 레이아웃을 사용하면, 최대한 많은 요소를 보여주는 레이아웃을 그릴 수 있다.

Figma 디자인 시안

06

emotion 사용

디자인 재사용성을 높여보도록 emotion를 사용했는데, 퍼블리싱에만 집중했다. ^^;

reset css

https://www.joshwcomeau.com/css/custom-css-reset/ 를 사용했다.

그 중에, isolation 속성이 인상깊은데,

/* https://www.joshwcomeau.com/css/custom-css-reset/ */

/*
  Create a root stacking context
*/
#root, #__next {
  isolation: isolate;
}

This is beneficial since it allows us to guarantee that certain high-priority elements (modals, dropdowns, tooltips) will always show up above the other elements in our application. No weird stacking context bugs, no z-index arms race.

모달, 드롭다운, 툴팁이 항상 다른 요소들 위에 표시되도록 보장할 수 있다고 한다.

카드 레이아웃

07

화면 해상도가 넓어지면 최대한 많은 카드를 보여주기 위해 grid-template-columns 속성을 사용하고 최소 카드 width를 315px 를 주었다.

const CardLayout = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(315px, 1fr));
  grid-gap: 20px;
`;

탭 레이아웃

08

두 버튼의 width 간격을 같은 비율로 맞춰주기 위해 flex: 1 1 auto; 를 적용했다. (미루고 미뤄왔던,,, flex: 1 1 auto를 이해했다. 😆)

Button을 width 100%로 둬도 동일한 효과를 줄 수 있다고 한다.

const TabContainer = styled.div`
  display:flx;
`
const Button = styled.div`
    width: 100%;
`

Collection 하위 아이템 레이아웃

09

하위 아이템의 레이아웃은 최소 너비를 95px를 보장하고 균등하게 나누기 위해 flex: 1 1 95px; 을 사용했다.

하위 아이템 개수가 모자른 경우에는 조건문으로 빈 element를 넣어줬는데, grid-template-columns를 이용해 같은 공간을 3개로 균등하게 나누면 스크립트롤 작성하지 않아도 된다!

display: grid;
grid-template-columns: 1fr 1fr 1fr;

작업 결과

10

week03

TL;DR

Grid로 공백있는 레이아웃 표현하기

Figma 디자인 시안

11

그리드 시스템으로 공백이 있는 레이아웃 표현하기

모바일에서는 컨텐츠가 일렬로 배치되어 있고 태블릿 이상부터는 두 열로 배치된다. flex를 사용하면 태블릿 이상부터는 표현하기 어려워진다. 그리드 시스템을 사용하면 일렬, 두 열 레이아웃을 간결하게 구현할 수 있다.

12  13  14

grid-template-areas를 사용하면 이름을 지정해 레이아웃을 배치할 수 있다. 각 그리드
아이템은 grid-area 속성으로 이름을 지정할 수 있다.

각 영역에 grid-area 로 적당한 이름으로 준 뒤, 컨테이너에 이렇게 하면 일렬로 배치할 수 있다.

const ContentsContainer = styled.div`
    grid-template-areas:
    &#x27;title&#x27;
    &#x27;endsIn&#x27;
    &#x27;creator&#x27;
    &#x27;description&#x27;
    &#x27;details&#x27;
    &#x27;tags&#x27;;
  // ...
`;

15

태블릿 크기 이상에서는 그리드 아이템을 두 열로 나누어 배치한다. endsIn 영역은 오른쪽 열에 위치시키고 title부터 description 영역까지 세로로 걸치게 했다. 나머지 영역은 &#x27;.&#x27;을 사용하여 공백 처리한다.

const ContentsContainer = styled.div`
  // ...

  @media (min-width: 834px) {
    grid-template-areas:
      &#x27;title title endsIn&#x27;
      &#x27;creator creator endsIn&#x27;
      &#x27;description description endsIn&#x27;
      &#x27;details details .&#x27;
      &#x27;tags tags .&#x27;;
    // ...
    }
`;

endsIn 영역(타이머)이 description까지 늘어나게 되는데, 이는 해당 요소에 height를 지정하지 않아 왼쪽 컨텐츠의 높이값을 따라가기 때문이다. 이 문제를 해결하기 위해 endsIn 컨텐츠에 min-content 값을 적용하여 자신의 내용물 크기만큼만 높이를 가지도록 했다.

16

const EndsInBlock = styled.div`
  height: min-content;
  // ...
 `

아래는 전체 코드의 일부이다. 흥미로운 점은 마크업 순서와 관계없이 grid-area의 이름 속성만으로 요소 배치가 결정된다.


  
  
  
  
  
  


const ContentsContainer = styled.div`
  gap: 20px;
  padding: 40px 30px;
  display: grid;
  grid-template-areas:
    &#x27;title&#x27;
    &#x27;endsIn&#x27;
    &#x27;creator&#x27;
    &#x27;description&#x27;
    &#x27;details&#x27;
    &#x27;tags&#x27;;

  @media (min-width: 834px) {
    padding: 40px 72px;
    grid-template-columns: 1fr 295px;
    grid-template-areas:
      &#x27;title title endsIn&#x27;
      &#x27;creator creator endsIn&#x27;
      &#x27;description description endsIn&#x27;
      &#x27;details details .&#x27;
      &#x27;tags tags .&#x27;;
    column-gap: 30px;
  }

  @media (min-width: 1280px) {
    padding: 40px 115px;
    column-gap: 150px;
  }
`;

작업 결과

17

week04

TL;DR

레이아웃 흐름을 방해하지 않고 스타일 주기

Figma 디자인 시안

18

Form 레이아웃

grid 레이아웃으로 모바일에서는 1열로 배치하고 태블릿 이상부터는 grid-template-areas로 2열로 배치하도록 했다.


    
    


const FormContainer = styled.div`
  display: grid;
  grid-template-columns: 1fr;

  @media (min-width: 834px) {
    grid-template-areas: &#x27;hero form&#x27;;
    grid-template-columns: 1fr 1fr;
  }
`;

const HeroBox = styled.div`
  // ...
  grid-area: &#x27;hero&#x27;;
`;

const FormBox = styled(FlexColumnBox)`
  // ...
  grid-area: &#x27;form&#x27;;
 `

Input focus 스타일

Input border스타일은 레이아웃에 영향을 주지 않는 box-shadow속성을 사용하고 ` 에 focus가 활성화 됐을 때, 부모 컴포넌트에 포커스 스타일을 주기위해서 네이티브 focus스타일을 주지않고:focus-within` 를 사용했다.

19


20


  
    
  
  


const InputWrapper = styled(FlexRowBox)`
  // ...
  box-shadow: 0px 0px 0px 1px rgba(133, 133, 132, 1);
  &amp;:focus-within {
    box-shadow: 0px 0px 0px 1.5px rgba(162, 89, 255, 1);
  }
`;

const InputEle = styled.input`
  // ...
  outline: none;
`;

에러 메세지 레이아웃

에러메세지가 보여지면서 레이아웃 영향을 주지않도록 absolute를 사용했다.

21


  
    
  
  


const InputContainer = styled.div`
  position: relative;
`;

const ErrorMessage = styled.span`
  // ...
  position: absolute;
  margin-top: 1px;
`;

작업 결과

22
</div></div></a><a href="/드래그 이벤트 구현기2 - 왜 transform은 더 빠를까/"><div class="flex flex-col gap-[14px] w-full min-w-[210px] h-[323px] pt-4 pl-[14px] pr-[14px] rounded-xl border border-black bg-white"><div data-gatsby-image-wrapper="" class="gatsby-image-wrapper self-center min-w-[192px] w-full h-[145px] rounded-xl"><div aria-hidden="true" style="padding-top:48.48958333333333%"></div><img aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear" decoding="async" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACCUlEQVR42pWS7U/aUBTGmyWLyYw6N1/m5jKHlrb2DVqhRbsUBKS0tMXotoyhKIKa7NP+/w+/XbqXZB/98Mtzz33Oc3KSe6WTJOJYcDKICeM+n6KIVhLTyQaE/b4gKrSVDmgNM9p5TitPOc0zwYBAZE4WdJucXj8idW5GtCcjzqZXpNMJ6e2EbHpDPrslu7slv5uKeko6m5HeP5DO52TzB+HPBHPh35ELfyhmDH/8RKrUQhyviaL7yLpH2fQKNa2AklorUG0f3W5gWD6G7Ql8zOLOL/w9pca7fQej4iNtuDlvGxds2hmrhwmLetsd0ojmLMsxq3rCq2qKHH7hKJngxN8xuyNqyZhKf1xklko9nn3o8d46Q1rRElbVAS+NjKWDHmt6ymb1HDOe8PxjjxVtwHI5QW6N8S4ecfN77GRKXZwr6azwF32LgbtmF2lL67PlJOwKdtQhO3rOhhkjB595UeqypkSCHqrY0E2uxYZXVKIxfj7BPhuxLvLLpQ5Lex327DaS1fyGdv5VNF5gN2bs+2Ne1xM26xkbNbFtXSB028950/jD8W+2/azwF33rbkIpvEQKTkPKmoVRPaLqOeJRTGTNQD78nwNNF/xV/V9d+LrBvnqIfVRH6rZbVCs2zTAkFv/NEWelLKOpypNYZFyniuQ4LoZhEAQBdd/DsiwURUFV1SdRLpdxHIdfiO9KJpqU4n4AAAAASUVORK5CYII=" alt=""/><picture><source type="image/webp" data-srcset="/static/44f0d9ea98aed905a50559e9b9bbdc08/edf46/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 750w,/static/44f0d9ea98aed905a50559e9b9bbdc08/e2d70/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1080w,/static/44f0d9ea98aed905a50559e9b9bbdc08/3577c/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1366w,/static/44f0d9ea98aed905a50559e9b9bbdc08/f19ee/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1920w" sizes="100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="100vw" decoding="async" loading="lazy" data-src="/static/44f0d9ea98aed905a50559e9b9bbdc08/4e630/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png" data-srcset="/static/44f0d9ea98aed905a50559e9b9bbdc08/c4c25/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 750w,/static/44f0d9ea98aed905a50559e9b9bbdc08/ca77f/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1080w,/static/44f0d9ea98aed905a50559e9b9bbdc08/c8ae2/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1366w,/static/44f0d9ea98aed905a50559e9b9bbdc08/4e630/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1920w" alt="드래그 이벤트 구현기2 - 왜 transform은 더 빠를까"/></picture><noscript><picture><source type="image/webp" srcSet="/static/44f0d9ea98aed905a50559e9b9bbdc08/edf46/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 750w,/static/44f0d9ea98aed905a50559e9b9bbdc08/e2d70/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1080w,/static/44f0d9ea98aed905a50559e9b9bbdc08/3577c/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1366w,/static/44f0d9ea98aed905a50559e9b9bbdc08/f19ee/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.webp 1920w" sizes="100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="100vw" decoding="async" loading="lazy" src="/static/44f0d9ea98aed905a50559e9b9bbdc08/4e630/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png" srcSet="/static/44f0d9ea98aed905a50559e9b9bbdc08/c4c25/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 750w,/static/44f0d9ea98aed905a50559e9b9bbdc08/ca77f/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1080w,/static/44f0d9ea98aed905a50559e9b9bbdc08/c8ae2/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1366w,/static/44f0d9ea98aed905a50559e9b9bbdc08/4e630/%EA%B5%AC%EA%B0%84-%ED%99%95%EC%9D%B8.png 1920w" alt="드래그 이벤트 구현기2 - 왜 transform은 더 빠를까"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div><p class="h-[55px] text font-semibold text-pretty line-clamp-2">드래그 이벤트 구현기2 - 왜 transform은 더 빠를까</p><div class="w-full line-clamp-3 text-pretty" style="font-size:14px;line-height:16px;color:#666">
목차

들어가며
transform으로 개선 전 후 성능 비교하기
Layout, Reflow, Paint, Repaint
애니메이션은 어떻게 처리될까?

들어가며

드래그 이벤트 구현시 초기에는 엘리먼트의 위치를 top 과 left 값으로 업데이트해주었다. 그런데 드래그시 미세하게 버벅거려 transform 으로 변경해 매끄러운 드래그 이벤트를 구현했다. transform은 Layout(Reflow)를 발생시키지 않아 더 빠르게 위치를 업데이트 할 수 있다.

이 포스트에서 실제로 성능을 비교해보고 브라우저 렌더링 과정을 이해하고 마지막으로 transform은 어떻게 처리하는지 알아보자.

개선 전, 후 성능 비교하기

크롬 성능 측정을 이용해 드래그 이벤트를 발생시킨 후, 드래그가 본격적으로 발생한 약 4초 동안의 구간을 확인해 보았다.

개선 전, 개선 후의 요약 탭을 확인해보면 렌더링은 38ms에서 24ms 로 단축되고 페인팅은 41ms에서 24ms로 로 개선됐다.

개선 전:
개선전


개선 후: 개선후

다음 사진은 드래그가 발생하는 동안 실행된 작업들이다. 여기서 하나를 확대해보자.
드래그시 실행 중인 작업

mousemove가 드래그 이벤트가 발생한 시점이다. 개선 전 작업을 보면 레이아웃과 페인트 작업을 볼 수 있다.
개선 전 작업

반면에 개선 후 작업에서는 페인트 단계만 볼 수 있다.
개선 후 작업

왜 transform 은 레이아웃 작업이 없을까? 브라우저 렌더링 과정에서 알아보자.

Layout, Reflow, Paint, Repaint

브라우저 렌더링 과정에은 Style, Layout, Paint, 때때로 Compositing이 포함된다. 오늘은 Layout부터 Repaint까지 알아보자.

Layout

렌더 트리가 만들어진 후, 각 노드의 도형 값을 계산하기 위해 레이아웃을 실행한다. 렌더 트리에 있는 모든 노드의 너비, 높이, 위치를 결정하는 프로세스이다. 처음 노드의 사이즈와 위치가 결정된다.

Reflow

레이아웃 이후 페이지의 일부분이나 전체 문서에 대한 크기나 위치에 대한 결정한다. 레이아웃 이후에 노드의 크기와 위치를 다시 계산한다. (크롬 개발자 도구에서는 Layout 용어로 통일)

Paint

텍스트, 색깔, 경계, 그림자 및 버튼인자 이미지 같은 대체 요소를 포함하여 모든 요소의 시각적인 부분을 화면에 그리는 작업이다.

Repaint

첫 페인트 이후 UI변경으로 시각적 업데이트를 표시하기 위해 다시 그릴 때 발생한다. 일반적으로 리플로우 이후에 발생한다.

css 속성별로 렌더링을 발생시키는 작업이 있다. 각 속성이 어떤 렌더링 과정을 일으키는지는 https://lab.skk.moe/css-triggers에서 확인할 수 있다.

처음으로 구현했던 방법은 left와 top속성을 직접 업데이트하는 것이었는데, Layout을 발생시키는 요소를 확인할 수 있다.
left 트리거

반대로 transform은 Composite만 발생시킨다. (Blink, 크롬기준)
transform 트리거

여기까지 transform이 실제로 Reflow작업을 방지해 성능을 개선한 것을 눈으로 알아봤다.

transform은 어떻게 처리될까?

transform은 합성 단계에서 처리된다. 합성 단계는 메인 쓰레드가 아닌, GPU를 이용해 레이어를 합성해 정확하게 화면에 그린다. 레이어는 video, canvas, 3d 또는 원근 변화 css 속성 등 사용시 생성된다.

즉, transform 속성을 사용하면 레이어를 생성한다. 그리고 GPU를 사용해 변경이 일어나면, 기존 레이어를 합성하여 더 빠르게 렌더링을 할 수 있다. 레이어를 이용하면 성능이 향상되지만, 메모리 관리 측면에서는 비싼 작업이므로 주의해야한다.

참고

https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work
https://blog.seokho.dev/ko/development/2021/03/08/ReflowRepaint.html
https://developer.mozilla.org/ko/docs/Glossary/Repaint
https://lab.skk.moe/css-triggers
https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work
https://web.dev/articles/speed-layers#introducing_layers
</div></div></a><a href="/드래그 이벤트 구현기1/"><div class="flex flex-col gap-[14px] w-full min-w-[210px] h-[323px] pt-4 pl-[14px] pr-[14px] rounded-xl border border-black bg-white"><div data-gatsby-image-wrapper="" class="gatsby-image-wrapper self-center min-w-[192px] w-full h-[145px] rounded-xl"><div aria-hidden="true" style="padding-top:55.729166666666664%"></div><img aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear" decoding="async" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIElEQVR42n2SW08TURSF+V8mqAREegMvYAxGEtTEoMQQhSiiRAhUaKfTFgq9QGuFTu+dFigtCmoElCg8gOIjiQ+amPgfPndb9MXSh5XJzpz5Zq29Tp0lrmCOOSqKixadNMyqNPhdnJ1zUR92c1qbxphwy3snrX/PVpElplJnXJjBFHViiSqYMio3FDd3e0J09YW49zjFSG+Wsb5lIqM63cEADVG7nK8BbNM8mAVoFqBZn6LLOkTwyUPe5nQOtrb4NZ3nx80AP29p+MRp/+tJricdGKIlQBXg1bSHNolSGpq0SRxrWT7mX7G7/Zmjg2+81xfQfRN8vR9kQFnkgqRoT6iYTnLYHpuRvVR20xi1oeY1fh9953BvF++YjdSolS876+zHcvSO5zijTcmHysmR2zWBHds/n3TyyGdlJxEW2DhX6puZHRgk/WyCfMTPlL5Jc8RVG9gRV8vuSsBmifI07GLjpZ/psedY+x8wfLubzlONjNzpEfdZTLIecy2g6YW0FlFoFXCTNGgvRvhUWOJw+w177zYY6LxGNjDP5nCIIdWBMV0qsEbLhpDjH/CcZsNeiLOeyZGYd/Nho0gqvMBKUGN7METvnFNSKP+1az5OWAZaUk6MMpTUotnL8S8n3eWfXEy46Mh4uCSzZdFevvgGuV7V1CJrMIjq7NEwniVNFMe7EhOlmVlJ4S1k8Bd1/KuVZ2Atx1yxugKrOt7lJL58mj+B6UXuYyQ9fAAAAABJRU5ErkJggg==" alt=""/><picture><source type="image/webp" data-srcset="/static/b25dfd39144083a82bdaf66033dd54b7/81950/thumbnail.webp 750w,/static/b25dfd39144083a82bdaf66033dd54b7/86e93/thumbnail.webp 1080w,/static/b25dfd39144083a82bdaf66033dd54b7/51b5c/thumbnail.webp 1366w,/static/b25dfd39144083a82bdaf66033dd54b7/a518e/thumbnail.webp 1920w" sizes="100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="100vw" decoding="async" loading="lazy" data-src="/static/b25dfd39144083a82bdaf66033dd54b7/61fb6/thumbnail.png" data-srcset="/static/b25dfd39144083a82bdaf66033dd54b7/27806/thumbnail.png 750w,/static/b25dfd39144083a82bdaf66033dd54b7/1af68/thumbnail.png 1080w,/static/b25dfd39144083a82bdaf66033dd54b7/eff31/thumbnail.png 1366w,/static/b25dfd39144083a82bdaf66033dd54b7/61fb6/thumbnail.png 1920w" alt="드래그 이벤트 구현기1"/></picture><noscript><picture><source type="image/webp" srcSet="/static/b25dfd39144083a82bdaf66033dd54b7/81950/thumbnail.webp 750w,/static/b25dfd39144083a82bdaf66033dd54b7/86e93/thumbnail.webp 1080w,/static/b25dfd39144083a82bdaf66033dd54b7/51b5c/thumbnail.webp 1366w,/static/b25dfd39144083a82bdaf66033dd54b7/a518e/thumbnail.webp 1920w" sizes="100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="100vw" decoding="async" loading="lazy" src="/static/b25dfd39144083a82bdaf66033dd54b7/61fb6/thumbnail.png" srcSet="/static/b25dfd39144083a82bdaf66033dd54b7/27806/thumbnail.png 750w,/static/b25dfd39144083a82bdaf66033dd54b7/1af68/thumbnail.png 1080w,/static/b25dfd39144083a82bdaf66033dd54b7/eff31/thumbnail.png 1366w,/static/b25dfd39144083a82bdaf66033dd54b7/61fb6/thumbnail.png 1920w" alt="드래그 이벤트 구현기1"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div><p class="h-[55px] text font-semibold text-pretty line-clamp-2">드래그 이벤트 구현기1</p><div class="w-full line-clamp-3 text-pretty" style="font-size:14px;line-height:16px;color:#666">
목차

목표 기능
구현 아이디어
상세 구현 내용
마무리

목표 기능

드래그 이벤트 구현

윈도우 창을 드래그 할 수 있는 기능이다. react-draggable 라이브러리를 이용하면 손쉽게 구현할 수 있지만 어떻게 구현해야 하는지 알아보기 위해 구현한다.

구현 아이디어

react-draggable 구현 참고하기

react-draggable 라이브러리를 사용하면 아이템을 드래그앤 드롭 이벤트를 쉽게 구현할 수 있다. 아이템은 CSS transform을 이용해 위치를 움직인다.

react-draggable 라이브러리는 어떻게 구현했는지 짧게 확인해보았다.

// /lib/Draggable.js

type DraggableState = {
  dragging: boolean,
  dragged: boolean,
  x: number, y: number,
  slackX: number, slackY: number,
  isElementSVG: boolean,
  prevPropsPosition: ?ControlPosition,
};

export type DraggableDefaultProps = {
  ...DraggableCoreDefaultProps,
  axis: &#x27;both&#x27; | &#x27;x&#x27; | &#x27;y&#x27; | &#x27;none&#x27;,
  bounds: Bounds | string | false,
  defaultClassName: string,
  defaultClassNameDragging: string,
  defaultClassNameDragged: string,
  defaultPosition: ControlPosition,
  scale: number,
};

export type DraggableProps = {
  ...DraggableCoreProps,
  ...DraggableDefaultProps,
  positionOffset: PositionOffsetControlPosition,
  position: ControlPosition,
};

class Draggable extends React.Component {
    // ...
  onDrag: DraggableEventHandler = (e, coreData) =&gt; {
    if (!this.state.dragging) return false;
    log(&#x27;Draggable: onDrag: %j&#x27;, coreData);

    const uiData = createDraggableData(this, coreData);

    const newState = {
      x: uiData.x,
      y: uiData.y,
      slackX: 0,
      slackY: 0,
    };
// ...

DraggableProps 보면 드래그 하는 상태(dragging, dragged)와 엘리먼트 위치(x, y)를 확인할 수 있다. 또 드래그 이벤트 구현체인 onDrag 메서드에서 createDraggableData 함수를 이용해 엘리먼트 위치를 업데이트한다.

createDraggableData 함수는 현재 위치, 이동한 델타 값 그리고 마지막 위치를 반환하고 있다.

// /lib/utils.positionFns.js

export function createDraggableData(draggable: Draggable, coreData: DraggableData): DraggableData {
  const scale = draggable.props.scale;
  return {
    node: coreData.node,
    x: draggable.state.x + (coreData.deltaX / scale),
    y: draggable.state.y + (coreData.deltaY / scale),
    deltaX: (coreData.deltaX / scale),
    deltaY: (coreData.deltaY / scale),
    lastX: draggable.state.x,
    lastY: draggable.state.y
  };

이를 통해 알 수 있는 것은 아이템의 현재 위치, 이동한 델타 값, 마지막 위치를 활용해서 위치를 업데이트 하는 것을 알 수 있다.

아이템 위치 업데이트하기

아이템의 현재 위치, 이동한 델타 값은 마우스 이벤트에서 제공하는 뷰포트의 좌표값인 clientX, clientY 를 사용하면 된다.

먼저 마우스가 이동한 델타값을 구해보자. 현재 마우스 위치 - 마지막 마우스 위치 을 계산하면 된다.

아이템의 위치는 아이템의 좌측 상단의 값으로 계산해줘야 한다. 아이템은 transform을 이용해 업데이트 하는데 transform의 기준은 아이템의 좌측 상단이기 때문이다. 현재 좌측 상단의 값 + 델타값 을 계산하면 된다.

드래그 위치

상세 구현 내용

드래그 앤 드롭이벤트 구현하기

드래그 앤 드롭 이벤트를 구현하기 위해 isDragging인 상태를 추가했다. 이 상태 값이 true인 경우 handleDrag 를 실행시킨다.

const [isDragging, setIsDragging] = useState(false);
const ref = useRef(null);

const handleDragStart = () =&gt; {
  setIsDragging(true);
};

const handleDragStop = () =&gt; {
  if (!isDragging) return;

  setIsDragging(false);
};

const handleDrag = () =&gt; {
  if (!ref.current) return;
  if (!isDragging) return;

  // TODO: 아이템 위치 업데이트
};

useEffect(() =&gt; {
  if (isDragging) {
    document.addEventListener(&#x27;mousemove&#x27;, handleDrag);
  }

  return () =&gt; {
    document.removeEventListener(&#x27;mousemove&#x27;, handleDrag);
  };
}, [isDragging]);

return (
    
      {children}
    
  );
}

아이템 위치 업데이트 하기

아이템 위치를 업데이트하기 위해 아이템의 현재 위치, 이동한 델타 값, 마지막 위치 값이 필요하다.

아이템의 현재 위치와 마지막 위치 정보를 저장하기 위해 position 과 last 상태 값을 추가했다.

// 아이템 위치
const [position, setPosition] = useState({
  x: 0,
  y: 0,
});
// 마지막 위치
const [last, setLast] = useState({
  x: defaultPosition.x,
  y: defaultPosition.y,
});

마우스가 이동한 델타 값은 현재 마우스 위치 - 마지막 마우스 위치 로 구할 수 있다.

const deltaX = e.clientX - last.x;
const deltaY = e.clientY - last.y;

마지막으로 아이템의 위치를 업데이트할 값인 좌측 상단의 값은 현재 좌측 상단의 값 + 델타값 로 구하면 된다.

const deltaX = position.x + e.clientX - last.x;
const deltaY = position.y + e.clientY - last.y;

구한 delta값으로 아이템의 위치를 업데이트 하면 끝이다.

ref.current.style.transform = translate(${deltaX}px, ${deltaY}px);

전체 코드는 이렇다.

const [isDragging, setIsDragging] = useState(false);
// 아이템 위치
const [position, setPosition] = useState({
  x: 0,
  y: 0,
});
// 마지막 위치
const [last, setLast] = useState({
  x: defaultPosition.x,
  y: defaultPosition.y,
});
const ref = useRef(null);

const handleDragStart = (
  e: MouseEvent | React.MouseEvent
) =&gt; {
  setLast({
    x: e.clientX,
    y: e.clientY,
  });
  setIsDragging(true);
};

const handleDragStop = (
  e: MouseEvent | React.MouseEvent
) =&gt; {
  if (!isDragging) return;

  setIsDragging(false);
};

const handleDrag = (e: MouseEvent) =&gt; {
  if (!ref.current) return;
  if (!isDragging) return;
  e.preventDefault();

  const deltaX = e.clientX - last.x + position.x;
  const deltaY = e.clientY - last.y + position.y;

  setPosition({ x: deltaX, y: deltaY });
  setLast({
    x: e.clientX,
    y: e.clientY,
  });

  ref.current.style.transform = translate(${deltaX}px, ${deltaY}px);
};

useEffect(() =&gt; {
  if (isDragging) {
    document.addEventListener(&#x27;mousemove&#x27;, handleDrag);
  }

  return () =&gt; {
    document.removeEventListener(&#x27;mousemove&#x27;, handleDrag);
  };
}, [isDragging]);

return (
    
      {children}
    
  );
}

화면 밖으로 벗어나지 않기

드래그는 이제 잘 된다! 그러나 아이템이 화면 밖으로 벗어나는 문제점이 있다. 상하좌우 밖으로 벗어나지 않도록 개선해보자.

화면 밖으로 나가기

상단 밖으로 벗어나는 경우

아이템의 초기 y + 델타 y 이 0보다 작은 경우 상단 밖으로 벗어나는 케이스이다. 아이템을 상단에 고정시키기 위해 -아이템의 초기 y 로 위치를 업데이트 하면 된다.

const fixToTop = (ref: HTMLDivElement) =&gt; {
  setPosition({ x: deltaX, y: -defaultPosition.y });
  setLast({
    x: e.clientX,
    y: e.clientY,
  });
  ref.style.transform = translate(${deltaX}px, ${-defaultPosition.y}px);
};

하단 밖으로 벗어나는 경우

아이템의 초기 y + 델타 y + 아이템의 높이 가 뷰포트의 높이보다 큰 경우 하단 밖으로 벗어나는 케이스이다. 아이템을 하단에 고정시키기 위해 뷰포트 높이 - 아이템 높이 - 아이템의 초기 y 로 위치를 업데이트 하면 된다.

const eleHeight = ref.current.clientHeight || 0;

const fixToBottom = (ref: HTMLDivElement) =&gt; {
  setPosition({
    x: deltaX,
    y: window.innerHeight - eleHeight - defaultPosition.y,
  });
  setLast({
    x: e.clientX,
    y: e.clientY,
  });
  ref.style.transform = `translate(${deltaX}px, ${
    window.innerHeight - eleHeight - defaultPosition.y
  }px)`;
};

좌측 밖으로 벗어나는 경우

아이템이 상단 밖으로 벗어나는 경우처럼 계산하면 된다.

const fixToLeftTop = (ref: HTMLDivElement) =&gt; {
  setPosition({ x: -defaultPosition.x, y: -defaultPosition.y });
  setLast({
    x: e.clientX,
    y: e.clientY,
  });
  ref.style.transform = translate(${-defaultPosition.x}px, ${-defaultPosition.y}px);
};

우측 밖으로 벗어나는 경우

아이템이 하단 밖으로 벗어나는 경우처럼 계산하면 된다.

const eleWidth = ref.current.clientWidth || 0;

const fixToRight = (ref: HTMLDivElement) =&gt; {
  setPosition({
    x: window.innerWidth - eleWidth - defaultPosition.x,
    y: deltaY,
  });
  setLast({
    x: e.clientX,
    y: e.clientY,
  });
  ref.style.transform = `translate(${
    window.innerWidth - eleWidth - defaultPosition.x
  }px, ${deltaY}px)`;
};

여기서 대각선 방향으로 벗어나는 경우까지 추가하면 외부로 벗어나지 않는 드래그 이벤트를 구현할 수 있다.

드래그 이벤트 구현

마무리

드래그 이벤트를 구현하면서 뷰포트, 마우스 좌표값을 활용하는 것을 익힐 수 있었다. 또한 라이브러리 의존성을 성공적으로 제거하여 구현 능력을 키울 수 있었다.
</div></div></a><a href="/useQuery를 만들어보자/"><div class="flex flex-col gap-[14px] w-full min-w-[210px] h-[323px] pt-4 pl-[14px] pr-[14px] rounded-xl border border-black bg-white"><p class="h-[55px] text font-semibold text-pretty line-clamp-2">useQuery를 만들어보자</p><div class="w-full line-clamp-3 text-pretty" style="font-size:14px;line-height:16px;color:#666">
들어가며

React Query는 제가 애정하는 라이브러리 중 하나입니다. 데이터 패칭 상태 관리를 마법 처럼 우아하게 처리하고 캐싱을 통해 불필요한 네트워크 요청을 줄여 리소스를 절약할 수도 있습니다. 예전에는 useEffect로 구현했는데 반복되는 중복 코드때문에 고민이 많았던 기억이 납니다.

그런데 React Query에 너무 익숙해진 나머지, 정작 useEffect로 데이터 패칭을 구현하는 방법을 잊어버렸습니다. 그래서 이번에는 useQuery 훅을 직접 구현해보며 학습한 과정을 정리해보겠습니다.

구현 목표

이렇게 4가지를 구현해보았습니다.

상태 관리: isPending, isError, data 상태를 관리
경쟁 상태 방지: 여러번의 요청이 발생해도 최신 데이터만 화면에 보여지도록 보장
캐싱: 캐싱된 데이터가 있으면 이를 우선적으로 보여주고, 데이터가 stale한 상태라면 새로운 데이터를 패치
retry 지원: 네트워크 요청 실패 시, 지정된 횟수만큼 재시도 할 수 있음

구현 과정

1. 상태 관리

useEffect를 사용해 isPending, isError, data 상태를 관리하는 기능을 구현하면서 무한 렌더링에 빠졌습니다.

useEffect 로직 내부에서 queryKey와 queryFn을 참조하여 react-hooks 린터 규칙에 따라 의존성 배열에 두 변수를 포함해야 합니다. 하지만 queryFn을 포함하면 무한 렌더링이 발생합니다.

이는 queryFn이 리렌더링이 될때마다 새로운 객체로 평가되기 때문에 무한 렌더링에 빠지게 됩니다. 그래서 이를 방지하기 위해 의존성 배열에 queryKey만 포함했습니다.

// useQuery.ts

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type UseQueryProps = {
  queryKey: string;
  queryFn: () =&gt; Promise;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function useQuery({
  queryKey,
  queryFn,
}: UseQueryProps) {
  const [isPending, setIsPending] = useState(true);
  const [data, setData] = useState();
  const [error, setError] = useState();

  useEffect(() =&gt; {
    setIsPending(true);
    setData(undefined);
    setError(undefined);

    try {
      const result = await queryFn();
      setData(result);
      setError(undefined);
      setIsPending(false);
    } catch (error) {
      setData(undefined);
      setError(error as TError);
      setIsPending(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [queryKey]);

  return {
    isPending,
    error,
    data,
  };
}

2. 경쟁 상태 방지

경쟁상태

만약에 동시에 여러 번의 요청이 발생했을 때 첫 번째 요청이 나중에 완료되면 두 번째 요청의 결과를 덮어씁니다.

이를 방지하기 위해 현재 컴포넌트가 활성상태인지 나타내는 active flag를 통해 해결할 수 있습니다.

새로운 요청이 발생할 때마다 active플래그를 true로 설정하고, 기존 요청에 대해서 클린업 함수를 실행해 false로 설정해 기존 요청의 결과를 무시합니다. 그러면 항상 마지막으로 요청한 요청에 대해서만 상태를 업데이트 하도록 보장할 수 있습니다.

// useQuery.ts

useEffect(() =&gt; {
  let active = true;
  setIsPending(true);
  setData(undefined);
  setError(undefined);

  const handleResult = (result: TData) =&gt; {
    // 활성 상태가 아님
    if (!active) return;

    setData(result);
    setError(undefined);
    setIsPending(false);
  };

  const handleError = (error: TError) =&gt; {
    // 활성 상태가 아님
    if (!active) return;

    setData(undefined);
    setError(error as TError);
    setIsPending(false);
  };

  try {
    const result = await queryFn();
    handleResult(result);
  } catch (error) {
    handleError(error as TError);
  }

  return () =&gt; {
    active = false;
  };
}, [queryKey]);

3. retry 구현

네트워크 요청 실패 시, MAXIMUM_RETRY만큼 재시도하도록 재귀적으로 fetchWithRetry를 호출했습니다.

// useQuery.ts

// ...
const fetchWithRetry = async (retry = 0) =&gt; {
  try {
    const result = await queryFn();
    handleResult(result);
  } catch (error) {
    if (retry + 1  {
  createdAt: Date; // 데이터 생성 시간
  cacheTime: number;
  value: TData;
}

export class QueryCache {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private static instance: QueryCache;
  private cache: Record&gt; = {};

  private constructor() {}

  static getInstance(): QueryCache {
    if (!QueryCache.instance) {
      QueryCache.instance = new QueryCache();
    }
    return QueryCache.instance;
  }

  writeCache({
    key,
    value,
    cacheTime,
  }: {
    key: string;
    value: TData;
    cacheTime: number;
  }) {
    this.cache[key] = { value, createdAt: new Date(), cacheTime };
  }

  readCache(key: string) {
    if (key in this.cache) {
      const cachedItem = this.cache[key];
      const isStale =
        new Date().getTime() - cachedItem.createdAt.getTime() &gt;
        cachedItem.cacheTime;
      if (isStale) {
        // 데이터 삭제
        this.#deleteCache(key);
        return null;
      } else {
        return cachedItem;
      }
    }
    return null;
  }

  #deleteCache(key: string): void {
    delete this.cache[key];
  }
}

// useQuery.ts

// ...
const handleResult = (result: TData) =&gt; {
  // 활성 상태가 아님
  if (!active) return;

  // 캐시에 저장
  if (cache) {
    queryCache.writeCache({ key: queryKey, value: result, cacheTime });
  }

  setData(result);
  setError(undefined);
  setIsPending(false);
};

// ...
const cachedData = queryCache.readCache(queryKey);
if (cache &amp;&amp; cachedData) {
  setData(cachedData.value as TData);
  setIsPending(false);
  setError(undefined);
} else {
  if (retry) {
    fetchWithRetry();
  } else {
    fetchWithoutRetry();
  }
}

전체코드

// queryCache.ts

interface CacheData {
  createdAt: Date; // 데이터 생성 시간
  cacheTime: number;
  value: TData;
}

export class QueryCache {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private static instance: QueryCache;
  private cache: Record&gt; = {};

  private constructor() {}

  static getInstance(): QueryCache {
    if (!QueryCache.instance) {
      QueryCache.instance = new QueryCache();
    }
    return QueryCache.instance;
  }

  writeCache({
    key,
    value,
    cacheTime,
  }: {
    key: string;
    value: TData;
    cacheTime: number;
  }) {
    this.cache[key] = { value, createdAt: new Date(), cacheTime };
  }

  readCache(key: string) {
    if (key in this.cache) {
      const cachedItem = this.cache[key];
      const isStale =
        new Date().getTime() - cachedItem.createdAt.getTime() &gt;
        cachedItem.cacheTime;
      if (isStale) {
        // 데이터 삭제
        this.#deleteCache(key);
        return null;
      } else {
        return cachedItem;
      }
    }
    return null;
  }

  #deleteCache(key: string): void {
    delete this.cache[key];
  }
}

// useQuery.ts

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type UseQueryProps = {
  queryKey: string;
  queryFn: () =&gt; Promise;
  cache?: boolean;
  cacheTime?: number;
  retry?: boolean;
};

const MAXIMUM_RETRY = 5; // 최대 retry 횟수
const DEFAULT_CACHE_TIME = 60 * 1000; // 캐시 디폴트 저장 시간, 1분

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function useQuery({
  queryKey,
  queryFn,
  cache,
  cacheTime = DEFAULT_CACHE_TIME,
  retry,
}: UseQueryProps) {
  const [isPending, setIsPending] = useState(true);
  const [data, setData] = useState();
  const [error, setError] = useState();
  const queryCache = useMemo(() =&gt; QueryCache.getInstance(), []);

  useEffect(() =&gt; {
    let active = true;
    setIsPending(true);
    setData(undefined);
    setError(undefined);

    const handleResult = (result: TData) =&gt; {
      // 활성 상태가 아님
      if (!active) return;

      // 캐시에 저장
      if (cache) {
        queryCache.writeCache({ key: queryKey, value: result, cacheTime });
      }

      setData(result);
      setError(undefined);
      setIsPending(false);
    };

    const handleError = (error: TError) =&gt; {
      // 활성 상태가 아님
      if (!active) return;

      setData(undefined);
      setError(error as TError);
      setIsPending(false);
    };

    const fetchWithRetry = async (retry = 0) =&gt; {
      try {
        const result = await queryFn();
        handleResult(result);
      } catch (error) {
        if (retry + 1  {
      try {
        const result = await queryFn();
        handleResult(result);
      } catch (error) {
        handleError(error as TError);
      }
    };

    const cachedData = queryCache.readCache(queryKey);
    if (cache &amp;&amp; cachedData) {
      setData(cachedData.value as TData);
      setIsPending(false);
      setError(undefined);
    } else {
      if (retry) {
        fetchWithRetry();
      } else {
        fetchWithoutRetry();
      }
    }

    return () =&gt; {
      active = false;
    };

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [queryKey, cache, cacheTime, retry]);

  return {
    isPending,
    error,
    data,
  };
}
</div></div></a><a href="/FSD로 코드 경계 그리기/"><div class="flex flex-col gap-[14px] w-full min-w-[210px] h-[323px] pt-4 pl-[14px] pr-[14px] rounded-xl border border-black bg-white"><div data-gatsby-image-wrapper="" class="gatsby-image-wrapper self-center min-w-[192px] w-full h-[145px] rounded-xl"><div aria-hidden="true" style="padding-top:62.28373702422145%"></div><img aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear" decoding="async" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVR42p2SW0/CQBCF+f+PvvkffNcXEx40GhVjQA0aDchFLi0tO5dtwZjjtIsGiAXjw6Sd2d1vz5zZGovgwzPO3zIcNJYYJorcC4q6WKgKiBW3fUZKAq+hXhW19YSZDMQbG1QCvBcX4JDvBzJD/QI+hxV1a5NH6gStcY7UlOp+haZIc7iojVn3GDSPSiVEVH5dMoBLx5gkjLlzZRflmgUzVwEXcNMmZq9HEIos97ZIEFOt4zo0urE8K2Gi+r+WVTOL3IbAq0FkcCtlfwQaIFsGmMF51gaNLsCTO8jkEvRet32JAeXXVjeB1iLFAyS9pnk4M+88OOmCpvdw8TMoeoAzMLkEztGP0moPTRn1rhFfHULnk/KCouXC22JghZflv3kiL6fQYSvUhHe1bH4tPreezdoBDkPycccunQZ4JXD9kFT4UyiOe5CoCx49Qebfr4F3ACuDQ4v9BrRzhvTxBBy9BZVbPn4BYJ6VlEM7qVUAAAAASUVORK5CYII=" alt=""/><picture><source type="image/webp" data-srcset="/static/d275c298c762d8b8e94f90601a2df767/4c146/fsd-%EC%A0%81%EC%9A%A9.webp 750w,/static/d275c298c762d8b8e94f90601a2df767/7e940/fsd-%EC%A0%81%EC%9A%A9.webp 867w" sizes="100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="100vw" decoding="async" loading="lazy" data-src="/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png" data-srcset="/static/d275c298c762d8b8e94f90601a2df767/fbddd/fsd-%EC%A0%81%EC%9A%A9.png 750w,/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png 867w" alt="FSD로 코드 경계 그리기"/></picture><noscript><picture><source type="image/webp" srcSet="/static/d275c298c762d8b8e94f90601a2df767/4c146/fsd-%EC%A0%81%EC%9A%A9.webp 750w,/static/d275c298c762d8b8e94f90601a2df767/7e940/fsd-%EC%A0%81%EC%9A%A9.webp 867w" sizes="100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="100vw" decoding="async" loading="lazy" src="/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png" srcSet="/static/d275c298c762d8b8e94f90601a2df767/fbddd/fsd-%EC%A0%81%EC%9A%A9.png 750w,/static/d275c298c762d8b8e94f90601a2df767/034c8/fsd-%EC%A0%81%EC%9A%A9.png 867w" alt="FSD로 코드 경계 그리기"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div><p class="h-[55px] text font-semibold text-pretty line-clamp-2">FSD로 코드 경계 그리기</p><div class="w-full line-clamp-3 text-pretty" style="font-size:14px;line-height:16px;color:#666">
들어가며

이번 프로젝트에서 코드의 유지보수성과 확장성을 높일 수 있는 FSD 아키텍처를 도입했습니다. 그 중 createPost 기능을 구현하며 기존 방식에서 느꼈던 문제점들과 FSD를 적용한 후 느낀 점을 회고해보려고 합니다.

FSD란?

FSD는 Feature-Sliced Design로 코드를 목적에 따라 애플리케이션 구조를 잡는 아키텍처 방법론입니다. 이를 통해 코드의 응집도를 높이고 결합도를 낮추어 프로젝트 유지보수성을 극대화하는 데 중점을 둡니다.

FSD의 주요 개념

fsd 계층 구조

레이어: 애플리케이션의 전반적인 구조를 7가지 계층(App, Pages, Features 등)으로 나눔.
슬라이스: 각 비즈니스 도메인에 맞게 코드를 분리.
세그먼트: 슬라이스와 레이어 내에서 목적별로 코드를 분리 (예: UI, API, Model).

FSD의 import 규칙은 상위 레이어가 하위 레이어를 참조 가능하다는 점과 슬라이스는 Public API를 가진다는 점이 핵심입니다.

FSD 구조를 적용한 createPost

FSD를 적용하여 createPost 기능을 다음과 같이 구조화했습니다.

FSD 구조 적용

pages/createPost/ui: 페이지의 UI 구성.
features/createPost/lib: 폼 유효성 검사 로직.
features/createPost/model: 상태 관리 및 데이터 모델 정의.
...

.
├── entities
│   └── post
│       ├── api
│       │   ├── createPostDto.ts
│       │   └── createPost.ts
│       └── ui
│           └── createForm.tsx
├── features
│   └── createPost
│       ├── lib
│       │   └── validateForm.ts
│       └── model
│           ├── tag.ts
│           ├── useFormState.ts
│           └── useTagInput.ts
└── pages
    └── createPost
        └── ui

기존 스타일과 비교

FSD를 적용하기 전에는 코드 타입별로 폴더를 분류했습니다. 기존 방식으로 createPost 기능을 재구성하면 다음과 같은 모습입니다

.
├── api
│   └── createPost
│       ├── index.ts
│       └── type.ts
├── components
│   ├── common
│   └── createPost
│       └── CreateForm.tsx
├── pages
│   └── createPost.tsx
├── hooks
│   ├── useFormState.ts
│   └── useImageInput.ts
├── libs
│   └── validateForm.ts
└── types
    └── post.ts

이 방식은 간단해 보이지만, 다음과 같은 문제점이 있었습니다:

타입 관리의 혼란: 특정 타입이 여러 곳에서 사용되더라도, 어디서 관리해야 하는지 모호함.
응집도 부족: 관련 코드가 분산되어, 하나의 기능을 수정하려면 여러 폴더를 오가야 했음.

FSD 적용 전후의 import 관계를 대략적으로 그려보았습니다.

FSD 적용 후: 기능병로 코드가 모여 있어 의존 관계가 단순해짐
fsd 적용

FSD 미적용: 코드가 분산되어 있어 의존 관계가 복잡함
fsd 미적용

정리

FSD는 러닝 커브가 높지만, 다음과 같은 이점을 제공합니다:

유지보수성 향상: 도메인별로 코드가 나뉘어 기능 수정이 용이.
응집도 증가: 관련 코드가 한곳에 모여 있어 가독성과 확장성이 개선.
결합도 감소: 코드 간 의존성이 줄어 변경 사항의 영향을 최소화.

참조:

https://feature-sliced.design/docs
https://velog.io/@teo/fsd
</div></div></a><a href="/Jest에선 성공인데 브라우저에선 실패/"><div class="flex flex-col gap-[14px] w-full min-w-[210px] h-[323px] pt-4 pl-[14px] pr-[14px] rounded-xl border border-black bg-white"><p class="h-[55px] text font-semibold text-pretty line-clamp-2">Jest에선 성공인데... 브라우저에선 실패?</p><div class="w-full line-clamp-3 text-pretty" style="font-size:14px;line-height:16px;color:#666">
import hashtagGif from &#x27;./해시태그입력.gif&#x27;;

프로젝트에서 한글 입력 시 마지막 글자가 지워지지 않는 IME 버그를 겪었습니다. “유닛 테스트에서 잡을 수 있었다면 좋았을 텐데…” 싶어 앞으로는 TDD도 해보자는 마음으로 Jest로 폼 테스트를 학습해봤습니다.
그런데 예상과 달리 Jest에선 이 문제가 드러나지 않고 테스트가 성공했습니다.

이번 글은 그 과정에서 배운 Jest 디바운스 테스트와 API 모킹 경험, 그리고 브라우저 환경에서의 E2E 테스트가 필요한 이유를 정리한 글입니다.

테스트할 기능

테스트할 기능은 입력 후 API 호출로 메타데이터를 불러오는 기능입니다.

링크미리보기.gif

사용자가 링크를 입력한다.
해당 링크로 API 요청을 보내 메타데이터를 가져온다.
결과를 화면에 표시한다.

여기서 입력이 변경될 때마다 불필요한 API 요청이 발생하지 않도록 2000ms 디바운스를 적용했습니다.

디바운스 모방하기

const urlInput = screen.getByLabelText(&#x27;링크&#x27;);

fireEvent.change(urlInput, { target: { value: &#x27;https://www.naver.com/&#x27; } });
await act(async () =&gt; {
  jest.advanceTimersByTime(2000); // 디바운스 적용
});

jest.advanceTimersByTime(ms) : 지정한 ms만큼 시간이 흐른 것처럼 시뮬레이션

테스트 후에는 타이머를 초기화해줍니다.

afterEach(() =&gt; {
  jest.clearAllTimers();
  jest.useRealTimers();
});

API 요청 mocking하기

실제 API 호출을 막기 위해 msw로 응답을 모킹했습니다.

const handlers = [
  rest.get(${API_BASE_URL}/link/metadata, (req, res, ctx) =&gt; {
    return res(
      ctx.status(200),
      ctx.json({
        metaDescription: &#x27;링크 설명&#x27;,
        metaThumbnail: &#x27;링크 썸네일&#x27;,
        metaTitle: &#x27;링크 타이틀&#x27;,
        titleText: &#x27;타이틀 텍스트&#x27;,
      })
    );
  }),
];

해시태그 입력 테스트하기

엔터 키 입력 시 해시태그가 추가되도록 구현했습니다. 아래 이미지처럼 현재 한글로 해시태그를 입력하는 경우에는 마지막 글자인 ‘녕’이 input에 남아있는 문제가 있습니다.



문제 시나리오에 대해서 테스트 코드를 작성했습니다.

describe(&#x27;해시 태그 입력 테스트&#x27;, () =&gt; {
  test (&#x27;여러 개의 해시 태그를 입력하면, 입력한 해시 태그의 수만큼 Chip 컴포넌트가 렌더링된다.&#x27;,
  // 해시태그 추가
  fireEvent.change(tagInput, { target: { value: &#x27;안녕&#x27; } });
  fireEvent.keyDown(tagInput, { key: &#x27;Enter&#x27; });
  // input value가 빈값이어야 함
  expect(tagInput.value).toBe(&#x27;&#x27;):


  // 연달아 새로운 해시태그 추가
  fireEvent.change(tagInput, { target: { value: &#x27;하이&#x27; } });
  fireEvent.keyDown(tagInput, { key: &#x27;Enter&#x27; });
  // input value가 빈값이어야 함
  expect (tagInput.value).toBe(&#x27;&#x27;);
  // ...

하지만 테스트 결과는 실패하지 않고, 성공하고 말았습니다... 양성거짓

Jest에서는 왜 성공할까?

한글이 input에 여전히 남는 원인은 IME 입니다. ㅇ ㅑ ㅎ ㅗ 를 순서대로 입력하면 자음과 모음을 조합해 야호 를 출력합니다. 브라우저에서는 이 조합 과정을 compositionstart, compositionend같은 이벤트가 발생합니다. 하지만, Jest는 `야호’라는 value의 값을 넣었을 때, 이미 조합이 완료된 값을 넣으므로 마지막 글자가 남지 않아 해당 버그는 재현되지 않습니다.

브라우저 E2E 테스트 필요성

Jest만으론 브라우저가 가진 특징을 재현하기 어려운걸 깨달았습니다. 이를 보완할 수 있는 Cypress나 Playwright와 같은 E2E 도구의 필요성을 느꼈습니다.

참고

https://ko.wikipedia.org/wiki/입력기
https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionstart_event
https://ui.toast.com/posts/ko_20220624
https://minjung-jeon.github.io/IME-keyCode-229-issue/
</div></div></a><a href="/type-challenges/medium/"><div class="flex flex-col gap-[14px] w-full min-w-[210px] h-[323px] pt-4 pl-[14px] pr-[14px] rounded-xl border border-black bg-white"><p class="h-[55px] text font-semibold text-pretty line-clamp-2">[type-challenges] medium 도전</p><div class="w-full line-clamp-3 text-pretty" style="font-size:14px;line-height:16px;color:#666">
Get Return Type

문제

내장 제네릭 ReturnType을 이를 사용하지 않고 구현하자

코드

// 아쉬운 정답
type MyReturnType unknown&gt; =
  T extends (...args:any) =&gt; infer U
      ? U
      : never;

함수 인자 타입을 never[] 로 하면 모든 테스트 케이스가 통과된다.

// 정답
type MyReturnType unknown&gt; =
  T extends (...args: never[]) =&gt; infer R
    ? R
    : never

해설

리턴되는 타입을 infer U로 추론하고 U를 반환한다. 하지만 함수 인수를 받는 타입을 unknown[] 으로 하면 테스트 케이스가 일부만 통과해서 any로 변경해 모두 통과되도록 했다.

unknown[]이 안되는 이유

unknown 은 모든 타입의 상위 타입이므로 모든 타입은 unknown에 할당할 수 있다. 그렇기 때문에 unknown 은 가장 일반적인 타입이기 때문에 구체적인 타입과 호환되지 않는다.

type foo = unknown extends string ? true : false; // false

never[] 를 사용하는 이유

never는 존재하지 않는 공집합이기 때문에 any를 포함해 어떤 값도 가질 수 없는 가장 구체적인 타입이어서 다른 타입들과 호환될 수 있다.

type foo = never extends string ? true : false; // true

Omit

문제

T에서 K 프로퍼티만 제거해 새로운 오브젝트 타입을 만드는 내장 제네릭 Omit를 이를 사용하지 않고 구현하자.

코드

T의 프로퍼티 키에서 K가 아니라면 키값을 추출하는 코드를 의도했다. 이 코드는 infer의 잘못된 사용으로 동작하지 않는다.

// 오답
type MyOmit = K extends infer Key keyof T ?
  never :
  { Key: T[Key] }

정답 코드는 이렇다.

// 정답
type MyOmit = {[Key in keyof T as Key extends K ? never: Key]: T[Key]}

해설

as 키워드

as 키용해 이용해 맵드 타입의 키를 다시 매핑할 수 있다. 예를들어 모든 프로퍼티 키를 Hamster라고 키 이름을 다시 매핑할 수 있다.

type MappedTypeWithNewProperties = {
    [Properties in keyof Type as &#x27;Hamster&#x27;]: Type[Properties]
}

Readonly 2

문제

T에서 K 프로퍼티만 읽기 전용으로 설정해 새로운 오브젝트 타입을 만드는 제네릭 MyReadonly2를 구현하세요. K가 주어지지 않으면 단순히 Readonly처럼 모든 프로퍼티를 읽기 전용으로 설정해야 합니다.

코드

type MyReadonly2 = { readonly [k in K]: T[k] } &amp; Omit;

해설

K 프로퍼티는 readonly 속성을 부여하면 된다. 구현은 정답을 참고했다.

K가 주어지지 않는 경우를 위해 K extends keyof T = keyof T default 값을 설정한다.

교차 타입 &amp;

두 개 이상의 타입을 결합해 모든 타입의 속성을 포함하는 새로운 타입을 생성할 수 있다. A &amp; B는 A와 B의 모든 속성을 포함하는 새로운 타입이 된다.

유니온 타입 |

두 개 이상의 타입 중 하나를 선택할 수 있는 새로운 타입을 생성한다. A | B 는 A또는 B 중 하나의 타입을 가질 수 있다.

Deep Readonly

문제

객체의 프로퍼티와 모든 하위 객체를 재귀적으로 읽기 전용으로 설정하는 제네릭 DeepReadonly를 구현하세요.

이 챌린지에서는 타입 파라미터 T를 객체 타입으로 제한하고 있습니다. 객체뿐만 아니라 배열, 함수, 클래스 등 가능한 다양한 형태의 타입 파라미터를 사용하도록 도전해 보세요.

코드

중첩된 객체 프로퍼티의 타입을 반환하는 타입은 만들었는데 다음은 어떻게 해야할까?

// 오답
type DeepReadonly = T extends object ? DeepReadonly : T

정답을 참고해서 readonly 타입을 반환하도록 했는데, 중첩된 객체에서는 readonly가 안된다. (아래 코드가 왜 잘못됐는지 모르겠다🥲 )

// 오답
type DeepReadonly = T extends Record ?
  { readonly [P in keyof T]: DeepReadonly }
  :
  T;

type x = DeepReadonly;

// 결과
// type x = {
//  readonly l: [&quot;hi&quot;, {
//      m: [&quot;hey&quot;];
//    }];
//  }

// 기댓값
// type x = {
//  readonly l: readonly [&quot;hi&quot;, {
//      readonly m: readonly [&quot;hey&quot;];
//    }];
//  }

정답 코드를 보면 T에 프로퍼티 키로 접근할 수 있는 값이 없다면 T\[K\]를 반환하고 그렇지 않다면 재귀적으로 DeepReadonly 를 호출한다.

// 정답
type DeepReadonly = {
  readonly [K in keyof T]: keyof T[K] extends never ? T[K] : DeepReadonly
}

해설

TypeScript 에서 {} vs Object vs object

{} 는 빈 객체가 아닌 any non-nullsih value이므로 undefined, null을 제외한 모든 타입을 할당할 수 있다.
Object 도 {} 와 동일하다.
object 는 원시값을 제외한 모든 값이 할당 가능하다.

빈 객체{} 타입만을 허용하고 싶다면 never를 사용하자. 자바스크립트의 객체 타입(중괄호로 이루어진 객체)만을 허용하고 싶다면 Record를 사용하면 된다.

mind_타입스크립트는 어렵네요_

문제 풀기에 앞서…

문제 풀기에 앞서 아직 헷갈리는 내용을 짚고 넘어가보자.

정적 타입 검사:

타입스크립트는 프로그램을 실행시키지 않고 오류를 검출한다.

점진적 타입 시스템:

타입스크립트는 타입 검사를 점진적으로 적용해 동적 타입처럼 자유롭게 타입을 작성할 수 있다.

let a = 10;  // 타입스크립트가 자동으로 number로 추론 (자동 타입 추론)
let b;       // 타입 명시가 없으므로 b는 암시적으로 any 타입을 가짐
b = &quot;hello&quot;; // b에 어떤 값이든 할당 가능 (any 타입)
b = 42;      // any 타입이기 때문에 타입 오류 없음

구조적 타입 시스템이란:

타입스크립트 컴파일러는 두 타입의 명시적 선언이 아닌 프로퍼티를 비교하여 타입을 비교한다. 그러니까 타입 Hamster과 Animal이 있을 때, Hamster ⊂ Animal를 만족한다. Hamster의 프로퍼티는 Animal를 만족시키기 때문에 Hamster타입에 Animal을 할당할 수 있고 Hamster은 Animal타입과 호환이 가능하다.

Indexed Access Type:

인덱스를 사용해 객체의 프로퍼티 타입을 추출할 수 있다. 배열 요소의 타입을 가져오려면 Foo[number] 로 하면 된다.

infer:

조건부 타입의 extends 절 안에서 infer을 이용해 타입 변수를 추론할 수 있다. 이렇게 추론된 타입은 분기에서 참조될 수 있다.

Tuple to Union

튜플 값으로 유니온 타입을 생성하는 제네릭 TupleToUnion를 구현하세요.

배열의 인덱스를 number로 접근해서 타입을 가져오면 된다.

type TupleToUnion = T[number];

Chainable Options

체인 가능 옵션은 일반적으로 Javascript에서 사용됩니다. 하지만 TypeScript로 전환하면 제대로 구현할 수 있나요?
이 챌린지에서는 option(key, value)과 get() 두가지 함수를 제공하는 객체(또는 클래스) 타입을 구현해야 합니다. 현재 타입을 option으로 지정된 키와 값으로 확장할 수 있고 get으로 최종 결과를 가져올 수 있어야 합니다.

너무 어려워서 정답을 봤다. R 타입은 option 메서드로 점진적으로 타입이 확장된다.

type Chainable = {
  option(
    key: K extends keyof T
         ? (V extends T[K] ? never : K)
         : K,
    value: V
  ): Chainable &amp; Record&gt;; // Omit K from T
  get(): T;
}

declare

문제에서 a를 declare로 선언했는데, declare에 대해 알아보자.

declare const a: Chainable

declare는 타입이나 값을 설명하기 위해 사용할 수 있다. 변수, 객체, 함수 또는 외부 모듈 등에서 타입 정보를 제공하는 용도로 사용할 수 있다. declare 키워드로 선언된 변수는 javascript로 컴파일되지 않는다.

Last of Array

배열 T를 사용하고 마지막 요소를 반환하는 제네릭 Last를 구현합니다.

T[length - 1] 식으로 접근하고 싶은데, 타입스크립트는 런타입 값을 알 수 없기 때문에 계산이 안된다.

정답 코드에서는 새로운 배열을 만들고, 이 배열의 T[&#x27;length&#x27;] 를 접근한다.

type Last = unknown, ...T]

Pop

배열 T를 사용해 마지막 요소를 제외한 배열을 반환하는 제네릭 Pop를 구현합니다.

infer로 추론하고 P를 반환하면 된다.

type Pop = T extends [...infer P, unknown] ? P : [];

Shift, Push, Unshift 구현하기

type Shift = T extends [unknown, ...infer P] ? P : [];

type Push = [...T, X];

type Unshift = [X, ...T];

Promise.all

Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array.

09번은 너무 어려워서 패스하고 다음에 도전해본다!

Type Lookup

때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다.
이 챌린지에서는 유니온 타입 Cat | Dog에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 LookUp으로 Dog 타입을, LookUp으로 Cat 타입을 얻을 수 있습니다.

type LookUp = U extends { type: T } ? U : never;

Shift, Push, Unshift 구현하기

type Shift = T extends [unknown, ...infer P] ? P : [];

type Push = [...T, X];

type Unshift = [X, ...T];

Promise.all

Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise where T is the resolved result array.

09번은 너무 어려워서 패스하고 다음에 도전해본다!

Type Lookup

때때로 유니온 타입의 특정 속성을 기준으로 조회할 수도 있습니다.
이 챌린지에서는 유니온 타입 Cat | Dog에서 공통으로 사용하는 type 필드를 기준으로 해당하는 타입을 얻고자 합니다. 다시 말해서, 다음 예시에서는 LookUp으로 Dog 타입을, LookUp으로 Cat 타입을 얻을 수 있습니다.

type LookUp = U extends { type: T } ? U : never;

Trim Left

정확한 문자열 타입이고 시작 부분의 공백이 제거된 새 문자열을 반환하는 TrimLeft를 구현하십시오.

빈 공백을 제거하고 재귀적으로 trim을 하려고 했는데 U는 string이 아니라 배열 타입이 되므로 오답이다.

type TrimLeft = S[number] extends [&#x27; &#x27;, ...infer U] ?  TrimLeft : S;

리터럴을 이용해 처리할 수 있다.

type Space = &#x27; &#x27; | &#x27;\t&#x27; | &#x27;\n&#x27;;
type TrimLeft = S extends ${Space}${infer U} ?  TrimLeft : S;

Trim

정확한 문자열 타입이고 양쪽 끝의 공백이 제거된 새 문자열을 반환하는 Trim를 구현하십시오.

TrimLeft 코드에서 분기 처리를 추가하면 된다.

type Space = &#x27; &#x27; | &#x27;\t&#x27; | &#x27;\n&#x27;;

type Trim = S extends ${Space}${infer U}
  ? Trim
  : S extends ${infer T}${Space}
  ? Trim
  : S;

유니언으로 처리하면 더 깔끔하게 처리할 수 있다.

type Space = &#x27; &#x27; | &#x27;\t&#x27; | &#x27;\n&#x27;;

type Trim = S extends ${Space}${infer T} | ${infer T}${Space} ? Trim : S;

Capitalize

문자열의 첫 글자만 대문자로 바꾸고 나머지는 그대로 놔두는 Capitalize를 구현하세요.

Capitalize 인터페이스를 사용하면 된다.

type MyCapitalize = S extends ${infer X}${infer T} ? ${Capitalize}${T} : S;

Replace

문자열 S에서 From를 찾아 한 번만 To로 교체하는 Replace를 구현하세요.

리터럴 타입을 이용해 조건부로 넘겼지만, From이 &#x27;&#x27; 케이스인 경우 통과하지 않는다.

type Replace = S extends ${From}${infer T}
  ? ${To}${T}
  : S extends ${infer T}${From}${infer X}
  ? ${T}${To}${X}
  : S;

From이 공백 문자열인지 확인하는 분기를 추가하면 된다.

type Replace = From extends &#x27;&#x27;
  ? S
  : S extends ${From}${infer T}
  ? ${To}${T}
  : S extends ${infer T}${From}${infer X}
  ? ${T}${To}${X}
  : S;

ReplaceAll

주어진 문자열 S에서 부분 문자열 From을 찾아 모두 To로 교체하는 제네릭 ReplaceAll을 구현하세요.

Replace 코드에 재귀적으로 타입을 호출했는데, 이미 교체한 문자열에도 교체를 진행해 foobarfoobar 테스트 케이스를 통과하지 못한다.

type ReplaceAll = From extends &#x27;&#x27;
  ? S
  : S extends ${infer T}${From}${infer X}
  ? ReplaceAll
  : S extends ${From}${infer T}
  ? ReplaceAll
  : S;

리터럴 타입 내부에서 ReplaceAll 타입을 재귀적으로 호출하면 된다.

type ReplaceAll = From extends &#x27;&#x27;
  ? S
  : S extends ${infer R1}${From}${infer R2}
  ? ${R1}${To}${ReplaceAll}
  : S

Append Argument

함수 타입 Fn과 어떤 타입 A가 주어질 때 Fn의 인수와 A를 마지막 인수로 받는 Fn과 동일한 함수 유형인 G를 생성하세요.

Fn의 인자 타입을 추론하고 A를 추가하고자 아래처럼 작성했는데, 문법상에 오류가 있다.

type AppendArgument unknown, A&gt; = Fn extends (...X: any[]) =&gt; unknown ? (...X, A) =&gt; unknown : false;

arguments를 올바르게 타입을 추론하면 된다.

type AppendArgument = Fn extends (...args: infer T) =&gt; infer U ? (...arg: [...T, A]) =&gt; U : never;

arguments 객체

arguments 객체는 함수에 전달된 인수에 해당하는 Array 형태의 객체이다.

function foo(a, b, c){
    console.log(arguments[0] === a);
    console.log(arguments[1] === b);
    console.log(arguments[2] === c);
}

타입 챌린지는 임시 중단합니다.

다양한 타입을 만드는건 재미있지만 자주 쓰이는 케이스로 타입스크립트를 학습하겠습니다~
</div></div></a><a href="/type-challenges/easy/"><div class="flex flex-col gap-[14px] w-full min-w-[210px] h-[323px] pt-4 pl-[14px] pr-[14px] rounded-xl border border-black bg-white"><p class="h-[55px] text font-semibold text-pretty line-clamp-2">[type-challenges] easy 도전</p><div class="w-full line-clamp-3 text-pretty" style="font-size:14px;line-height:16px;color:#666">
PICK-4

문제

pick을 사용하지 않고 Pick을 구현하는 문제이다.

keyof 는 객체의 키 값들을 숫자나 문자열 리터럴 유니언을 생성한다.
in 는 객체에 특정 속성이 존재하는지 확인할 수 있다.

코드

type MyPick = {
  [k in K]: T[k]
}

풀이

K extends keyof T K는 T의 프로퍼티 이름을 가진다. 매핑된 타입을 이용하면 키를 통해 타입을 반복적으로 생성할 수 있고 인덱스 시그니처 문법으로 작성하면 된다.

Readonly

문제

Readonly 타입을 사용하지 않고 구현하는 문제이다.

readonly 는 프로퍼티를 읽기 전용으로 지정할 수 있다.

코드

type MyReadonly = {
  readonly [P in keyof T]: T[P]
}

Tuple to Object

문제

각 원소의 값을 key/value로 갖는 오브젝트 타입을 반환하는 타입을 구현하는 문제이다.

// 배열의 원소의 값을 key/value로 갖는 타입을 반환한다.
[&#x27;tesla&#x27;, &#x27;model 3&#x27;, &#x27;model X&#x27;, &#x27;model Y&#x27;]

{ &#x27;tesla&#x27;: &#x27;tesla&#x27;, &#x27;model 3&#x27;: &#x27;model 3&#x27;, &#x27;model X&#x27;: &#x27;model X&#x27;, &#x27;model Y&#x27;: &#x27;model Y&#x27;}

코드

type TupleToObject = {
  [P in T[number]] : P
}

풀이

배열 순회하기: T[number]을 통해 배열을 순회하여 타입을 가져올 수 있다. T[number] 은 인덱스가 숫자형인 요소들의 타입을 가져오므로 배열에 있는 모든 요소의 타입을 가져올 수 있다.
PropertyKey: keyof 를 통해 생성되는 key의 집합이다. 여기에는 string, number, symbol이 있다.

First of Array

문제

T를 받아 첫번째 원소의 타입을 반환하는 제네릭 First를 구현하는 문제이다.

코드

// 오답: 빈 배열인 경우 T[0]은 undefeind가 된다
type First = T[0] extends never ? never : T[0]; // 원소가 없다면 never 타입 반환

// 정답1
type First = T[number] extends never ? never : T[0];
// 정답2
type First = T extends [] ? never : T[0];

풀이

조건부 타입: 배열이 빈 배열이라면 never 타입을 반환한다.

Length of Tuple

문제

튜블(배열)의 길이를 반환하는 제네릭 타입을 구현하는 문제이다.

코드

// 오답: Length인 경우 타입 에러가 나지 않는다.
type Length = T extends readonly unknown[] ? T[&#x27;length&#x27;] : never;

` 는 T가 readonly unknown[ ]`이라는 타입을 반드시 만족해야 하므로 배열이 아닌 경우 타입 에러를 발생한다.

// 정답
type Length = T[&quot;length&quot;];

풀이

readonly: 튜플은 고정된 요소를 저장하므로 readonly이다.

T extends readonly unknown[] 에서 T가 배열 타입인지 조건부로 타입을 할당한다. 이런 경우 배열이 아닌 경우 never를 반환하기 때문에 타입 에러가 나지 않는다.

Exclude

문제

T에서 U에 할당할 수 있는 타입을 제외하는 내장 제네릭 Exclude를 사용하지 않고 구현하는 문제이다.

코드

type MyExclude = T extends U ? never : T;

풀이

Exclude: Exclude 는 U에 할당할 수 있는 타입을 제외한다. 차집합으로 이해할 수 있다.
분배법칙: 조건부 타입에서 분배법칙이 적용된다. 예를 들어 A | B | C extends U ? X : Y 는 A extends U ? X : Y, B extends U ? X : Y, C extends U ? X : Y 가 된다. T extends U ? X : Y 에서 T 유니언 타입은 개별 구성 요소를 확인한다.

T가 U에 속한다면, never를 반환한다.

Awaited

문제

Promise와 같은 타입에 감싸인 타입이 있을 때, 안에 감싸인 타입이 무엇인지 가르키는 타입을 구현하는 문제이다.

코드

type MyAwaited = T extends PromiseLike ? MyAwaited : T;

풀이

Promise에 감싸진 리턴 타입을 반환하기 위해 T가 Promise라면 Promise를 재귀적으로 풀어주고 그렇지 않다면 T를 반환하면 된다.

예를 들어 타입 X에서 Promise로 감싸진 타입을 가져올 때 다음처럼 동작한다.

type MyAwaited = T extends PromiseLike ? MyAwaited : T;

type X = Promise
type Foo = MyAwaited // string

MyAwaited&gt;은 PromiseLike타입에 해당하므로 다시 MyAwaited 을 호출한다. 여기서 infer D 로 string을 추론한다. MyAwaited 은 PromiseLike타입이 아니므로 타입 string을 반환한다.

infer란?

조건부 타입에서 infer 키워드를 이용해 새로운 타입 변수를 선언적으로 정의할 수 있다. type Flatten = Type extends Array ? Item : Type;

Promise가 아닌 PromiseLike를 사용하는 이유

Promise가 아닌 PromiseLike를 사용하는 이유는 아래 테스트 케이스가 존재하기 때문이다.

type T = { then: (onfulfilled: (arg: number) =&gt; any) =&gt; any }

PromiseLike타입에는 후속처리 메서드인 then만 가지고 있다. 이를 통해 커스텀 비동기 처리를 유연하게 정의할 수 있다.

// https://github.com/microsoft/TypeScript/blob/main/src/lib/es5.d.ts

interface PromiseLike {
    /**
     Attaches callbacks for the resolution and/or rejection of the Promise.
     @param onfulfilled The callback to execute when the Promise is resolved.
     @param onrejected The callback to execute when the Promise is rejected.
     @returns A Promise for the completion of which ever callback is executed.
     */
    then(
        onfulfilled?: ((value: T) =&gt; TResult1 | PromiseLike) | undefined | null,
        onrejected?: ((reason: any) =&gt; TResult2 | PromiseLike) | undefined | null
      ): PromiseLike;
}

If

문제

조건 C가 참이면 A, 아니면 B를 반환하는 타입을 구현하자.

코드

type If = C extends true ? T : F;

풀이

C는 true, false만 가능하도록 boolean 타입으로 제한하고 C 조건에 따라 T, F를 리턴하면 된다.

Concat

문제

Array.concat 함수를 타입 시스템에서 구현하자. 인수를 왼쪽부터 concat한 새로운 배열을 반환하자.

코드

// 오답
type Concat = [
  T extends [] ? never : T[number],
  U extends [] ? never : U[number]
];

type Foo = Concat; // [2 | 3 | &quot;1&quot;, never]

// 정답
type Tuple = readonly unknown[];
type Concat = [...T, ...U];

type Foo = Concat; //  [&quot;1&quot;, 2, 3]

풀이

T와 U를 concat할 수 있도록 T와 U를 배열로 타입을 제한했다. 요소의 타입으로 이루어진 튜플을 반환할 수 있도록 T[number] 를 했다. 그러나 T[number]는 배열의 요소 타입으로 이뤄진 유니언 타입을 추출한다. 그리고 빈 배열인 경우 never 타입이 반환되므로 오답이다.

여기서 T와 U를 배열타입으로 제한했으므로 열거 가능하다.

Includes

문제

JavaScript의 Array.includes 함수를 타입 시스템에서 구현하세요. 타입은 두 인수를 받고, true 또는 false를 반환하자.

코드

// 오답
type Includes = U extends T[number] ? true : false;

T 배열의 요소를 키로 갖는 타입을 만들고 U가 T의 키인지 확인하면 해결할 수 있을 것 같지만, U가 프로퍼티 키로 사용할 수 있을 때만 통과된다. (참고)

// 오답
type Includes = {
  [P in T[number]]: true
}[U] extends true ? true : false;

이를 해결하기 위해 배열의 첫번째 요소와 타입이 같은지 재귀적으로 타입을 확인해야 한다.

// 정답
type Includes =
  T extends [infer First, ...infer Rest]
    ? Equal extends true ? true : Includes
    : false;

풀이

U가 T의 구성 요소인지 확인하기 위해 T를 인덱스 접근 타입으로 변경하고 U가 이 유니온 타입에 속하는지 조건부로 true 또는 false를 반환한다. 그런데 이 코드는 primitive type만 통과하고 객체나 타입 자체는 통과하지 않는다. 예를 들어 { a: &#x27;A&#x27;} 는 { }의 서브 타입으로 true를 반환한다.

infer 키워드를 복습하고 가자. infer은 조건부 타입에서 참으로 평가될 때 사용할 수 있는 타입을 추론하는 데 사용한다.

참고로 @type-challenges/utils 의 Equal은 아래처럼 구현되어 있다.

Equal =
    (() =&gt; T extends X ? 1 : 2) extends
    (() =&gt; T extends Y ? 1 : 2) ? true : false;

Push

문제

Array.push의 제네릭 버전을 구현하자.

코드

type Push = [...T, U];

풀이

T를 배열로 타입을 제한하고 배열 디스트럭쳐링을 이용해 배열 타입을 반환한다.

Unshift

문제

Array.unshift의 타입 버전을 구현하자.

코드

type Unshift = [U, ...T];

풀이

Push 문제와 동일하다. T와 U 순서만 바꿔주면 된다.

Parameters

문제

내장 제네릭 Parameters를 이를 사용하지 않고 구현하자.

코드

type MyParameters = T extends (...args: infer D) =&gt; unknown ? D : any;

const temp = [&#x27;1&#x27;];
type x = MyParameters; // 타입 에러가 나지 않는다.

타입 에러가 나지 않는데, 이를 막으려면 타입 T를 함수로 제한하면 된다.

type MyParameters any&gt; = T extends (...any: infer S) =&gt; any ? S : any

풀이

조건부 타입으로 함수 타입이라면 args를 추론한 D 타입을 반환한다. 하지만 T타입이 함수로 제한하지 않아 함수가 아닌 타입에서 에러가 나지 않아서 아쉽다.
</div></div></a></div></div></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-14437606d336ce945417.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-69b29e4925ee113b91b2.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-f6b1536cd8a70b2d388f.js\"],\"component---src-pages-resume-tsx\":[\"/component---src-pages-resume-tsx-64d268fcd103ac1098e1.js\"],\"component---src-templates-post-tsx-content-file-path-src-content-fsd-적용-후기-index-mdx\":[\"/component---src-templates-post-tsx-content-file-path-src-content-fsd-적용-후기-index-mdx-7c7f2eb1f7aa6e7bd5bb.js\"],\"component---src-templates-post-tsx-content-file-path-src-content-jest에선-성공인데-브라우저에선-실패-index-mdx\":[\"/component---src-templates-post-tsx-content-file-path-src-content-jest에선-성공인데-브라우저에선-실패-index-mdx-eee30e66226e65807b12.js\"],\"component---src-templates-post-tsx-content-file-path-src-content-type-challenges-easy-index-mdx\":[\"/component---src-templates-post-tsx-content-file-path-src-content-type-challenges-easy-index-mdx-18e52fa0a5ff616278b3.js\"],\"component---src-templates-post-tsx-content-file-path-src-content-type-challenges-medium-index-mdx\":[\"/component---src-templates-post-tsx-content-file-path-src-content-type-challenges-medium-index-mdx-64f191ab0de31cd7553a.js\"],\"component---src-templates-post-tsx-content-file-path-src-content-use-query를-만들어보자-index-mdx\":[\"/component---src-templates-post-tsx-content-file-path-src-content-use-query를-만들어보자-index-mdx-a323b35f853d27fb9a20.js\"],\"component---src-templates-post-tsx-content-file-path-src-content-드래그-이벤트-구현기-1-index-mdx\":[\"/component---src-templates-post-tsx-content-file-path-src-content-드래그-이벤트-구현기-1-index-mdx-24d2c3cdc072f281831d.js\"],\"component---src-templates-post-tsx-content-file-path-src-content-드래그-이벤트-구현기-2-왜-transform은-더-빠를까-index-mdx\":[\"/component---src-templates-post-tsx-content-file-path-src-content-드래그-이벤트-구현기-2-왜-transform은-더-빠를까-index-mdx-78bc7c77b34b03738c21.js\"],\"component---src-templates-post-tsx-content-file-path-src-content-반응형-퍼블리싱-스터디-회고-🤓-index-mdx\":[\"/component---src-templates-post-tsx-content-file-path-src-content-반응형-퍼블리싱-스터디-회고-🤓-index-mdx-a494152c4ad3eea29f47.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="aa3386511e978fdaea86";</script><script src="/webpack-runtime-6f68a2afd0846627683c.js" async></script><script src="/framework-53a942b5d852d3139bb2.js" async></script><script src="/app-14437606d336ce945417.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>