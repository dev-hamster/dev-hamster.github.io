"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[253],{5888:function(e,n,l){l.r(n),l.d(n,{default:function(){return p}});var t=l(1151),r=l(7294);function c(e){const n=Object.assign({h2:"h2",h3:"h3",p:"p",ul:"ul",li:"li",code:"code",pre:"pre",strong:"strong",a:"a",blockquote:"blockquote"},(0,t.a)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h2,null,"PICK-4"),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"pick을 사용하지 않고 Pick을 구현하는 문제이다."),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.code,null,"keyof")," 는 객체의 키 값들을 숫자나 문자열 리터럴 유니언을 생성한다."),"\n",r.createElement(n.li,null,r.createElement(n.code,null,"in")," 는 객체에 특정 속성이 존재하는지 확인할 수 있다."),"\n"),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MyPick<T, K extends keyof T> = {\n  [k in K]: T[k]\n}\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"K extends keyof T")," K는 T의 프로퍼티 이름을 가진다. 매핑된 타입을 이용하면 키를 통해 타입을 반복적으로 생성할 수 있고 인덱스 시그니처 문법으로 작성하면 된다."),"\n",r.createElement(n.h2,null,"Readonly"),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"Readonly 타입을 사용하지 않고 구현하는 문제이다."),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.code,null,"readonly")," 는 프로퍼티를 읽기 전용으로 지정할 수 있다."),"\n"),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MyReadonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Tuple to Object")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"각 원소의 값을 key/value로 갖는 오브젝트 타입을 반환하는 타입을 구현하는 문제이다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 배열의 원소의 값을 key/value로 갖는 타입을 반환한다.\n['tesla', 'model 3', 'model X', 'model Y']\n\n{ 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}\n")),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type TupleToObject<T extends readonly PropertyKey[]> = {\n  [P in T[number]] : P\n}\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"배열 순회하기: ",r.createElement(n.code,null,"T[number]"),"을 통해 배열을 순회하여 타입을 가져올 수 있다. ",r.createElement(n.code,null,"T[number]")," 은 인덱스가 숫자형인 요소들의 타입을 가져오므로 배열에 있는 모든 요소의 타입을 가져올 수 있다."),"\n",r.createElement(n.li,null,"PropertyKey: ",r.createElement(n.code,null,"keyof")," 를 통해 생성되는 key의 집합이다. 여기에는 string, number, symbol이 있다."),"\n"),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"First of Array")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"T"),"를 받아 첫번째 원소의 타입을 반환하는 제네릭 ",r.createElement(n.code,null,"First<T>"),"를 구현하는 문제이다."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 오답: 빈 배열인 경우 T[0]은 undefeind가 된다\ntype First<T extends any[]> = T[0] extends never ? never : T[0]; // 원소가 없다면 never 타입 반환\n\n// 정답1\ntype First<T extends unknown[]> = T[number] extends never ? never : T[0];\n// 정답2\ntype First<T extends unknown[]> = T extends [] ? never : T[0];\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"조건부 타입: 배열이 빈 배열이라면 ",r.createElement(n.code,null,"never")," 타입을 반환한다."),"\n"),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Length of Tuple")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"튜블(배열)의 길이를 반환하는 제네릭 타입을 구현하는 문제이다."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 오답: Length<5>인 경우 타입 에러가 나지 않는다.\ntype Length<T> = T extends readonly unknown[] ? T['length'] : never;\n")),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"<T extends readonly unknown[]>")," 는 T가 ",r.createElement(n.code,null,"readonly unknown[ ]"),"이라는 타입을 반드시 만족해야 하므로 배열이 아닌 경우 타입 에러를 발생한다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,'// 정답\ntype Length<T extends readonly unknown[]> = T["length"];\n')),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.code,null,"readonly"),": 튜플은 고정된 요소를 저장하므로 readonly이다."),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"T extends readonly unknown[]")," 에서 T가 배열 타입인지 조건부로 타입을 할당한다. 이런 경우 배열이 아닌 경우 ",r.createElement(n.code,null,"never"),"를 반환하기 때문에 타입 에러가 나지 않는다."),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Exclude")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"T에서 U에 할당할 수 있는 타입을 제외하는 내장 제네릭 Exclude를 사용하지 않고 구현하는 문제이다."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MyExclude<T, U> = T extends U ? never : T;\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.code,null,"Exclude"),": ",r.createElement(n.code,null,"Exclude<T, U>")," 는 U에 할당할 수 있는 타입을 제외한다. 차집합으로 이해할 수 있다."),"\n",r.createElement(n.li,null,"분배법칙: 조건부 타입에서 분배법칙이 적용된다. 예를 들어 ",r.createElement(n.code,null,"A | B | C extends U ? X : Y")," 는 ",r.createElement(n.code,null,"A extends U ? X : Y"),", ",r.createElement(n.code,null,"B extends U ? X : Y"),", ",r.createElement(n.code,null,"C extends U ? X : Y")," 가 된다. ",r.createElement(n.code,null,"T extends U ? X : Y")," 에서 T 유니언 타입은 개별 구성 요소를 확인한다."),"\n"),"\n",r.createElement(n.p,null,"T가 U에 속한다면, never를 반환한다."),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Awaited")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"Promise와 같은 타입에 감싸인 타입이 있을 때, 안에 감싸인 타입이 무엇인지 가르키는 타입을 구현하는 문제이다."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MyAwaited<T> = T extends PromiseLike<infer D> ? MyAwaited<D> : T;\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.p,null,"Promise에 감싸진 리턴 타입을 반환하기 위해 T가 Promise라면 Promise를 재귀적으로 풀어주고 그렇지 않다면 T를 반환하면 된다."),"\n",r.createElement(n.p,null,"예를 들어 타입 ",r.createElement(n.code,null,"X"),"에서 Promise로 감싸진 타입을 가져올 때 다음처럼 동작한다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MyAwaited<T> = T extends PromiseLike<infer D> ? MyAwaited<D> : T;\n\ntype X = Promise<string>\ntype Foo = MyAwaited<X> // string\n")),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"MyAwaited<Promise<string>>"),"은 ",r.createElement(n.code,null,"PromiseLike<infer D>"),"타입에 해당하므로 다시 ",r.createElement(n.code,null,"MyAwaited<D>")," 을 호출한다. 여기서 ",r.createElement(n.code,null,"infer D")," 로 string을 추론한다. ",r.createElement(n.code,null,"MyAwaited<string>")," 은 ",r.createElement(n.code,null,"PromiseLike"),"타입이 아니므로 타입 ",r.createElement(n.code,null,"string"),"을 반환한다."),"\n",r.createElement(n.h3,null,r.createElement(n.code,null,"infer"),"란?"),"\n",r.createElement(n.p,null,"조건부 타입에서 ",r.createElement(n.code,null,"infer")," 키워드를 이용해 새로운 타입 변수를 선언적으로 정의할 수 있다. ",r.createElement(n.code,null,"type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;")),"\n",r.createElement(n.h3,null,r.createElement(n.code,null,"Promise"),"가 아닌 ",r.createElement(n.code,null,"PromiseLike"),"를 사용하는 이유"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"Promise"),"가 아닌 ",r.createElement(n.code,null,"PromiseLike"),"를 사용하는 이유는 아래 테스트 케이스가 존재하기 때문이다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type T = { then: (onfulfilled: (arg: number) => any) => any }\n")),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"PromiseLike"),"타입에는 후속처리 메서드인 then만 가지고 있다. 이를 통해 커스텀 비동기 처리를 유연하게 정의할 수 있다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// https://github.com/microsoft/TypeScript/blob/main/src/lib/es5.d.ts\n\ninterface PromiseLike<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n      ): PromiseLike<TResult1 | TResult2>;\n}\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"If")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"조건 C가 참이면 A, 아니면 B를 반환하는 타입을 구현하자."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type If<C extends boolean, T, F> = C extends true ? T : F;\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.p,null,"C는 true, false만 가능하도록 ",r.createElement(n.code,null,"boolean")," 타입으로 제한하고 C 조건에 따라 T, F를 리턴하면 된다."),"\n",r.createElement(n.h2,null,"Concat"),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"Array.concat 함수를 타입 시스템에서 구현하자. 인수를 왼쪽부터 concat한 새로운 배열을 반환하자."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 오답\ntype Concat<T extends unknown[], U extends unknown[]> = [\n  T extends [] ? never : T[number],\n  U extends [] ? never : U[number]\n];\n\ntype Foo = Concat<['1', 2, 3], []>; // [2 | 3 | \"1\", never]\n")),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 정답\ntype Tuple = readonly unknown[];\ntype Concat<T extends Tuple, U extends Tuple> = [...T, ...U];\n\ntype Foo = Concat<['1', 2, 3], []>; //  [\"1\", 2, 3]\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.p,null,"T와 U를 concat할 수 있도록 T와 U를 배열로 타입을 제한했다. 요소의 타입으로 이루어진 튜플을 반환할 수 있도록 ",r.createElement(n.code,null,"T[number]")," 를 했다. 그러나 ",r.createElement(n.code,null,"T[number]"),"는 배열의 요소 타입으로 이뤄진 유니언 타입을 추출한다. 그리고 빈 배열인 경우 never 타입이 반환되므로 오답이다."),"\n",r.createElement(n.p,null,"여기서 T와 U를 배열타입으로 제한했으므로 열거 가능하다."),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Includes")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"JavaScript의 ",r.createElement(n.code,null,"Array.includes")," 함수를 타입 시스템에서 구현하세요. 타입은 두 인수를 받고, ",r.createElement(n.code,null,"true")," 또는 ",r.createElement(n.code,null,"false"),"를 반환하자."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 오답\ntype Includes<T extends readonly unknown[], U> = U extends T[number] ? true : false;\n")),"\n",r.createElement(n.p,null,"T 배열의 요소를 키로 갖는 타입을 만들고 U가 T의 키인지 확인하면 해결할 수 있을 것 같지만, U가 프로퍼티 키로 사용할 수 있을 때만 통과된다. (",r.createElement(n.a,{href:"https://github.com/type-challenges/type-challenges/issues/1568"},"참고"),")"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 오답\ntype Includes<T extends readonly any[], U> = {\n  [P in T[number]]: true\n}[U] extends true ? true : false;\n")),"\n",r.createElement(n.p,null,"이를 해결하기 위해 배열의 첫번째 요소와 타입이 같은지 재귀적으로 타입을 확인해야 한다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"// 정답\ntype Includes<T extends readonly unknown[], U> =\n  T extends [infer First, ...infer Rest]\n    ? Equal<First, U> extends true ? true : Includes<Rest, U>\n    : false;\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.p,null,"U가 T의 구성 요소인지 확인하기 위해 T를 인덱스 접근 타입으로 변경하고 U가 이 유니온 타입에 속하는지 조건부로 true 또는 false를 반환한다. 그런데 이 코드는 primitive type만 통과하고 객체나 타입 자체는 통과하지 않는다. 예를 들어 ",r.createElement(n.code,null,"{ a: 'A'}")," 는 ",r.createElement(n.code,null,"{ }"),"의 서브 타입으로 true를 반환한다."),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,r.createElement(n.code,null,"infer")," 키워드를 복습하고 가자. ",r.createElement(n.code,null,"infer"),"은 조건부 타입에서 ",r.createElement(n.strong,null,"참으로 평가"),"될 때 사용할 수 있는 타입을 추론하는 데 사용한다."),"\n"),"\n",r.createElement(n.p,null,"참고로 ",r.createElement(n.code,null,"@type-challenges/utils")," 의 Equal은 아래처럼 구현되어 있다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"Equal<X, Y> =\n    (<T>() => T extends X ? 1 : 2) extends\n    (<T>() => T extends Y ? 1 : 2) ? true : false;\n")),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Push")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"Array.push"),"의 제네릭 버전을 구현하자."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Push<T extends unknown[], U> = [...T, U];\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.p,null,"T를 배열로 타입을 제한하고 배열 디스트럭쳐링을 이용해 배열 타입을 반환한다."),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Unshift")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"Array.unshift"),"의 타입 버전을 구현하자."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type Unshift<T extends unknown[], U> = [U, ...T];\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.p,null,"Push 문제와 동일하다. T와 U 순서만 바꿔주면 된다."),"\n",r.createElement(n.h2,null,r.createElement(n.strong,null,"Parameters")),"\n",r.createElement(n.h3,null,"문제"),"\n",r.createElement(n.p,null,"내장 제네릭 ",r.createElement(n.code,null,"Parameters<T>"),"를 이를 사용하지 않고 구현하자."),"\n",r.createElement(n.h3,null,"코드"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MyParameters<T> = T extends (...args: infer D) => unknown ? D : any;\n\nconst temp = ['1'];\ntype x = MyParameters<typeof temp>; // 타입 에러가 나지 않는다.\n")),"\n",r.createElement(n.p,null,"타입 에러가 나지 않는데, 이를 막으려면 타입 T를 함수로 제한하면 된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"type MyParameters<T extends (...args: any[]) => any> = T extends (...any: infer S) => any ? S : any\n")),"\n",r.createElement(n.h3,null,"풀이"),"\n",r.createElement(n.p,null,"조건부 타입으로 함수 타입이라면 args를 추론한 D 타입을 반환한다. 하지만 T타입이 함수로 제한하지 않아 함수가 아닌 타입에서 에러가 나지 않아서 아쉽다."))}var a=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,t.a)(),e.components);return n?r.createElement(n,e,r.createElement(c,e)):c(e)},u=l(4160),m=l(4098),o=l(1858),E=l(8032),s=l(9542);const d={Link:u.rU};function i(e){let{data:n,children:l}=e;const{frontmatter:c}=n.mdx,a=(0,s.E)(c.thumbnail);return r.createElement(r.Fragment,null,r.createElement(m.h,null),r.createElement(o.A,null,r.createElement(t.Z,{components:Object.assign({ul:e=>r.createElement("ul",Object.assign({},e,{style:{listStyle:"revert"}})),ol:e=>r.createElement("ul",Object.assign({},e,{style:{listStyleType:"decimal"}}))},d)},r.createElement("article",{className:"markdown-body"},r.createElement("h1",null,c.title),a&&r.createElement("div",{style:{position:"relative",width:"100%",paddingBottom:"56.25%"}},r.createElement(E.G,{image:a,alt:c.title,className:"absolute top-0 left-0 w-full h-full object-cover"})),l))))}function p(e){return r.createElement(i,e,r.createElement(a,e))}},9542:function(e,n,l){l.d(n,{E:function(){return t}});const t=e=>{if(e)return"childImageSharp"in e?e.childImageSharp.gatsbyImageData:e}},1151:function(e,n,l){l.d(n,{Z:function(){return u},a:function(){return a}});var t=l(7294);const r={},c=t.createContext(r);function a(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-content-type-challenges-easy-index-mdx-e8f6cb4f46b3a61f0d60.js.map